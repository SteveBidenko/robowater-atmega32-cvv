
;CodeVisionAVR C Compiler V2.03.9 Standard
;(C) Copyright 1998-2008 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com

;Chip type              : ATmega32
;Program type           : Application
;Clock frequency        : 3,686400 MHz
;Memory model           : Small
;Optimize for           : Size
;(s)printf features     : int, width
;(s)scanf features      : int, width
;External RAM size      : 0
;Data Stack size        : 256 byte(s)
;Heap size              : 0 byte(s)
;Promote char to int    : No
;char is unsigned       : Yes
;global const stored in FLASH  : Yes
;8 bit enums            : Yes
;Enhanced core instructions    : On
;Smart register allocation : Off
;Automatic register allocation : On

	#pragma AVRPART ADMIN PART_NAME ATmega32
	#pragma AVRPART MEMORY PROG_FLASH 32768
	#pragma AVRPART MEMORY EEPROM 1024
	#pragma AVRPART MEMORY INT_SRAM SIZE 2048
	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60

	.LISTMAC
	.EQU UDRE=0x5
	.EQU RXC=0x7
	.EQU USR=0xB
	.EQU UDR=0xC
	.EQU SPSR=0xE
	.EQU SPDR=0xF
	.EQU EERE=0x0
	.EQU EEWE=0x1
	.EQU EEMWE=0x2
	.EQU EECR=0x1C
	.EQU EEDR=0x1D
	.EQU EEARL=0x1E
	.EQU EEARH=0x1F
	.EQU WDTCR=0x21
	.EQU MCUCR=0x35
	.EQU GICR=0x3B
	.EQU SPL=0x3D
	.EQU SPH=0x3E
	.EQU SREG=0x3F

	.DEF R0X0=R0
	.DEF R0X1=R1
	.DEF R0X2=R2
	.DEF R0X3=R3
	.DEF R0X4=R4
	.DEF R0X5=R5
	.DEF R0X6=R6
	.DEF R0X7=R7
	.DEF R0X8=R8
	.DEF R0X9=R9
	.DEF R0XA=R10
	.DEF R0XB=R11
	.DEF R0XC=R12
	.DEF R0XD=R13
	.DEF R0XE=R14
	.DEF R0XF=R15
	.DEF R0X10=R16
	.DEF R0X11=R17
	.DEF R0X12=R18
	.DEF R0X13=R19
	.DEF R0X14=R20
	.DEF R0X15=R21
	.DEF R0X16=R22
	.DEF R0X17=R23
	.DEF R0X18=R24
	.DEF R0X19=R25
	.DEF R0X1A=R26
	.DEF R0X1B=R27
	.DEF R0X1C=R28
	.DEF R0X1D=R29
	.DEF R0X1E=R30
	.DEF R0X1F=R31

	.MACRO __CPD1N
	CPI  R30,LOW(@0)
	LDI  R26,HIGH(@0)
	CPC  R31,R26
	LDI  R26,BYTE3(@0)
	CPC  R22,R26
	LDI  R26,BYTE4(@0)
	CPC  R23,R26
	.ENDM

	.MACRO __CPD2N
	CPI  R26,LOW(@0)
	LDI  R30,HIGH(@0)
	CPC  R27,R30
	LDI  R30,BYTE3(@0)
	CPC  R24,R30
	LDI  R30,BYTE4(@0)
	CPC  R25,R30
	.ENDM

	.MACRO __CPWRR
	CP   R@0,R@2
	CPC  R@1,R@3
	.ENDM

	.MACRO __CPWRN
	CPI  R@0,LOW(@2)
	LDI  R30,HIGH(@2)
	CPC  R@1,R30
	.ENDM

	.MACRO __ADDB1MN
	SUBI R30,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDB2MN
	SUBI R26,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDW1MN
	SUBI R30,LOW(-@0-(@1))
	SBCI R31,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW2MN
	SUBI R26,LOW(-@0-(@1))
	SBCI R27,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	SBCI R22,BYTE3(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1N
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	SBCI R22,BYTE3(-@0)
	SBCI R23,BYTE4(-@0)
	.ENDM

	.MACRO __ADDD2N
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	SBCI R24,BYTE3(-@0)
	SBCI R25,BYTE4(-@0)
	.ENDM

	.MACRO __SUBD1N
	SUBI R30,LOW(@0)
	SBCI R31,HIGH(@0)
	SBCI R22,BYTE3(@0)
	SBCI R23,BYTE4(@0)
	.ENDM

	.MACRO __SUBD2N
	SUBI R26,LOW(@0)
	SBCI R27,HIGH(@0)
	SBCI R24,BYTE3(@0)
	SBCI R25,BYTE4(@0)
	.ENDM

	.MACRO __ANDBMNN
	LDS  R30,@0+@1
	ANDI R30,LOW(@2)
	STS  @0+@1,R30
	.ENDM

	.MACRO __ANDWMNN
	LDS  R30,@0+@1
	ANDI R30,LOW(@2)
	STS  @0+@1,R30
	LDS  R30,@0+@1+1
	ANDI R30,HIGH(@2)
	STS  @0+@1+1,R30
	.ENDM

	.MACRO __ANDD1N
	ANDI R30,LOW(@0)
	ANDI R31,HIGH(@0)
	ANDI R22,BYTE3(@0)
	ANDI R23,BYTE4(@0)
	.ENDM

	.MACRO __ANDD2N
	ANDI R26,LOW(@0)
	ANDI R27,HIGH(@0)
	ANDI R24,BYTE3(@0)
	ANDI R25,BYTE4(@0)
	.ENDM

	.MACRO __ORBMNN
	LDS  R30,@0+@1
	ORI  R30,LOW(@2)
	STS  @0+@1,R30
	.ENDM

	.MACRO __ORWMNN
	LDS  R30,@0+@1
	ORI  R30,LOW(@2)
	STS  @0+@1,R30
	LDS  R30,@0+@1+1
	ORI  R30,HIGH(@2)
	STS  @0+@1+1,R30
	.ENDM

	.MACRO __ORD1N
	ORI  R30,LOW(@0)
	ORI  R31,HIGH(@0)
	ORI  R22,BYTE3(@0)
	ORI  R23,BYTE4(@0)
	.ENDM

	.MACRO __ORD2N
	ORI  R26,LOW(@0)
	ORI  R27,HIGH(@0)
	ORI  R24,BYTE3(@0)
	ORI  R25,BYTE4(@0)
	.ENDM

	.MACRO __DELAY_USB
	LDI  R24,LOW(@0)
__DELAY_USB_LOOP:
	DEC  R24
	BRNE __DELAY_USB_LOOP
	.ENDM

	.MACRO __DELAY_USW
	LDI  R24,LOW(@0)
	LDI  R25,HIGH(@0)
__DELAY_USW_LOOP:
	SBIW R24,1
	BRNE __DELAY_USW_LOOP
	.ENDM

	.MACRO __GETD1S
	LDD  R30,Y+@0
	LDD  R31,Y+@0+1
	LDD  R22,Y+@0+2
	LDD  R23,Y+@0+3
	.ENDM

	.MACRO __PUTD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R31
	STD  Y+@0+2,R22
	STD  Y+@0+3,R23
	.ENDM

	.MACRO __PUTD2S
	STD  Y+@0,R26
	STD  Y+@0+1,R27
	STD  Y+@0+2,R24
	STD  Y+@0+3,R25
	.ENDM

	.MACRO __POINTB1MN
	LDI  R30,LOW(@0+@1)
	.ENDM

	.MACRO __POINTW1MN
	LDI  R30,LOW(@0+@1)
	LDI  R31,HIGH(@0+@1)
	.ENDM

	.MACRO __POINTD1M
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __POINTW1FN
	LDI  R30,LOW(2*@0+@1)
	LDI  R31,HIGH(2*@0+@1)
	.ENDM

	.MACRO __POINTD1FN
	LDI  R30,LOW(2*@0+@1)
	LDI  R31,HIGH(2*@0+@1)
	LDI  R22,BYTE3(2*@0+@1)
	LDI  R23,BYTE4(2*@0+@1)
	.ENDM

	.MACRO __POINTB2MN
	LDI  R26,LOW(@0+@1)
	.ENDM

	.MACRO __POINTW2MN
	LDI  R26,LOW(@0+@1)
	LDI  R27,HIGH(@0+@1)
	.ENDM

	.MACRO __POINTBRM
	LDI  R@0,LOW(@1)
	.ENDM

	.MACRO __POINTWRM
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __POINTBRMN
	LDI  R@0,LOW(@1+@2)
	.ENDM

	.MACRO __POINTWRMN
	LDI  R@0,LOW(@2+@3)
	LDI  R@1,HIGH(@2+@3)
	.ENDM

	.MACRO __POINTWRFN
	LDI  R@0,LOW(@2*2+@3)
	LDI  R@1,HIGH(@2*2+@3)
	.ENDM

	.MACRO __GETD1N
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __GETD2N
	LDI  R26,LOW(@0)
	LDI  R27,HIGH(@0)
	LDI  R24,BYTE3(@0)
	LDI  R25,BYTE4(@0)
	.ENDM

	.MACRO __GETD2S
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	LDD  R24,Y+@0+2
	LDD  R25,Y+@0+3
	.ENDM

	.MACRO __GETB1MN
	LDS  R30,@0+@1
	.ENDM

	.MACRO __GETB1HMN
	LDS  R31,@0+@1
	.ENDM

	.MACRO __GETW1MN
	LDS  R30,@0+@1
	LDS  R31,@0+@1+1
	.ENDM

	.MACRO __GETD1MN
	LDS  R30,@0+@1
	LDS  R31,@0+@1+1
	LDS  R22,@0+@1+2
	LDS  R23,@0+@1+3
	.ENDM

	.MACRO __GETBRMN
	LDS  R@0,@1+@2
	.ENDM

	.MACRO __GETWRMN
	LDS  R@0,@2+@3
	LDS  R@1,@2+@3+1
	.ENDM

	.MACRO __GETWRZ
	LDD  R@0,Z+@2
	LDD  R@1,Z+@2+1
	.ENDM

	.MACRO __GETD2Z
	LDD  R26,Z+@0
	LDD  R27,Z+@0+1
	LDD  R24,Z+@0+2
	LDD  R25,Z+@0+3
	.ENDM

	.MACRO __GETB2MN
	LDS  R26,@0+@1
	.ENDM

	.MACRO __GETW2MN
	LDS  R26,@0+@1
	LDS  R27,@0+@1+1
	.ENDM

	.MACRO __GETD2MN
	LDS  R26,@0+@1
	LDS  R27,@0+@1+1
	LDS  R24,@0+@1+2
	LDS  R25,@0+@1+3
	.ENDM

	.MACRO __PUTB1MN
	STS  @0+@1,R30
	.ENDM

	.MACRO __PUTW1MN
	STS  @0+@1,R30
	STS  @0+@1+1,R31
	.ENDM

	.MACRO __PUTD1MN
	STS  @0+@1,R30
	STS  @0+@1+1,R31
	STS  @0+@1+2,R22
	STS  @0+@1+3,R23
	.ENDM

	.MACRO __PUTB1EN
	LDI  R26,LOW(@0+@1)
	LDI  R27,HIGH(@0+@1)
	CALL __EEPROMWRB
	.ENDM

	.MACRO __PUTW1EN
	LDI  R26,LOW(@0+@1)
	LDI  R27,HIGH(@0+@1)
	CALL __EEPROMWRW
	.ENDM

	.MACRO __PUTD1EN
	LDI  R26,LOW(@0+@1)
	LDI  R27,HIGH(@0+@1)
	CALL __EEPROMWRD
	.ENDM

	.MACRO __PUTBR0MN
	STS  @0+@1,R0
	.ENDM

	.MACRO __PUTDZ2
	STD  Z+@0,R26
	STD  Z+@0+1,R27
	STD  Z+@0+2,R24
	STD  Z+@0+3,R25
	.ENDM

	.MACRO __PUTBMRN
	STS  @0+@1,R@2
	.ENDM

	.MACRO __PUTWMRN
	STS  @0+@1,R@2
	STS  @0+@1+1,R@3
	.ENDM

	.MACRO __PUTBZR
	STD  Z+@1,R@0
	.ENDM

	.MACRO __PUTWZR
	STD  Z+@2,R@0
	STD  Z+@2+1,R@1
	.ENDM

	.MACRO __GETW1R
	MOV  R30,R@0
	MOV  R31,R@1
	.ENDM

	.MACRO __GETW2R
	MOV  R26,R@0
	MOV  R27,R@1
	.ENDM

	.MACRO __GETWRN
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __PUTW1R
	MOV  R@0,R30
	MOV  R@1,R31
	.ENDM

	.MACRO __PUTW2R
	MOV  R@0,R26
	MOV  R@1,R27
	.ENDM

	.MACRO __ADDWRN
	SUBI R@0,LOW(-@2)
	SBCI R@1,HIGH(-@2)
	.ENDM

	.MACRO __ADDWRR
	ADD  R@0,R@2
	ADC  R@1,R@3
	.ENDM

	.MACRO __SUBWRN
	SUBI R@0,LOW(@2)
	SBCI R@1,HIGH(@2)
	.ENDM

	.MACRO __SUBWRR
	SUB  R@0,R@2
	SBC  R@1,R@3
	.ENDM

	.MACRO __ANDWRN
	ANDI R@0,LOW(@2)
	ANDI R@1,HIGH(@2)
	.ENDM

	.MACRO __ANDWRR
	AND  R@0,R@2
	AND  R@1,R@3
	.ENDM

	.MACRO __ORWRN
	ORI  R@0,LOW(@2)
	ORI  R@1,HIGH(@2)
	.ENDM

	.MACRO __ORWRR
	OR   R@0,R@2
	OR   R@1,R@3
	.ENDM

	.MACRO __EORWRR
	EOR  R@0,R@2
	EOR  R@1,R@3
	.ENDM

	.MACRO __GETWRS
	LDD  R@0,Y+@2
	LDD  R@1,Y+@2+1
	.ENDM

	.MACRO __PUTWSR
	STD  Y+@2,R@0
	STD  Y+@2+1,R@1
	.ENDM

	.MACRO __MOVEWRR
	MOV  R@0,R@2
	MOV  R@1,R@3
	.ENDM

	.MACRO __INWR
	IN   R@0,@2
	IN   R@1,@2+1
	.ENDM

	.MACRO __OUTWR
	OUT  @2+1,R@1
	OUT  @2,R@0
	.ENDM

	.MACRO __CALL1MN
	LDS  R30,@0+@1
	LDS  R31,@0+@1+1
	ICALL
	.ENDM

	.MACRO __CALL1FN
	LDI  R30,LOW(2*@0+@1)
	LDI  R31,HIGH(2*@0+@1)
	CALL __GETW1PF
	ICALL
	.ENDM

	.MACRO __CALL2EN
	LDI  R26,LOW(@0+@1)
	LDI  R27,HIGH(@0+@1)
	CALL __EEPROMRDW
	ICALL
	.ENDM

	.MACRO __GETW1STACK
	IN   R26,SPL
	IN   R27,SPH
	ADIW R26,@0+1
	LD   R30,X+
	LD   R31,X
	.ENDM

	.MACRO __NBST
	BST  R@0,@1
	IN   R30,SREG
	LDI  R31,0x40
	EOR  R30,R31
	OUT  SREG,R30
	.ENDM


	.MACRO __PUTB1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RNS
	MOVW R26,R@0
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	CALL __PUTDP1
	.ENDM


	.MACRO __GETB1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R30,Z
	.ENDM

	.MACRO __GETB1HSX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	.ENDM

	.MACRO __GETW1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R31,Z
	MOV  R30,R0
	.ENDM

	.MACRO __GETD1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R1,Z+
	LD   R22,Z+
	LD   R23,Z
	MOVW R30,R0
	.ENDM

	.MACRO __GETB2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R26,X
	.ENDM

	.MACRO __GETW2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	.ENDM

	.MACRO __GETD2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R1,X+
	LD   R24,X+
	LD   R25,X
	MOVW R26,R0
	.ENDM

	.MACRO __GETBRSX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	LD   R@0,Z
	.ENDM

	.MACRO __GETWRSX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	LD   R@0,Z+
	LD   R@1,Z
	.ENDM

	.MACRO __LSLW8SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	CLR  R30
	.ENDM

	.MACRO __PUTB1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __CLRW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __CLRD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R30
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __PUTB2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z,R26
	.ENDM

	.MACRO __PUTW2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z,R27
	.ENDM

	.MACRO __PUTD2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z+,R27
	ST   Z+,R24
	ST   Z,R25
	.ENDM

	.MACRO __PUTBSRX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z,R@1
	.ENDM

	.MACRO __PUTWSRX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	ST   Z+,R@0
	ST   Z,R@1
	.ENDM

	.MACRO __PUTB1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __MULBRR
	MULS R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRRU
	MUL  R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRR0
	MULS R@0,R@1
	.ENDM

	.MACRO __MULBRRU0
	MUL  R@0,R@1
	.ENDM

	.MACRO __MULBNWRU
	LDI  R26,@2
	MUL  R26,R@0
	MOVW R30,R0
	MUL  R26,R@1
	ADD  R31,R0
	.ENDM

;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
	.DEF _tmp_delta=R4
	.DEF _tap_angle_min=R6

	.CSEG
	.ORG 0x00

;INTERRUPT VECTORS
	JMP  __RESET
	JMP  _ext_int0_isr
	JMP  _ext_int1_isr
	JMP  _ext_int2_isr
	JMP  0x00
	JMP  _timer2_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer1_ovf_isr
	JMP  0x00
	JMP  _timer0_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00

_all_menu_str:
	.DB  0xCF,0xEE,0xEC,0xE5,0xF9,0xE5,0xED,0xE8
	.DB  0xE5,0x20,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD0,0xC5,0xC6,0xC8,0xCC,0x20,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD1,0xC5,0xC7,0xCE,0xCD,0x20,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x2E,0x20,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCF,0xE0,0xF0,0xE0,0xEC,0xE5,0xF2,0xF0
	.DB  0xFB,0x20,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xC0,0xC2,0xC0,0xD0,0xC8,0xC9,0x20,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCD,0xC0,0xD1,0xD2,0xD0,0xCE,0xC9,0xCA
	.DB  0xC0,0x2E,0x2E,0x2E,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x2E,0xD7,0xE0,0xF1,0x2E
	.DB  0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x20,0xCC,0xE8,0xED,0x20
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x2E,0xE4,0xE5,0xED,0xFC
	.DB  0x2E,0x20,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x20,0xCC,0xE5,0xF1,0x2E
	.DB  0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x20,0xC3,0xCE,0xC4,0x2E
	.DB  0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCF,0xCE,0xCC,0xC5,0xD9,0x2E,0x20,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xCB,0x2E,0xD2,0x20,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x2E,0xD2,0x20,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xC2,0xEE,0xE4,0x20,0xC2,0xD5,0x2E,0x20
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xC2,0xEE,0xE4,0x20,0xC2,0xDB,0xD5,0x2E
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCA,0xD0,0xC0,0xCD,0x20,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xD1,0xD2,0x2E,0xCA,0xD0,0xC0,0xCD
	.DB  0x2E,0x20,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xC2,0xC5,0xCD,0xD2,0xC8,0xCB,0xDF,0xD2
	.DB  0xCE,0xD0,0x20,0x0,0x0,0x0,0x0,0x0
	.DB  0xD3,0xF1,0xF2,0x2E,0x20,0xC2,0xC5,0xCD
	.DB  0xD2,0x2E,0x20,0x0,0x0,0x0,0x0,0x0
	.DB  0xC7,0xC0,0xD1,0xCB,0x2E,0x20,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCD,0xC0,0xD1,0xCE,0xD1,0x20,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x54,0x41,0x20,0x49,0x4E,0x20,0x4D,0x69
	.DB  0x6E,0x20,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x54,0x57,0x20,0x53,0x54,0x4F,0x50,0x20
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x54,0x57,0x20,0x4D,0x69,0x6E,0x20,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x54,0x41,0x20,0x4D,0x69,0x6E,0x20,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCF,0xD0,0xCE,0xC3,0xD0,0xC5,0xC2,0x20
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xC2,0xD0,0x2E,0xC8,0xCD,0xD2,0x2E,0x20
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCA,0xD3,0x3D,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCA,0xC8,0x3D,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCA,0xC4,0x3D,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD1,0xEC,0x2E,0xCF,0x2E,0x3D,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD8,0xEA,0x2E,0xCF,0x2E,0x3D,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD1,0xEC,0x2E,0xD3,0xEB,0x2E,0x3D,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD8,0xEA,0x2E,0xD3,0xEB,0x2E,0x3D,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD1,0xEC,0x2E,0xC2,0xC2,0xF5,0x3D,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD8,0xEA,0x2E,0xC2,0xC2,0xF5,0x3D,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD1,0xEC,0x2E,0xC2,0xC2,0xFB,0xF5,0x3D
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD8,0xEA,0x2E,0xC2,0xC2,0xFB,0xF5,0x3D
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xD1,0xE5,0xE7,0xEE,0xED,0x3D,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCF,0xE0,0xF0,0xEE,0xEB,0xFC,0x3D,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
_all_alerts:
	.DB  0xD2,0xE5,0xF0,0xEC,0xEE,0xE7,0xE0,0xF9
	.DB  0xE8,0xF2,0xE0,0x20,0x0,0x0,0x0,0x0
	.DB  0xC7,0xE0,0xEC,0xE5,0xF0,0xE7,0xE0,0xED
	.DB  0xE8,0xE5,0x20,0x0,0x0,0x0,0x0,0x0
	.DB  0xD2,0xE5,0xEC,0xEF,0x2E,0xE2,0xEE,0xE7
	.DB  0xE4,0x2E,0xE2,0xF5,0x20,0x0,0x0,0x0
	.DB  0xD2,0x2E,0xE2,0xEE,0xE7,0xE4,0x2E,0xE2
	.DB  0xFB,0xF5,0x2E,0x20,0x0,0x0,0x0,0x0
	.DB  0xD2,0xE5,0xEC,0xEF,0x2E,0xE2,0xEE,0xE4
	.DB  0xFB,0x20,0xE2,0xF5,0x20,0x0,0x0,0x0
	.DB  0xD2,0x2E,0xE2,0xEE,0xE4,0xFB,0x20,0xE2
	.DB  0xFB,0xF5,0x2E,0x0,0x0,0x0,0x0,0x0
	.DB  0xCD,0xE5,0xF2,0x20,0xF1,0xE2,0xFF,0xE7
	.DB  0xE8,0x20,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xCD,0xE5,0xF2,0x20,0xF2,0xE5,0xF0,0xEC
	.DB  0x2E,0x42,0x31,0x20,0x0,0x0,0x0,0x0
	.DB  0xCD,0xE5,0xF2,0x20,0xF2,0xE5,0xF0,0xEC
	.DB  0x2E,0x42,0x32,0x20,0x0,0x0,0x0,0x0
	.DB  0xCD,0xE5,0xF2,0x20,0xF2,0xE5,0xF0,0xEC
	.DB  0x2E,0x42,0x33,0x20,0x0,0x0,0x0,0x0
	.DB  0xCD,0xE5,0xF2,0x20,0xF2,0xE5,0xF0,0xEC
	.DB  0x2E,0x42,0x34,0x20,0x0,0x0,0x0,0x0
	.DB  0xD4,0xE8,0xEB,0xFC,0xF2,0xF0,0x20,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
_tbl10_G101:
	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
	.DB  0x1,0x0
_tbl16_G101:
	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0

;DATA STACK END MARKER INITIALIZATION
__DSTACK_END:
	.DB  'D','S','T','A','C','K','E','N','D',0

;HARDWARE STACK END MARKER INITIALIZATION
__HSTACK_END:
	.DB  'H','S','T','A','C','K','E','N','D',0

_0x0:
	.DB  0xCF,0xD3,0xD1,0xCA,0x20,0xD,0xA,0x0
	.DB  0xCF,0xEE,0xE8,0xF1,0xEA,0x20,0xE2,0xF1
	.DB  0xE5,0xF5,0x20,0xF2,0xE5,0xF0,0xEC,0xEE
	.DB  0xEC,0xE5,0xF2,0xF0,0xEE,0xE2,0x20,0xED
	.DB  0xE0,0x20,0xF8,0xE8,0xED,0xE5,0x20,0x31
	.DB  0x2D,0x57,0x69,0x72,0x65,0x2E,0x20,0xCD
	.DB  0xE0,0xE9,0xE4,0xE5,0xED,0xEE,0x3A,0x20
	.DB  0x0,0x25,0x64,0x20,0xF8,0xF2,0xF3,0xEA
	.DB  0xD,0xA,0x0,0xD1,0xF2,0xE0,0xF0,0xF2
	.DB  0x20,0xE8,0xED,0xE8,0xF6,0xE8,0xE0,0xEB
	.DB  0xE8,0xE7,0xE0,0xF6,0xE8,0xE8,0x20,0xEF
	.DB  0xE5,0xF0,0xE8,0xF4,0xE5,0xF0,0xE8,0xE8
	.DB  0x2E,0x2E,0x2E,0xD,0xA,0x0
_0x2001E:
	.DB  0x41,0xA0,0x42,0xA1,0xE0,0x45,0xA3,0xA4
	.DB  0xA5,0xA6,0x4B,0xA7,0x4D,0x48,0x4F,0xA8
	.DB  0x50,0x43,0x54,0xA9,0xAA,0x58,0xE1,0xAB
	.DB  0xAC,0xE2,0xAD,0xAE,0xAD,0xAF,0xB0,0xB1
	.DB  0x61,0xB2,0xB3,0xB4,0xE3,0x65,0xB6,0xB7
	.DB  0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0x6F,0xBE
	.DB  0x70,0x63,0xBF,0x79,0xE4,0x78,0xE5,0xC0
	.DB  0xC1,0xE6,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7
_0x40003:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x1
_0x40004:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0xFF,0xCD,0x7F,0x7F
	.DB  0xA,0x0,0x0,0x0,0x0,0x0,0xB4,0x0
	.DB  0x64,0x0,0x40,0x6,0x88,0x13,0x30,0xF8
	.DB  0xDC,0x5,0x98,0x8,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x1,0x0,0x0,0x4,0x28,0x95,0xF,0x7E
	.DB  0x3,0x0,0x0,0x72,0x1,0x28,0xC1,0x1A
	.DB  0x7E,0x3,0x0,0x0,0x2E,0x1,0x28,0x1A
	.DB  0x17,0x7E,0x3,0x0,0x0,0xFE,0x1,0x28
	.DB  0xE8,0x2A,0x7E,0x3,0x0,0x0,0x8A,0x1
_0x4016C:
	.DB  0x0
_0x40000:
	.DB  0xC8,0xED,0xE8,0xF6,0xE8,0xE0,0xEB,0xE8
	.DB  0xE7,0xE0,0xF6,0xE8,0xFF,0x20,0xEA,0xED
	.DB  0xEE,0xEF,0xEE,0xEA,0x2E,0x2E,0x2E,0xD
	.DB  0xA,0x0,0xD1,0xF2,0xE0,0xF0,0xF2,0x20
	.DB  0xCD,0xFC,0xFE,0xF2,0xEE,0xED,0xE0,0x20
	.DB  0xEC,0xE5,0xF2,0xE0,0xEB,0xEE,0xE8,0xE7
	.DB  0xE4,0xE5,0xEB,0xE8,0xFF,0x20,0xCF,0x32
	.DB  0x5F,0x31,0x2E,0x20,0x25,0x75,0x2E,0x25
	.DB  0x30,0x32,0x75,0x2E,0x20,0xCD,0xE0,0xE9
	.DB  0xE4,0xE5,0xED,0xEE,0x20,0x25,0x75,0x20
	.DB  0xF2,0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2
	.DB  0xF0,0xEE,0xE2,0x2E,0xD,0xA,0x0,0xC7
	.DB  0xE0,0xEF,0xE8,0xF1,0xFC,0x20,0xE2,0x20
	.DB  0x45,0x45,0x50,0x52,0x4F,0x4D,0x20,0xE7
	.DB  0xE0,0xE2,0xEE,0xE4,0xF1,0xEA,0xE8,0xF5
	.DB  0x20,0xF3,0xF1,0xF2,0xE0,0xED,0xEE,0xE2
	.DB  0xEE,0xEA,0x2E,0xD,0xA,0x20,0xCD,0xE5
	.DB  0xEE,0xEF,0xEE,0xE7,0xED,0xE0,0xED,0xED
	.DB  0xFB,0xF5,0x20,0xF2,0xE5,0xF0,0xEC,0xEE
	.DB  0xEC,0xE5,0xF2,0xF0,0xEE,0xE2,0x20,0x3D
	.DB  0x20,0x25,0x75,0xD,0xA,0x0,0xC7,0xE0
	.DB  0xEF,0xE8,0xF1,0xFC,0x20,0xE2,0x20,0x45
	.DB  0x45,0x50,0x52,0x4F,0x4D,0x20,0xF3,0xF1
	.DB  0xF2,0xE0,0xED,0xEE,0xE2,0xEE,0xEA,0x20
	.DB  0xEF,0xEE,0x20,0xF3,0xEC,0xEE,0xEB,0xF7
	.DB  0xE0,0xED,0xE8,0xFE,0x2E,0xD,0xA,0x0
	.DB  0xC7,0xE0,0xEF,0xE8,0xF1,0xFC,0x20,0xE2
	.DB  0x20,0x45,0x45,0x50,0x52,0x4F,0x4D,0x20
	.DB  0x25,0x75,0x20,0xED,0xEE,0xE2,0xFB,0xF5
	.DB  0x20,0xF2,0xE5,0xF0,0xEC,0xEE,0xEC,0xE5
	.DB  0xF2,0xF0,0xEE,0xE2,0x2E,0xD,0xA,0x0
	.DB  0xD3,0xF1,0xF2,0xE0,0xED,0xEE,0xE2,0xEA
	.DB  0xE0,0x20,0xE2,0xE5,0xED,0xF2,0xE8,0xEB
	.DB  0xFF,0xF2,0xEE,0xF0,0xE0,0x2E,0x20,0x25
	.DB  0x75,0x2E,0x20,0xD3,0xF1,0xF2,0xE0,0xED
	.DB  0xEE,0xE2,0xEA,0xE0,0x20,0xEA,0xF0,0xE0
	.DB  0xED,0xE0,0x20,0x25,0x75,0x20,0x2E,0xD
	.DB  0xA,0x0,0x2D,0x0,0xC4,0xEE,0x20,0xF1
	.DB  0xEB,0xE5,0xE4,0xF3,0xFE,0xF9,0xE5,0xE3
	.DB  0xEE,0x20,0xE8,0xE7,0xEC,0xE5,0xF0,0xE5
	.DB  0xED,0xE8,0xFF,0x20,0xCF,0xD3,0xD1,0xCA
	.DB  0x3A,0x20,0x25,0x75,0xD,0xA,0x0,0xC4
	.DB  0xEE,0x20,0xF1,0xEB,0xE5,0xE4,0xF3,0xFE
	.DB  0xF9,0xE5,0xE3,0xEE,0x20,0xE8,0xE7,0xEC
	.DB  0xE5,0xF0,0xE5,0xED,0xE8,0xFF,0x20,0xD1
	.DB  0xD2,0xCE,0xCF,0x3A,0x20,0x25,0x75,0xD
	.DB  0xA,0x0,0xCD,0xE0,0xE6,0xE0,0xF2,0xE0
	.DB  0x20,0xEA,0xED,0xEE,0xEF,0xEA,0xE0,0x20
	.DB  0xCF,0xD3,0xD1,0xCA,0x2E,0x20,0x0,0xC2
	.DB  0xEA,0xEB,0xFE,0xF7,0xE5,0xED,0x20,0xF0
	.DB  0xE5,0xE6,0xE8,0xEC,0x20,0xCF,0xF0,0xEE
	.DB  0xE3,0xF0,0xE5,0xE2,0x2E,0x20,0x4C,0x49
	.DB  0x4D,0x49,0x54,0x20,0x3D,0x20,0x25,0x64
	.DB  0x2C,0x20,0xC2,0xF0,0xE5,0xEC,0xFF,0x20
	.DB  0xEF,0xF0,0xEE,0xE3,0xF0,0xE5,0xE2,0xE0
	.DB  0x20,0x3D,0x20,0x25,0x64,0xD,0xA,0x0
	.DB  0xC2,0xEA,0xEB,0xFE,0xF7,0xE5,0xED,0x20
	.DB  0xF0,0xE5,0xE6,0xE8,0xEC,0x20,0xCF,0xF3
	.DB  0xF1,0xEA,0xD,0xA,0x0,0xD0,0xE5,0xE6
	.DB  0xE8,0xEC,0x20,0xCF,0xF0,0xEE,0xE3,0xF0
	.DB  0xE5,0xE2,0x2E,0xD,0xA,0x0,0xD0,0xE5
	.DB  0xE6,0xE8,0xEC,0x20,0xCE,0xF1,0xF2,0xE0
	.DB  0xED,0xEE,0xE2,0xEA,0xE8,0x2E,0xD,0xA
	.DB  0x0,0xD0,0xE5,0xE6,0xE8,0xEC,0x20,0xCF
	.DB  0xF3,0xF1,0xEA,0x2E,0xD,0xA,0x0,0xCD
	.DB  0xE0,0xE6,0xE0,0xF2,0xE0,0x20,0xEA,0xED
	.DB  0xEE,0xEF,0xEA,0xE0,0x20,0xD1,0xD2,0xCE
	.DB  0xCF,0x2E,0x20,0x0,0x20,0xD0,0xE5,0xE6
	.DB  0xE8,0xEC,0x20,0xD1,0xD2,0xCE,0xCF,0x2E
	.DB  0xD,0xA,0x0,0xC2,0xEA,0xEB,0xFE,0xF7
	.DB  0xE5,0xED,0x20,0xF0,0xE5,0xE6,0xE8,0xEC
	.DB  0x20,0xCE,0xF1,0xF2,0xE0,0xED,0xEE,0xE2
	.DB  0xEA,0xE8,0xD,0xA,0x0,0xC0,0xE2,0xE0
	.DB  0xF0,0xE8,0xFF,0x3A,0x20,0x25,0x73,0xD
	.DB  0xA,0x0,0xC0,0xC2,0xC0,0xD0,0xC8,0xDF
	.DB  0x3A,0x20,0x25,0x73,0xD,0xA,0x0,0xCF
	.DB  0xD0,0xC5,0xC4,0xD3,0xCF,0xD0,0xC5,0xC6
	.DB  0xC4,0xC5,0xCD,0xC8,0xC5,0x3A,0x20,0x25
	.DB  0x73,0xD,0xA,0x0,0xD0,0xE0,0xE7,0xEE
	.DB  0xE3,0xF0,0xE5,0xE2,0x20,0xEA,0xE0,0xEB
	.DB  0xEE,0xF0,0xE8,0xF4,0xE5,0xF0,0xE0,0x3A
	.DB  0x20,0x25,0x64,0x2C,0x20,0xD3,0xE3,0xEE
	.DB  0xEB,0x20,0xEA,0xF0,0xE0,0xED,0xE0,0x20
	.DB  0xF0,0xE0,0xF1,0xF7,0xE5,0xF2,0xED,0xFB
	.DB  0xE9,0x20,0x3A,0x25,0x64,0x2C,0x20,0xD3
	.DB  0xE3,0xEE,0xEB,0x20,0xEA,0xF0,0xE0,0xED
	.DB  0xE0,0x20,0xE8,0xE7,0xEC,0xE5,0xF0,0xE5
	.DB  0xED,0xED,0xFB,0xE9,0x20,0x3A,0x25,0x64
	.DB  0x2C,0x20,0xF3,0xE3,0xEE,0xEB,0x20,0xEE
	.DB  0xE3,0xF0,0xE0,0xED,0xE8,0xF7,0xE5,0xED
	.DB  0xE8,0xFF,0x3A,0x20,0x25,0x64,0x2C,0x20
	.DB  0x74,0x20,0xEE,0xE1,0xF0,0xE0,0xF2,0xEA
	.DB  0xE8,0x20,0x3A,0x25,0x64,0x20,0x20,0xD
	.DB  0xA,0x0,0xCE,0xF5,0xEB,0xE0,0xE6,0xE4
	.DB  0xE5,0xED,0xE8,0xE5,0x20,0xEA,0xE0,0xEB
	.DB  0xEE,0xF0,0xE8,0xF4,0xE5,0xF0,0xE0,0x3A
	.DB  0x20,0x25,0x64,0x2C,0x20,0xD3,0xE3,0xEE
	.DB  0xEB,0x20,0xEA,0xF0,0xE0,0xED,0xE0,0x20
	.DB  0xF0,0xE0,0xF1,0xF7,0xE5,0xF2,0xED,0xFB
	.DB  0xE9,0x20,0x3A,0x25,0x64,0x2C,0x20,0xD3
	.DB  0xE3,0xEE,0xEB,0x20,0xEA,0xF0,0xE0,0xED
	.DB  0xE0,0x20,0xE8,0xE7,0xEC,0xE5,0xF0,0xE5
	.DB  0xED,0xED,0xFB,0xE9,0x20,0x3A,0x25,0x64
	.DB  0x2C,0x20,0xF3,0xE3,0xEE,0xEB,0x20,0xEE
	.DB  0xE3,0xF0,0xE0,0xED,0xE8,0xF7,0xE5,0xED
	.DB  0xE8,0xFF,0x3A,0x20,0x25,0x64,0x2C,0x20
	.DB  0x74,0x20,0xEE,0xE1,0xF0,0xE0,0xF2,0xEA
	.DB  0xE8,0x20,0x3A,0x25,0x64,0x20,0x20,0xD
	.DB  0xA,0x0,0xCF,0xEE,0xE4,0xE4,0xE5,0xF0
	.DB  0xE6,0xE0,0xED,0xE8,0xE5,0x20,0xEA,0xE0
	.DB  0xEB,0xEE,0xF0,0xE8,0xF4,0xE5,0xF0,0xE0
	.DB  0x3A,0x20,0x25,0x64,0x2C,0x20,0x20,0xD3
	.DB  0xE3,0xEE,0xEB,0x20,0xEA,0xF0,0xE0,0xED
	.DB  0xE0,0x20,0xF0,0xE0,0xF1,0xF7,0xE5,0xF2
	.DB  0xED,0xFB,0xE9,0x20,0x3A,0x25,0x64,0x2C
	.DB  0x20,0xD3,0xE3,0xEE,0xEB,0x20,0xEA,0xF0
	.DB  0xE0,0xED,0xE0,0x20,0xE8,0xE7,0xEC,0xE5
	.DB  0xF0,0xE5,0xED,0xED,0xFB,0xE9,0x20,0x3A
	.DB  0x25,0x64,0x2C,0x20,0xF3,0xE3,0xEE,0xEB
	.DB  0x20,0xEE,0xE3,0xF0,0xE0,0xED,0xE8,0xF7
	.DB  0xE5,0xED,0xE8,0xFF,0x3A,0x20,0x25,0x64
	.DB  0x2C,0x20,0x74,0x20,0xEE,0xE1,0xF0,0xE0
	.DB  0xF2,0xEA,0xE8,0x20,0x3A,0x25,0x64,0x20
	.DB  0x20,0xD,0xA,0x0,0xCF,0xEE,0xED,0xE8
	.DB  0xE6,0xE5,0xED,0xE8,0xE5,0x20,0xF1,0xEA
	.DB  0xEE,0xF0,0xEE,0xF1,0xF2,0xE8,0x20,0xE2
	.DB  0xE5,0xED,0xF2,0xE8,0xEB,0xFF,0xF2,0xEE
	.DB  0xF0,0xE0,0x20,0xF0,0xE0,0xF1,0xF7,0xE5
	.DB  0xF2,0xED,0xEE,0xE5,0x20,0x3A,0x20,0x25
	.DB  0x64,0x2C,0x20,0xE8,0xE7,0xEC,0xE5,0xF0
	.DB  0xE5,0xED,0xED,0xEE,0xE5,0x20,0x3A,0x20
	.DB  0x25,0x64,0x2C,0x20,0xD1,0xF7,0xE5,0xF2
	.DB  0xF7,0xE8,0xEA,0x20,0xF6,0xE8,0xEA,0xEB
	.DB  0xEE,0xE2,0x20,0x3A,0x25,0x64,0x2C,0x20
	.DB  0x50,0x4F,0x4D,0x5F,0x54,0x20,0x3A,0x25
	.DB  0x64,0x20,0xD,0xA,0x0,0xD3,0xE2,0xE5
	.DB  0xEB,0xE8,0xF7,0xE5,0xED,0xE8,0xE5,0x20
	.DB  0xF1,0xEA,0xEE,0xF0,0xEE,0xF1,0xF2,0xE8
	.DB  0x20,0xE2,0xE5,0xED,0xF2,0xE8,0xEB,0xFF
	.DB  0xF2,0xEE,0xF0,0xE0,0x20,0xF0,0xE0,0xF1
	.DB  0xF7,0xE5,0xF2,0xED,0xE0,0xFF,0x3A,0x20
	.DB  0x25,0x64,0x2C,0x20,0xE8,0xE7,0xEC,0xE5
	.DB  0xF0,0xE5,0xED,0xED,0xE0,0xFF,0x20,0x3A
	.DB  0x20,0x25,0x64,0x2C,0x20,0xD1,0xF7,0xE5
	.DB  0xF2,0xF7,0xE8,0xEA,0x20,0xF6,0xE8,0xEA
	.DB  0xEB,0xEE,0xE2,0x20,0x3A,0x25,0x64,0x2C
	.DB  0x20,0xC7,0xE0,0xE4,0xE0,0xED,0xED,0xE0
	.DB  0xFF,0x20,0xF1,0xEA,0xEE,0xF0,0xEE,0xF1
	.DB  0xF2,0xFC,0x20,0x3A,0x25,0x64,0x20,0xD
	.DB  0xA,0x0,0xD1,0xEA,0xEE,0xF0,0xEE,0xF1
	.DB  0xF2,0xFC,0x20,0xE2,0xE5,0xED,0xF2,0xE8
	.DB  0xEB,0xFF,0xF2,0xEE,0xF0,0xE0,0x20,0xF0
	.DB  0xE0,0xF1,0xF7,0xE5,0xF2,0xED,0xE0,0xFF
	.DB  0x3A,0x20,0x25,0x64,0x2C,0x20,0xE8,0xE7
	.DB  0xEC,0xE5,0xF0,0xE5,0xED,0xED,0xE0,0xFF
	.DB  0x20,0x3A,0x20,0x25,0x64,0x2C,0x20,0xC7
	.DB  0xE0,0xE4,0xE0,0xED,0xED,0xE0,0xFF,0x20
	.DB  0xF1,0xEA,0xEE,0xF0,0xEE,0xF1,0xF2,0xFC
	.DB  0x3A,0x20,0x25,0x64,0x2C,0x20,0x50,0x4F
	.DB  0x4D,0x5F,0x54,0x3A,0x20,0x25,0x64,0x2C
	.DB  0x20,0x54,0x41,0x50,0x5F,0x41,0x4E,0x47
	.DB  0x4C,0x45,0x5F,0x4D,0x49,0x4E,0x20,0x3D
	.DB  0x20,0x25,0x64,0x20,0xD,0xA,0x0,0xD0
	.DB  0xE0,0xE7,0xED,0xEE,0xF1,0xF2,0xFC,0x20
	.DB  0xF2,0xE5,0xEC,0xEF,0xE5,0xF0,0xE0,0xF2
	.DB  0xF3,0xF0,0x3A,0x20,0x25,0x64,0x2C,0x20
	.DB  0x54,0x41,0x50,0x5F,0x41,0x4E,0x47,0x4C
	.DB  0x45,0x20,0x3A,0x25,0x64,0x2C,0x20,0x74
	.DB  0x69,0x6D,0x65,0x5F,0x69,0x6E,0x74,0x65
	.DB  0x67,0x72,0x61,0x74,0x69,0x6F,0x6E,0x20
	.DB  0x3A,0x25,0x64,0x20,0xD,0xA,0x0,0x25
	.DB  0x30,0x32,0x75,0x3A,0x25,0x30,0x32,0x75
	.DB  0x3A,0x25,0x30,0x32,0x75,0x2C,0x20,0x25
	.DB  0x64,0x2C,0x20,0x25,0x64,0x2C,0x20,0x25
	.DB  0x64,0x2C,0x20,0x25,0x64,0x2C,0x20,0x25
	.DB  0x64,0x2C,0x20,0x25,0x64,0x2C,0x20,0x25
	.DB  0x64,0x2C,0x20,0x25,0x64,0x2C,0x20,0x25
	.DB  0x64,0x2C,0x20,0x25,0x64,0x2C,0x20,0x25
	.DB  0x64,0x2C,0x20,0x25,0x64,0xD,0xA,0x0
	.DB  0x44,0x65,0x6C,0x74,0x61,0x20,0x28,0x78
	.DB  0x31,0x30,0x30,0x29,0x20,0x3D,0x20,0x25
	.DB  0x64,0x2C,0x20,0x72,0x65,0x73,0x75,0x6C
	.DB  0x74,0x20,0x3D,0x20,0x25,0x64,0x2C,0x20
	.DB  0x54,0x41,0x50,0x5F,0x41,0x4E,0x47,0x4C
	.DB  0x45,0x20,0x3D,0x20,0x25,0x64,0x2C,0x20
	.DB  0x70,0x54,0x65,0x72,0x6D,0x20,0x3D,0x20
	.DB  0x25,0x64,0x2C,0x20,0x69,0x54,0x65,0x72
	.DB  0x6D,0x20,0x3D,0x20,0x25,0x64,0x2C,0x20
	.DB  0x64,0x54,0x65,0x72,0x6D,0x20,0x3D,0x20
	.DB  0x25,0x64,0xD,0xA,0x0,0x20,0x74,0x25
	.DB  0x2D,0x75,0x20,0x3D,0x20,0x25,0x69,0x28
	.DB  0x25,0x2D,0x69,0x2E,0x25,0x2D,0x75,0x29
	.DB  0x43,0x5B,0x25,0x30,0x32,0x58,0x25,0x30
	.DB  0x32,0x58,0x3A,0x25,0x30,0x32,0x78,0x5D
	.DB  0x25,0x64,0x3A,0x25,0x64,0x3B,0x20,0x0
	.DB  0xD1,0xD2,0xCE,0xCF,0x20,0x20,0x20,0x0
	.DB  0xCF,0xD0,0xCE,0xC3,0xD0,0xC5,0xC2,0x0
	.DB  0xCE,0xD1,0xD2,0xC0,0xCD,0xCE,0xC2,0x0
	.DB  0xCF,0xD3,0xD1,0xCA,0x20,0x20,0x20,0x0
	.DB  0xC0,0xE2,0xE0,0xF0,0xE8,0xFF,0x20,0x0
	.DB  0x25,0x30,0x32,0x75,0x3A,0x25,0x30,0x32
	.DB  0x75,0x3A,0x25,0x30,0x32,0x75,0x20,0x25
	.DB  0x30,0x32,0x75,0x2E,0x25,0x30,0x32,0x75
	.DB  0x20,0x20,0x0,0x74,0x3D,0x25,0x63,0x25
	.DB  0x30,0x32,0x75,0x2E,0x25,0x30,0x31,0x75
	.DB  0x43,0x20,0x25,0x73,0x0,0xCD,0xE5,0xF2
	.DB  0x20,0xF2,0xE5,0xF0,0xEC,0xEE,0xEC,0xE5
	.DB  0xF2,0xF0,0xEE,0xE2,0x0,0xD1,0xEE,0xF1
	.DB  0xF2,0xEE,0xFF,0xED,0xE8,0xE5,0x20,0x70
	.DB  0x72,0x69,0x6D,0x5F,0x70,0x61,0x72,0x20
	.DB  0x5B,0x25,0x64,0x20,0x62,0x79,0x74,0x65
	.DB  0x73,0x5D,0x3A,0x20,0x0,0x20,0x25,0x64
	.DB  0x0,0x20,0x25,0x58,0x0,0xC7,0xE0,0xE4
	.DB  0xE0,0xED,0x20,0x4E,0x25,0x75,0x20,0x28
	.DB  0x6E,0x75,0x6D,0x62,0x65,0x72,0x29,0x2C
	.DB  0x20,0xED,0xE0,0xF8,0xEB,0xE8,0x20,0x4E
	.DB  0x25,0x75,0x20,0x28,0x69,0x73,0x5F,0x66
	.DB  0x6F,0x75,0x6E,0x64,0x29,0x2C,0x20,0xF1
	.DB  0xE2,0xEE,0xE1,0xEE,0xE4,0xED,0xFB,0xE9
	.DB  0x20,0x4E,0x25,0x75,0x20,0x28,0x69,0x73
	.DB  0x5F,0x6E,0x65,0x77,0x29,0xD,0xA,0x0
	.DB  0xD2,0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2
	.DB  0xF0,0x20,0x4E,0x25,0x75,0x20,0xF1,0xF3
	.DB  0xF9,0xE5,0xF1,0xF2,0xE2,0xF3,0xE5,0xF2
	.DB  0x20,0xEF,0xEE,0x20,0xEF,0xEE,0xF0,0xFF
	.DB  0xE4,0xEA,0xEE,0xE2,0xEE,0xEC,0xF3,0x20
	.DB  0xED,0xEE,0xEC,0xE5,0xF0,0xF3,0x20,0x25
	.DB  0x75,0xD,0xA,0x0,0xD1,0xE2,0xEE,0xE1
	.DB  0xEE,0xE4,0xED,0xFB,0xF5,0x20,0xF2,0xE5
	.DB  0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0,0xEE
	.DB  0xE2,0x20,0xED,0xE5,0xF2,0xD,0xA,0x0
	.DB  0xCD,0xEE,0xE2,0xFB,0xE9,0x20,0x54,0x4C
	.DB  0x20,0x3D,0x20,0x25,0x64,0x5B,0x25,0x30
	.DB  0x32,0x78,0x5D,0x20,0xEF,0xEE,0x20,0xED
	.DB  0xEE,0xEC,0xE5,0xF0,0xF3,0x20,0x25,0x75
	.DB  0xD,0xA,0x0,0xCF,0xF0,0xEE,0xE8,0xED
	.DB  0xE8,0xF6,0xE8,0xE0,0xEB,0xE8,0xE7,0xE8
	.DB  0xF0,0xEE,0xE2,0xE0,0xEB,0xE8,0x20,0xF2
	.DB  0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0
	.DB  0x20,0x4E,0x25,0x75,0x20,0xEF,0xEE,0x20
	.DB  0xEF,0xEE,0xF0,0xFF,0xE4,0xEA,0xEE,0xE2
	.DB  0xEE,0xEC,0xF3,0x20,0xED,0xEE,0xEC,0xE5
	.DB  0xF0,0xF3,0x20,0x25,0x75,0xD,0xA,0x0
	.DB  0xCD,0xE5,0x20,0xEC,0xEE,0xE3,0xF3,0x20
	.DB  0xEF,0xF0,0xEE,0xE8,0xED,0xE8,0xF6,0xE8
	.DB  0xE0,0xEB,0xE8,0xE7,0xE8,0xF0,0xEE,0xE2
	.DB  0xE0,0xF2,0xFC,0x20,0xED,0xEE,0xE2,0xFB
	.DB  0xE9,0x20,0xF2,0xE5,0xF0,0xEC,0xEE,0xEC
	.DB  0xE5,0xF2,0xF0,0x20,0x4E,0x25,0x75,0xD
	.DB  0xA,0x0,0xC2,0xFB,0xEA,0xEB,0xFE,0xF7
	.DB  0xE8,0xF2,0xE5,0x20,0xEF,0xE8,0xF2,0xE0
	.DB  0xED,0xE8,0xE5,0x20,0xE8,0x20,0xEF,0xEE
	.DB  0xE4,0xEA,0xEB,0xFE,0xF7,0xE8,0xF2,0xE5
	.DB  0x20,0xE2,0xF1,0xE5,0x20,0xEE,0xE1,0xEE
	.DB  0xF0,0xF3,0xE4,0xEE,0xE2,0xE0,0xED,0xE8
	.DB  0xE5,0xD,0xA,0x0,0xCE,0xF2,0xEA,0xEB
	.DB  0xFE,0xF7,0xE8,0xF2,0xE5,0x20,0xE2,0xF1
	.DB  0xE5,0x20,0xF2,0xE5,0xF0,0xEC,0xEE,0xEC
	.DB  0xE5,0xF2,0xF0,0xFB,0x2C,0x20,0xEA,0xF0
	.DB  0xEE,0xEC,0xE5,0x20,0x5B,0x25,0x30,0x32
	.DB  0x78,0x5D,0x20,0xE8,0x20,0xED,0xE0,0xE6
	.DB  0xEC,0xE8,0xF2,0xE5,0x20,0xEA,0xEB,0xE0
	.DB  0xE2,0xE8,0xF8,0xF3,0x20,0x53,0x48,0x49
	.DB  0x46,0x54,0x2D,0x27,0x7E,0x27,0xD,0xA
	.DB  0xC2,0xFB,0xF5,0xEE,0xE4,0x20,0xE8,0xE7
	.DB  0x20,0xF0,0xE5,0xE6,0xE8,0xEC,0xE0,0x20
	.DB  0x2D,0x20,0xE2,0xFB,0xEA,0xEB,0xFE,0xF7
	.DB  0xE5,0xED,0xE8,0xE5,0x20,0xEF,0xE8,0xF2
	.DB  0xE0,0xED,0xE8,0xFF,0xD,0xA,0x0,0xD2
	.DB  0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0
	.DB  0xFB,0x20,0xED,0xE5,0x20,0xED,0xE0,0xE9
	.DB  0xE4,0xE5,0xED,0xFB,0xD,0xA,0x0,0xD2
	.DB  0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0
	.DB  0x20,0x5B,0x25,0x30,0x32,0x78,0x5D,0x20
	.DB  0xF3,0xF1,0xEF,0xE5,0xF8,0xED,0xEE,0x20
	.DB  0xEF,0xF0,0xEE,0xE8,0xED,0xE8,0xF6,0xE8
	.DB  0xE0,0xEB,0xE8,0xE7,0xE8,0xF0,0xEE,0xE2
	.DB  0xE0,0xED,0xD,0xA,0x0,0xCD,0xE5,0x20
	.DB  0xEC,0xEE,0xE3,0xF3,0x20,0xEF,0xF0,0xEE
	.DB  0xE8,0xED,0xE8,0xF6,0xE8,0xE0,0xEB,0xE8
	.DB  0xE7,0xE8,0xF0,0xEE,0xE2,0xE0,0xF2,0xFC
	.DB  0x20,0xED,0xEE,0xE2,0xFB,0xE9,0x20,0xF2
	.DB  0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0
	.DB  0x20,0x5B,0x25,0x30,0x32,0x78,0x5D,0xD
	.DB  0xA,0x0,0xCD,0xE5,0x20,0xEC,0xEE,0xE3
	.DB  0xF3,0x20,0xEF,0xF0,0xEE,0xE8,0xED,0xE8
	.DB  0xF6,0xE8,0xE0,0xEB,0xE8,0xE7,0xE8,0xF0
	.DB  0xEE,0xE2,0xE0,0xF2,0xFC,0x20,0xF2,0xE5
	.DB  0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0,0x20
	.DB  0x5B,0x25,0x30,0x32,0x78,0x5D,0xD,0xA
	.DB  0x0,0xD2,0xE5,0xF0,0xEC,0xEE,0xEC,0xE5
	.DB  0xF2,0xF0,0x20,0x5B,0x25,0x30,0x32,0x78
	.DB  0x5D,0x20,0xF3,0xF1,0xEF,0xE5,0xF8,0xED
	.DB  0xEE,0x20,0xEE,0xF7,0xE8,0xF9,0xE5,0xED
	.DB  0xD,0xA,0x0,0xCD,0xE5,0x20,0xEC,0xEE
	.DB  0xE3,0xF3,0x20,0xEE,0xF7,0xE8,0xF1,0xF2
	.DB  0xE8,0xF2,0xFC,0x20,0xF2,0xE5,0xF0,0xEC
	.DB  0xEE,0xEC,0xE5,0xF2,0xF0,0x20,0x5B,0x25
	.DB  0x30,0x32,0x78,0x5D,0xD,0xA,0x0,0xC7
	.DB  0xE2,0xF3,0xEA,0x20,0xE2,0xFB,0xEA,0xEB
	.DB  0xFE,0xF7,0xE5,0xED,0xD,0xA,0x0,0xC7
	.DB  0xE2,0xF3,0xEA,0x20,0xE2,0xEA,0xEB,0xFE
	.DB  0xF7,0xE5,0xED,0xD,0xA,0x0,0xCF,0xE5
	.DB  0xF7,0xE0,0xF2,0xFC,0x20,0xE2,0xEA,0xEB
	.DB  0xFE,0xF7,0xE5,0xED,0xE0,0xD,0xA,0x0
	.DB  0xCF,0xE5,0xF7,0xE0,0xF2,0xFC,0x20,0xE2
	.DB  0xFB,0xEA,0xEB,0xFE,0xF7,0xE5,0xED,0xE0
	.DB  0xD,0xA,0x20,0xC2,0xF0,0xE5,0xEC,0xFF
	.DB  0x2C,0x20,0xD2,0xE5,0xEC,0xEF,0xE5,0xF0
	.DB  0xE0,0xF2,0xF3,0xF0,0xE0,0x20,0xE7,0xE0
	.DB  0xE4,0xE0,0xED,0xED,0xE0,0xFF,0x2C,0x20
	.DB  0xD2,0xE5,0xEC,0xEF,0xE5,0xF0,0xE0,0xF2
	.DB  0xF3,0xF0,0xE0,0x20,0xE8,0xE7,0xEC,0xE5
	.DB  0xF0,0xE5,0xED,0xED,0xE0,0xFF,0x2C,0x20
	.DB  0x44,0x65,0x6C,0x74,0x61,0x2C,0x20,0xD3
	.DB  0xE3,0xEE,0xEB,0x20,0xEA,0xF0,0xE0,0xED
	.DB  0xE0,0x20,0xF0,0xE0,0xF1,0xF7,0xE5,0xF2
	.DB  0xED,0xFB,0xE9,0x2C,0x20,0xD3,0xE3,0xEE
	.DB  0xEB,0x20,0xEA,0xF0,0xE0,0xED,0xE0,0xE8
	.DB  0xE7,0xEC,0xE5,0xF0,0xE5,0xED,0xED,0xFB
	.DB  0xE9,0x2C,0x20,0xD3,0xE3,0xEE,0xEB,0x20
	.DB  0xEE,0xE3,0xF0,0xE0,0xED,0xE8,0xF7,0xE5
	.DB  0xED,0xE8,0xFF,0x2C,0x20,0x72,0x65,0x73
	.DB  0x75,0x6C,0x74,0x2C,0x20,0x70,0x54,0x65
	.DB  0x72,0x6D,0x2C,0x20,0x69,0x54,0x65,0x72
	.DB  0x6D,0x2C,0x20,0x64,0x54,0x65,0x72,0x6D
	.DB  0x2C,0x20,0xCE,0xE1,0xEE,0xF0,0xEE,0xF2
	.DB  0xFB,0x20,0xF0,0xE0,0xF1,0xF7,0xE5,0xF2
	.DB  0xED,0xFB,0xE5,0x2C,0x20,0xCE,0xE1,0xEE
	.DB  0xF0,0xEE,0xF2,0xFB,0x20,0xE8,0xE7,0xEC
	.DB  0xE5,0xF0,0xE5,0xED,0xED,0xFB,0xE5,0xE5
	.DB  0xD,0xA,0x0,0xC2,0xF0,0xE5,0xEC,0xFF
	.DB  0x3A,0x20,0x25,0x30,0x32,0x75,0x3A,0x25
	.DB  0x30,0x32,0x75,0x3A,0x25,0x30,0x32,0x75
	.DB  0x2C,0x20,0xE4,0xE0,0xF2,0xE0,0x3A,0x25
	.DB  0x30,0x32,0x75,0x2E,0x25,0x30,0x32,0x75
	.DB  0x2E,0x25,0x30,0x32,0x75,0x2C,0x20,0xED
	.DB  0xE0,0xE9,0xE4,0xE5,0xED,0xEE,0x20,0x25
	.DB  0x75,0x20,0xF2,0xE5,0xF0,0xEC,0xEE,0xEC
	.DB  0xE5,0xF2,0xF0,0xEE,0xE2,0xD,0xA,0x0
	.DB  0x43,0xE0,0xE0,0xE1,0xFB,0xF2,0xE8,0xE5
	.DB  0x20,0x3D,0x20,0x25,0x75,0xD,0xA,0x0
	.DB  0xD3,0xE4,0xE0,0xEB,0xE8,0xEB,0xE8,0x20
	.DB  0xE0,0xEA,0xF2,0xE8,0xE2,0xED,0xF3,0xFE
	.DB  0x20,0xF2,0xF0,0xE5,0xE2,0xEE,0xE3,0xF3
	.DB  0x3A,0x20,0x25,0x73,0xD,0xA,0x0,0xC8
	.DB  0xED,0xE8,0xF6,0xE8,0xE0,0xEB,0xE8,0xE7
	.DB  0xE8,0xF0,0xF3,0xE5,0xEC,0x20,0xE2,0xF1
	.DB  0xE5,0x20,0xF2,0xE5,0xF0,0xEC,0xEE,0xEC
	.DB  0xE5,0xF2,0xF0,0xFB,0x21,0xD,0xA,0x0
	.DB  0x25,0x73,0x9,0x0,0xC2,0xF1,0xE5,0xEC
	.DB  0x20,0xED,0xE0,0xE9,0xE4,0xE5,0xED,0xFB
	.DB  0xEC,0x20,0xF2,0xE5,0xF0,0xEC,0xEE,0xEC
	.DB  0xE5,0xF2,0xF0,0xE0,0xEC,0x20,0xEF,0xF0
	.DB  0xEE,0xEF,0xE8,0xF1,0xFB,0xE2,0xE0,0xE5
	.DB  0xEC,0x20,0x30,0x78,0x36,0x39,0x20,0x30
	.DB  0x78,0x46,0x45,0x20,0x2D,0x20,0xD2,0xE5
	.DB  0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0,0x20
	.DB  0xE2,0x20,0xEF,0xEE,0xEC,0xE5,0xF9,0xE5
	.DB  0xED,0xE8,0xE8,0xD,0xA,0x0,0xC2,0xF1
	.DB  0xE5,0xEC,0x20,0xED,0xE0,0xE9,0xE4,0xE5
	.DB  0xED,0xFB,0xEC,0x20,0xF2,0xE5,0xF0,0xEC
	.DB  0xEE,0xEC,0xE5,0xF2,0xF0,0xE0,0xEC,0x20
	.DB  0xEF,0xF0,0xEE,0xEF,0xE8,0xF1,0xFB,0xE2
	.DB  0xE0,0xE5,0xEC,0x20,0x30,0x78,0x36,0x39
	.DB  0x20,0x30,0x78,0x46,0x44,0x20,0x2D,0x20
	.DB  0xD2,0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2
	.DB  0xF0,0x20,0xED,0xE0,0x20,0xF3,0xEB,0xE8
	.DB  0xF6,0xE5,0xD,0xA,0x0,0xC2,0xF1,0xE5
	.DB  0xEC,0x20,0xED,0xE0,0xE9,0xE4,0xE5,0xED
	.DB  0xFB,0xEC,0x20,0xF2,0xE5,0xF0,0xEC,0xEE
	.DB  0xEC,0xE5,0xF2,0xF0,0xE0,0xEC,0x20,0xEF
	.DB  0xF0,0xEE,0xEF,0xE8,0xF1,0xFB,0xE2,0xE0
	.DB  0xE5,0xEC,0x20,0x30,0x78,0x36,0x39,0x20
	.DB  0x30,0x78,0x46,0x43,0x20,0x2D,0x20,0xD2
	.DB  0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2,0xF0
	.DB  0x20,0xED,0xE0,0x20,0xEF,0xEE,0xE4,0xE0
	.DB  0xF7,0xE5,0x20,0xE2,0xEE,0xE4,0xFB,0xD
	.DB  0xA,0x0,0xC2,0xF1,0xE5,0xEC,0x20,0xED
	.DB  0xE0,0xE9,0xE4,0xE5,0xED,0xFB,0xEC,0x20
	.DB  0xF2,0xE5,0xF0,0xEC,0xEE,0xEC,0xE5,0xF2
	.DB  0xF0,0xE0,0xEC,0x20,0xEF,0xF0,0xEE,0xEF
	.DB  0xE8,0xF1,0xFB,0xE2,0xE0,0xE5,0xEC,0x20
	.DB  0x30,0x78,0x36,0x39,0x20,0x30,0x78,0x46
	.DB  0x42,0x20,0x2D,0x20,0xD2,0xE5,0xF0,0xEC
	.DB  0xEE,0xEC,0xE5,0xF2,0xF0,0x20,0xED,0xE0
	.DB  0x20,0xEE,0xE1,0xF0,0xE0,0xF2,0xEA,0xE5
	.DB  0x20,0xE2,0xEE,0xE4,0xFB,0xD,0xA,0x0
	.DB  0xCD,0xE0,0xE6,0xE0,0xF2,0x20,0xF1,0xE8
	.DB  0xEC,0xE2,0xEE,0xEB,0x20,0x30,0x78,0x25
	.DB  0x78,0xD,0xA,0x0
_0x60033:
	.DB  0x0,0x6,0xC,0x13,0x19,0x1F,0x26,0x2C
	.DB  0x32,0x38,0x3F,0x45,0x4B,0x51,0x58,0x5E
_0xA0003:
	.DB  0x54,0xD9,0x5,0x0,0x1,0x0,0x0,0x3
	.DB  0x1,0x2,0x1,0x0,0x2,0x0,0x3,0x0
	.DB  0x0,0x12,0x1,0x4,0x0,0x0,0x0,0x1
	.DB  0x5,0x0,0x0,0x16,0x0,0x6,0x0,0x0
	.DB  0x0,0x0,0x7
_0xA0004:
	.DB  0x14,0x0,0xE,0x1,0x8,0x5,0x0,0xD
	.DB  0x1,0x9,0x13,0x0,0xF,0x1,0xA,0x3
	.DB  0x0,0x10,0x1,0xB,0xB,0x0,0x11,0x1
	.DB  0xC,0x0,0x0,0x2,0x1,0x29,0x0,0x0
	.DB  0x18,0x1,0x2A
_0xA0005:
	.DB  0x98,0x8,0x6,0x1,0xF,0xD0,0x7,0x5
	.DB  0x0,0xD,0xA2,0xFE,0x5,0x0,0xE,0x20
	.DB  0x1C,0x5,0x0,0x10,0x64,0x19,0x5,0x0
	.DB  0x11,0x28,0x0,0x4,0x0,0x12,0x2A,0x0
	.DB  0x4,0x1,0x13,0x5F,0x0,0x4,0x0,0x14
	.DB  0x64,0x0,0x4,0x1,0x15,0x1,0x0,0x1
	.DB  0x0,0x16,0x1,0x0,0x1,0x1,0x17
_0xA0006:
	.DB  0x3C,0xF6,0x7,0x1,0x18,0xAC,0xD,0x8
	.DB  0x1,0x19,0xE8,0x3,0x8,0x1,0x1A,0xDC
	.DB  0x5,0x6,0x1,0x1B,0x1E,0x0,0xB,0x1
	.DB  0x1C,0xA,0x0,0xB,0x1,0x1D,0x1,0x0
	.DB  0x9,0x1,0x1E,0x0,0x0,0x9,0x1,0x1F
	.DB  0x0,0x0,0x9,0x1,0x20,0x0,0x0,0x5
	.DB  0x1,0x21,0x0,0x0,0xA,0x1,0x22,0x0
	.DB  0x0,0x5,0x1,0x23,0x0,0x0,0xA,0x1
	.DB  0x24,0x0,0x0,0x5,0x1,0x25,0x0,0x0
	.DB  0xA,0x1,0x26,0x0,0x0,0x5,0x1,0x27
	.DB  0x0,0x0,0xA,0x1,0x28
_0xA0007:
	.DB  0x0,0x0,0x17,0x0,0x3D,0x0,0x0,0x17
	.DB  0x0,0x3E,0x0,0x0,0x17,0x0,0x3F,0x0
	.DB  0x0,0x17,0x0,0x40,0x0,0x0,0x17,0x0
	.DB  0x41,0x0,0x0,0x17,0x0,0x42,0x0,0x0
	.DB  0x17,0x0,0x43,0x0,0x0,0x17,0x0,0x44
	.DB  0x0,0x0,0x17,0x0,0x45,0x0,0x0,0x17
	.DB  0x0,0x46,0x0,0x0,0x17,0x0,0x47,0x0
	.DB  0x0,0x17,0x0,0x48
_0xA0000:
	.DB  0xC7,0xE0,0xEF,0xE8,0xF1,0xFC,0x20,0xE2
	.DB  0xF0,0xE5,0xEC,0xE5,0xED,0xE8,0x20,0x25
	.DB  0x30,0x32,0x75,0x3A,0x25,0x30,0x32,0x75
	.DB  0x3A,0x30,0x30,0xD,0xA,0x0,0xC4,0xE0
	.DB  0xF2,0xE0,0x20,0x25,0x30,0x32,0x75,0x2E
	.DB  0x25,0x30,0x32,0x75,0x2E,0x32,0x30,0x25
	.DB  0x30,0x32,0x75,0xD,0xA,0x0,0xC7,0xE0
	.DB  0xEF,0xE8,0xF1,0xFC,0x20,0xE4,0xE0,0xF2
	.DB  0xFB,0x20,0x25,0x30,0x32,0x75,0x2E,0x25
	.DB  0x30,0x32,0x75,0x2E,0x32,0x30,0x25,0x30
	.DB  0x32,0x75,0xD,0xA,0x0,0xC2,0xF0,0xE5
	.DB  0xEC,0xFF,0x20,0x25,0x30,0x32,0x75,0x3A
	.DB  0x25,0x30,0x32,0x75,0x3A,0x30,0x30,0xD
	.DB  0xA,0x0,0xD3,0xE4,0xE0,0xEB,0xE8,0xEB
	.DB  0xE8,0x20,0xE0,0xEA,0xF2,0xE8,0xE2,0xED
	.DB  0xF3,0xFE,0x20,0xF2,0xF0,0xE5,0xE2,0xEE
	.DB  0xE3,0xF3,0x3A,0x20,0x25,0x73,0xD,0xA
	.DB  0x0,0xC8,0xED,0xE8,0xF6,0xE8,0xE0,0xEB
	.DB  0xE8,0xE7,0xE8,0xF0,0xF3,0xE5,0xEC,0x20
	.DB  0xE2,0xF1,0xE5,0x20,0xF2,0xE5,0xF0,0xEC
	.DB  0xEE,0xEC,0xE5,0xF2,0xF0,0xFB,0x21,0xD
	.DB  0xA,0x0,0x25,0x73,0x0,0x25,0x73,0xC2
	.DB  0xCA,0xCB,0x2E,0x0,0x25,0x73,0xC2,0xFB
	.DB  0xEA,0xEB,0x2E,0x0,0x25,0x73,0x25,0x75
	.DB  0x25,0x25,0x0,0x25,0x73,0x25,0x75,0x0
	.DB  0x25,0x73,0x25,0x64,0x0,0x25,0x73,0xD1
	.DB  0xD2,0xCE,0xCF,0x0,0x25,0x73,0xCF,0xD0
	.DB  0xCE,0xC3,0xD0,0xC5,0xC2,0x0,0x25,0x73
	.DB  0xCE,0xD1,0xD2,0xC0,0xCD,0xCE,0xC2,0x0
	.DB  0x25,0x73,0xCF,0xD3,0xD1,0xCA,0x0,0x25
	.DB  0x73,0x20,0x2A,0x2A,0x0,0x25,0x73,0x25
	.DB  0x75,0x21,0x0,0x25,0x73,0xCD,0xC5,0xD2
	.DB  0x0,0x25,0x73,0xC7,0xC8,0xCC,0xC0,0x0
	.DB  0x25,0x73,0xCB,0xC5,0xD2,0xCE,0x0,0x25
	.DB  0x73,0x25,0x30,0x32,0x75,0x3A,0x25,0x30
	.DB  0x32,0x75,0x0,0x25,0x73,0x25,0x30,0x32
	.DB  0x75,0x2E,0x25,0x30,0x32,0x75,0x2E,0x25
	.DB  0x30,0x32,0x75,0x0,0x25,0x73,0x20,0xC2
	.DB  0xF0,0x2E,0x2F,0xC4,0xE0,0xF2,0x2E,0x0
	.DB  0x25,0x73,0x25,0x30,0x33,0x75,0x0,0x25
	.DB  0x73,0x25,0x63,0x25,0x75,0x2E,0x25,0x2D
	.DB  0x30,0x31,0x75,0x43,0x0,0x25,0x73,0x32
	.DB  0x30,0x25,0x75,0x0,0xC2,0xFB,0xE1,0xEE
	.DB  0xF0,0x20,0xEC,0xE5,0xED,0xFE,0x20,0x5B
	.DB  0x25,0x75,0x2C,0x20,0x25,0x75,0x5D,0x0
	.DB  0x20,0x31,0x29,0x20,0x25,0x73,0x2C,0x9
	.DB  0x32,0x29,0x20,0x25,0x73,0xD,0xA,0x0
	.DB  0xD2,0xE5,0xEA,0xF3,0xF9,0xE5,0xE5,0x20
	.DB  0xEC,0xE5,0xED,0xFE,0x3A,0x20,0x0,0x25
	.DB  0x73,0x9,0x0
_0xC0000:
	.DB  0xC7,0xE0,0xEF,0xE8,0xF1,0xFB,0xE2,0xE0
	.DB  0xE5,0xEC,0x20,0x53,0x45,0x54,0x54,0x49
	.DB  0x4E,0x47,0x53,0x20,0xE2,0x20,0x45,0x45
	.DB  0x50,0x52,0x4F,0x4D,0x20,0x5B,0x30,0x78
	.DB  0x25,0x78,0x5D,0x3A,0x20,0x0,0xD,0xA
	.DB  0x0,0xC7,0xE0,0xEF,0xE8,0xF1,0xFB,0xE2
	.DB  0xE0,0xE5,0xEC,0x20,0x41,0x4C,0x41,0x52
	.DB  0x4D,0x20,0x23,0x25,0x75,0x20,0xE2,0x20
	.DB  0x45,0x45,0x50,0x52,0x4F,0x4D,0x20,0x5B
	.DB  0x30,0x78,0x25,0x78,0x5D,0x20,0xEF,0xEE
	.DB  0x20,0xE0,0xE4,0xF0,0xE5,0xF1,0xF3,0x20
	.DB  0x30,0x78,0x25,0x78,0x3A,0xD,0xA,0x0
	.DB  0xD1,0xF7,0xE8,0xF2,0xFB,0xE2,0xE0,0xE5
	.DB  0xEC,0x20,0xE8,0xE7,0x20,0x45,0x45,0x50
	.DB  0x52,0x4F,0x4D,0x20,0x5B,0x30,0x78,0x25
	.DB  0x78,0x5D,0x3A,0x20,0x0
_0xE0000:
	.DB  0x25,0x30,0x32,0x75,0x3A,0x25,0x30,0x32
	.DB  0x75,0x20,0x25,0x30,0x32,0x75,0x2E,0x25
	.DB  0x30,0x32,0x75,0x0,0x25,0x73,0x0,0x3E
	.DB  0x20,0x25,0x73,0x20,0x25,0x69,0x20,0x25
	.DB  0x69,0x20,0x25,0x73,0xD,0xA,0x0,0xC2
	.DB  0xF1,0xE5,0x20,0xE0,0xE2,0xE0,0xF0,0xE8
	.DB  0xE8,0x3A,0xD,0xA,0x0
_0x100000:
	.DB  0xD1,0xF2,0xF3,0xEA,0xF2,0xF3,0xF0,0xE0
	.DB  0x20,0x73,0x69,0x67,0x6E,0x61,0x6C,0x73
	.DB  0x20,0x3D,0x0,0x20,0x25,0x78,0x0,0xD
	.DB  0xA,0x0
_0x120003:
	.DB  0xFF,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x33,0x3,0xFF,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x33,0x5,0xFF,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x33,0x6,0xFF,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x33,0x7
	.DB  0xFF,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x33,0x2,0xFF,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x33,0x4,0xFF,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x36,0x1
_0x204005F:
	.DB  0x1
_0x2040000:
	.DB  0x2D,0x4E,0x41,0x4E,0x0

__GLOBAL_INI_TBL:
	.DW  0x09
	.DW  0x60
	.DW  __DSTACK_END*2

	.DW  0x09
	.DW  0x00
	.DW  __HSTACK_END*2

	.DW  0x07
	.DW  _mode
	.DW  _0x40003*2

	.DW  0x58
	.DW  _prim_par
	.DW  _0x40004*2

	.DW  0x01
	.DW  0x06
	.DW  _0x4016C*2

	.DW  0x23
	.DW  _main_menu
	.DW  _0xA0003*2

	.DW  0x23
	.DW  _sdt
	.DW  _0xA0004*2

	.DW  0x37
	.DW  _parameters
	.DW  _0xA0005*2

	.DW  0x55
	.DW  _settings
	.DW  _0xA0006*2

	.DW  0x3C
	.DW  _alerts
	.DW  _0xA0007*2

	.DW  0x46
	.DW  _keys
	.DW  _0x120003*2

	.DW  0x01
	.DW  __seed_G102
	.DW  _0x204005F*2

_0xFFFFFFFF:
	.DW  0

__RESET:
	CLI
	CLR  R30
	OUT  EECR,R30

;INTERRUPT VECTORS ARE PLACED
;AT THE START OF FLASH
	LDI  R31,1
	OUT  GICR,R31
	OUT  GICR,R30
	OUT  MCUCR,R30

;DISABLE WATCHDOG
	LDI  R31,0x18
	OUT  WDTCR,R31
	OUT  WDTCR,R30

;CLEAR R2-R14
	LDI  R24,(14-2)+1
	LDI  R26,2
	CLR  R27
__CLEAR_REG:
	ST   X+,R30
	DEC  R24
	BRNE __CLEAR_REG

;CLEAR SRAM
	LDI  R24,LOW(0x800)
	LDI  R25,HIGH(0x800)
	LDI  R26,0x60
__CLEAR_SRAM:
	ST   X+,R30
	SBIW R24,1
	BRNE __CLEAR_SRAM

;GLOBAL VARIABLES INITIALIZATION
	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
__GLOBAL_INI_NEXT:
	LPM  R24,Z+
	LPM  R25,Z+
	SBIW R24,0
	BREQ __GLOBAL_INI_END
	LPM  R26,Z+
	LPM  R27,Z+
	LPM  R0,Z+
	LPM  R1,Z+
	MOVW R22,R30
	MOVW R30,R0
__GLOBAL_INI_LOOP:
	LPM  R0,Z+
	ST   X+,R0
	SBIW R24,1
	BRNE __GLOBAL_INI_LOOP
	MOVW R30,R22
	RJMP __GLOBAL_INI_NEXT
__GLOBAL_INI_END:

;STACK POINTER INITIALIZATION
	LDI  R30,LOW(0x85F)
	OUT  SPL,R30
	LDI  R30,HIGH(0x85F)
	OUT  SPH,R30

;DATA STACK POINTER INITIALIZATION
	LDI  R28,LOW(0x160)
	LDI  R29,HIGH(0x160)

	JMP  _main

	.ESEG
	.ORG 0

	.DSEG
	.ORG 0x160

	.CSEG
;/*****************************************************
;This program was produced by the
;CodeWizardAVR V2.03.9 Standard
;Automatic Program Generator
;© Copyright 1998-2008 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com
;
;Project : Robo Water
;Version : 1.0
;Date    : 02.03.2011
;Author  : Admin
;Company : Microsoft
;Comments:
;
;
;Chip type               : ATmega32
;Program type            : Application
;AVR Core Clock frequency: 3686400 MHz
;Memory model            : Small
;External RAM size       : 0
;Data Stack size         : 512
;*****************************************************/
;#include <mega32.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x80
	.EQU __sm_mask=0x70
	.EQU __sm_powerdown=0x20
	.EQU __sm_powersave=0x30
	.EQU __sm_standby=0x60
	.EQU __sm_ext_standby=0x70
	.EQU __sm_adc_noise_red=0x10
	.SET power_ctrl_reg=mcucr
	#endif
;// I2C Bus functions
;#asm
   .equ __i2c_port=0x15 ;PORTC
   .equ __sda_bit=1
   .equ __scl_bit=0
; 0000 001D #endasm
;#include <i2c.h>
;// DS1307 Real Time Clock functions
;#include <ds1307.h>
;// 1 Wire Bus functions
;#asm
   .equ __w1_port=0x18 ;PORTB
   .equ __w1_bit=0
; 0000 0025 #endasm
;#include <1wire.h>
;// Standard Input/Output functions
;#include <stdio.h>
;#include <stdlib.h>
;#include <delay.h>
;#include "robowater.h"
;#include "spd1820.h"
;#include "valcoder.h"
;#include "lcd_4bit.h"
;#include "menu.h"
;#include "signals.h"
;#include "at2404.h"
;#include "keys.h"
;#define NODEBUG
;// Описание локальных функций
;unsigned int read_adc(unsigned char);
;// Переменная timer1
;byte timer1_valcoder = 0;
;unsigned int timer_start = 0;
;byte timer_stop = 0;
;byte timer_fan = 0;
;byte count_fan = 0;
;
;// Ежесекундное прерывание
;interrupt [EXT_INT2] void ext_int2_isr(void) {
; 0000 003E interrupt [4] void ext_int2_isr(void) {

	.CSEG
_ext_int2_isr:
	CALL SUBOPT_0x0
; 0000 003F     #ifndef NODEBUG
; 0000 0040     // printf ("%02u:%02u Начало прерывания Секунда...", s_dt.cMM, s_dt.cSS);
; 0000 0041     // printf (".");
; 0000 0042     #endif
; 0000 0043     if (timer_fan) timer_fan--;
	LDS  R30,_timer_fan
	CPI  R30,0
	BREQ _0x3
	SUBI R30,LOW(1)
	STS  _timer_fan,R30
; 0000 0044     if (timer_start) {
_0x3:
	LDS  R30,_timer_start
	LDS  R31,_timer_start+1
	SBIW R30,0
	BREQ _0x4
; 0000 0045         timer_start--;
	LDI  R26,LOW(_timer_start)
	LDI  R27,HIGH(_timer_start)
	LD   R30,X+
	LD   R31,X+
	SBIW R30,1
	ST   -X,R31
	ST   -X,R30
; 0000 0046         // Если достигли нуля, то включаем вентилятор
; 0000 0047         if (!timer_start && (mode.run == 1)) {         // event = ev_timer_Start;
	LDS  R30,_timer_start
	LDS  R31,_timer_start+1
	SBIW R30,0
	BRNE _0x6
	__GETB2MN _mode,1
	CPI  R26,LOW(0x1)
	BREQ _0x7
_0x6:
	RJMP _0x5
_0x7:
; 0000 0048              mode.fan = 1;
	LDI  R30,LOW(1)
	__PUTB1MN _mode,4
; 0000 0049              printf ("ПУСК \r\n");
	__POINTW1FN _0x0,0
	CALL SUBOPT_0x1
; 0000 004A              mode.run=3;                // Включаем режим Пуск
	LDI  R30,LOW(3)
	__PUTB1MN _mode,1
; 0000 004B              count_fan = 0;
	LDI  R30,LOW(0)
	STS  _count_fan,R30
; 0000 004C              signal_green(ON);
	CALL SUBOPT_0x2
; 0000 004D         }
; 0000 004E     }
_0x5:
; 0000 004F     if (timer_stop) {
_0x4:
	LDS  R30,_timer_stop
	CPI  R30,0
	BREQ _0x8
; 0000 0050         timer_stop--;
	SUBI R30,LOW(1)
	STS  _timer_stop,R30
; 0000 0051         // Если достигли нуля, то выключаем вентилятор
; 0000 0052         if (!timer_stop && (mode.run == 2)) {          // event = ev_timer_Stop;
	CPI  R30,0
	BRNE _0xA
	__GETB2MN _mode,1
	CPI  R26,LOW(0x2)
	BREQ _0xB
_0xA:
	RJMP _0x9
_0xB:
; 0000 0053             mode.run = 0;
	CALL SUBOPT_0x3
; 0000 0054             mode.fan = 0;           // Выключение насоса
; 0000 0055             // printf ("Остановили Вентилятор Режим СТОП \r\n");
; 0000 0056             signal_green(OFF);
	CALL SUBOPT_0x4
; 0000 0057         }
; 0000 0058     }
_0x9:
; 0000 0059      // Пока timer1_counter > 0, уменьшаем его значение
; 0000 005A     if (timer1_valcoder) {
_0x8:
	LDS  R30,_timer1_valcoder
	CPI  R30,0
	BREQ _0xC
; 0000 005B         timer1_valcoder--;
	SUBI R30,LOW(1)
	STS  _timer1_valcoder,R30
; 0000 005C         // Если достигли нуля, то останавливаем обслуживание valcoder
; 0000 005D         if (!timer1_valcoder) {
	CPI  R30,0
	BRNE _0xD
; 0000 005E             if (event)
	LDS  R30,_event
	CPI  R30,0
	BREQ _0xE
; 0000 005F                 timer1_valcoder++;
	LDS  R30,_timer1_valcoder
	SUBI R30,-LOW(1)
	STS  _timer1_valcoder,R30
; 0000 0060             else
	RJMP _0xF
_0xE:
; 0000 0061                 event = ev_timer;
	LDI  R30,LOW(6)
	STS  _event,R30
; 0000 0062             // clatsman.valcoder_mode = 0; lcd_clrscr();
; 0000 0063         }
_0xF:
; 0000 0064     }
_0xD:
; 0000 0065     if (!mode.stop_sync_dt) get_cur_dt (0);
_0xC:
	__GETB1MN _mode,5
	CPI  R30,0
	BRNE _0x10
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _get_cur_dt
; 0000 0066     read_all_terms(DUTY_MODE);
_0x10:
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _read_all_terms
; 0000 0067     // Вычитаваем АЦП
; 0000 0068     ADC_VAR2 = read_adc(0)/4;
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _read_adc
	CALL __LSRW2
	__PUTW1MN _parameters,35
; 0000 0069     ADC_VAR1 = read_adc(1)/4;
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _read_adc
	CALL __LSRW2
	__PUTW1MN _parameters,25
; 0000 006A     if (time_integration) time_integration--;
	CALL SUBOPT_0x5
	SBIW R30,0
	BREQ _0x11
	LDI  R26,LOW(_time_integration)
	LDI  R27,HIGH(_time_integration)
	LD   R30,X+
	LD   R31,X+
	SBIW R30,1
	ST   -X,R31
	ST   -X,R30
; 0000 006B     #ifndef NODEBUG
; 0000 006C     // printf ("конец в %02u:%02u\r\n", s_dt.cMM, s_dt.cSS);
; 0000 006D     #endif
; 0000 006E     if CHECK_EVENT {
_0x11:
	LDS  R30,_event
	CPI  R30,0
	BRNE _0x12
; 0000 006F         event = ev_secunda;
	LDI  R30,LOW(5)
	STS  _event,R30
; 0000 0070         #ifndef NODEBUG
; 0000 0071         // printf ("%02u:%02u Сгенерировано событие Секунда\r\n", s_dt.cMM, s_dt.cSS);
; 0000 0072         #endif
; 0000 0073     }
; 0000 0074     #ifndef NODEBUG
; 0000 0075     else
; 0000 0076         printf ("Текущее событие = %u\r\n", (unsigned char)event);
; 0000 0077     #endif
; 0000 0078     // parameters[0].val_data = termometers[0].t;
; 0000 0079 }
_0x12:
	RJMP _0x18
;// Timer 0 overflow interrupt service routine
;interrupt [TIM0_OVF] void timer0_ovf_isr(void) {
; 0000 007B interrupt [12] void timer0_ovf_isr(void) {
_timer0_ovf_isr:
; 0000 007C // Нельзя использовать. Задействовано для PWM
; 0000 007D }
	RETI
;// Timer 1 overflow interrupt service routine
;interrupt [TIM1_OVF] void timer1_ovf_isr(void) {
; 0000 007F interrupt [10] void timer1_ovf_isr(void) {
_timer1_ovf_isr:
	CALL SUBOPT_0x0
; 0000 0080     update_signal_status();
	CALL _update_signal_status
; 0000 0081     if (t_key) t_key--;
	LDS  R30,_t_key
	CPI  R30,0
	BREQ _0x13
	SUBI R30,LOW(1)
	STS  _t_key,R30
; 0000 0082 }
_0x13:
_0x18:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R24,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R15,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;// Timer 2 overflow interrupt service routine
;interrupt [TIM2_OVF] void timer2_ovf_isr(void) {
; 0000 0084 interrupt [6] void timer2_ovf_isr(void) {
_timer2_ovf_isr:
; 0000 0085 // Нельзя использовать. Задействовано для PWM
; 0000 0086 }
	RETI
;#define ADC_VREF_TYPE 0xC0
;// Read the AD conversion result
;unsigned int read_adc(unsigned char adc_input) {
; 0000 0089 unsigned int read_adc(unsigned char adc_input) {
_read_adc:
; 0000 008A     ADMUX=adc_input | (ADC_VREF_TYPE & 0xff);
;	adc_input -> Y+0
	LD   R30,Y
	ORI  R30,LOW(0xC0)
	OUT  0x7,R30
; 0000 008B     delay_us(10);   // Delay needed for the stabilization of the ADC input voltage
	__DELAY_USB 12
; 0000 008C     ADCSRA|=0x40;   // Start the AD conversion
	SBI  0x6,6
; 0000 008D     while ((ADCSRA & 0x10)==0); // Wait for the AD conversion to complete
_0x14:
	SBIS 0x6,4
	RJMP _0x14
; 0000 008E     ADCSRA|=0x10;
	SBI  0x6,4
; 0000 008F     return ADCW;
	IN   R30,0x4
	IN   R31,0x4+1
	RJMP _0x20E0019
; 0000 0090 }
;#pragma used+
;void set_cur_dt (void) {
; 0000 0092 void set_cur_dt (void) {
_set_cur_dt:
; 0000 0093     #asm("cli")
	cli
; 0000 0094     rtc_set_time(s_dt.cHH, s_dt.cMM, s_dt.cSS);
	LDS  R30,_s_dt
	ST   -Y,R30
	__GETB1MN _s_dt,1
	ST   -Y,R30
	__GETB1MN _s_dt,2
	ST   -Y,R30
	CALL _rtc_set_time
; 0000 0095     rtc_set_date(s_dt.cdd, s_dt.cmo, s_dt.cyy);
	__GETB1MN _s_dt,5
	ST   -Y,R30
	__GETB1MN _s_dt,4
	ST   -Y,R30
	__GETB1MN _s_dt,3
	ST   -Y,R30
	CALL _rtc_set_date
; 0000 0096     #asm("sei")
	sei
; 0000 0097     delay_ms (200);
	CALL SUBOPT_0x6
; 0000 0098     get_cur_dt(FORCE_INIT);
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _get_cur_dt
; 0000 0099     // rtc_set_date(3, 13, 11); 	// 03.13.2011
; 0000 009A     // rtc_set_time(17, 22, 0); 	// 17:22:00
; 0000 009B }
	RET
;
;void get_cur_dt (unsigned char force) {
; 0000 009D void get_cur_dt (unsigned char force) {
_get_cur_dt:
; 0000 009E     if (force) {
;	force -> Y+0
	LD   R30,Y
	CPI  R30,0
	BREQ _0x17
; 0000 009F         rtc_init(0,1,0);            // Устанавливаем односекундное срабатывание интерапта
	CALL SUBOPT_0x7
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _rtc_init
; 0000 00A0         #ifndef NODEBUG
; 0000 00A1         printf ("Проинициализировали ежесекундное прерывание\r\n");
; 0000 00A2         #endif
; 0000 00A3     }
; 0000 00A4     // Время
; 0000 00A5     rtc_get_time(&s_dt.cHH,&s_dt.cMM,&s_dt.cSS);
_0x17:
	LDI  R30,LOW(_s_dt)
	LDI  R31,HIGH(_s_dt)
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _s_dt,1
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _s_dt,2
	ST   -Y,R31
	ST   -Y,R30
	CALL _rtc_get_time
; 0000 00A6     // Дата
; 0000 00A7     rtc_get_date(&s_dt.cdd,&s_dt.cmo,&s_dt.cyy);
	__POINTW1MN _s_dt,5
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _s_dt,4
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _s_dt,3
	ST   -Y,R31
	ST   -Y,R30
	CALL _rtc_get_date
; 0000 00A8 }
	RJMP _0x20E0019
;
;#pragma used-
;// Инициализация UART. Скорость на порту задается #define BAUDRATE
;void init_uart(void) {
; 0000 00AC void init_uart(void) {
_init_uart:
; 0000 00AD 	word bauddiv;
; 0000 00AE 	// USART initialization Communication Parameters: 8 Data, 1 Stop, No Parity
; 0000 00AF     // USART Receiver: On
; 0000 00B0     // USART Transmitter: On
; 0000 00B1 	UCSRA=0x00; UCSRC=0x86; UCSRB = (1<<TXEN) | (1<<RXEN);
	ST   -Y,R17
	ST   -Y,R16
;	bauddiv -> R16,R17
	LDI  R30,LOW(0)
	OUT  0xB,R30
	LDI  R30,LOW(134)
	OUT  0x20,R30
	LDI  R30,LOW(24)
	OUT  0xA,R30
; 0000 00B2     bauddiv = ((_MCU_CLOCK_FREQUENCY_ + (BAUDRATE * 8L))/(BAUDRATE * 16L) - 1);
	__GETWRN 16,17,1
; 0000 00B3     UBRRL = (unsigned char)bauddiv;
	OUT  0x9,R16
; 0000 00B4 	UBRRH = bauddiv >> 8;
	MOV  R30,R17
	ANDI R31,HIGH(0x0)
	OUT  0x20,R30
; 0000 00B5 }
	LD   R16,Y+
	LD   R17,Y+
	RET
;// Инициализация всех термометров в системе
;void init_terms(void) {
; 0000 00B7 void init_terms(void) {
_init_terms:
; 0000 00B8     printf ("Поиск всех термометров на шине 1-Wire. Найдено: ");
	__POINTW1FN _0x0,8
	CALL SUBOPT_0x1
; 0000 00B9     ds1820_devices = w1_search(0xf0,ds1820_rom_codes);
	CALL SUBOPT_0x8
	__PUTB1MN _prim_par,51
; 0000 00BA     delay_ms (DS1820_ALL_DELAY);
	CALL SUBOPT_0x6
; 0000 00BB     printf ("%d штук\r\n", ds1820_devices);
	__POINTW1FN _0x0,57
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x9
	CALL SUBOPT_0xA
; 0000 00BC }
	RET
;// Основной инициализационный модуль
;void init(void) {
; 0000 00BE void init(void) {
_init:
; 0000 00BF     // byte tmp_ret; // byte resolution;
; 0000 00C0     // signed char tmp_alarm_h, tmp_alarm_l;
; 0000 00C1     // Port A initialization
; 0000 00C2     /* Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=Out Func1=In Func0=In
; 0000 00C3     // State7=0 State6=0 State5=0 State4=0 State3=0 State2=0 State1=T State0=T
; 0000 00C4     */
; 0000 00C5     PORTA=0x00; DDRA=0xFC;
	LDI  R30,LOW(0)
	OUT  0x1B,R30
	LDI  R30,LOW(252)
	OUT  0x1A,R30
; 0000 00C6 
; 0000 00C7     // Port B initialization
; 0000 00C8     /* Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=In Func1=In Func0=In
; 0000 00C9     // State7=0 State6=0 State5=0 State4=0 State3=0 State2=P State1=P State0=P
; 0000 00CA     */
; 0000 00CB     PORTB=0x07; DDRB=0xF8;
	LDI  R30,LOW(7)
	OUT  0x18,R30
	LDI  R30,LOW(248)
	OUT  0x17,R30
; 0000 00CC 
; 0000 00CD     // Port C initialization
; 0000 00CE     /* Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0000 00CF     // State7=P State6=P State5=P State4=P State3=P State2=P State1=P State0=P
; 0000 00D0     */
; 0000 00D1     PORTC=0xFF; DDRC=0x00;
	LDI  R30,LOW(255)
	OUT  0x15,R30
	LDI  R30,LOW(0)
	OUT  0x14,R30
; 0000 00D2 
; 0000 00D3     // Port D initialization
; 0000 00D4     /* Func7=Out Func6=In Func5=Out Func4=Out Func3=In Func2=In Func1=Out Func0=In
; 0000 00D5     // State7=0 State6=P State5=0 State4=0 State3=P State2=P State1=0 State0=P
; 0000 00D6     PORTD=0x4D; DDRD=0xB2;
; 0000 00D7     */
; 0000 00D8     /* Func7=Out Func6=Out Func5=Out Func4=Out Func3=In Func2=In Func1=Out Func0=In
; 0000 00D9     // State7=0 State6=0 State5=0 State4=0 State3=P State2=P State1=0 State0=P
; 0000 00DA      */
; 0000 00DB     PORTD=0x0D; DDRD=0xF2;
	LDI  R30,LOW(13)
	OUT  0x12,R30
	LDI  R30,LOW(242)
	OUT  0x11,R30
; 0000 00DC 
; 0000 00DD 
; 0000 00DE     // Timer/Counter 0 initialization
; 0000 00DF     /* Clock source: System Clock
; 0000 00E0     // Clock value: 31,250 kHz
; 0000 00E1     // Mode: Fast PWM top=FFh
; 0000 00E2     // OC0 output: Non-Inverted PWM
; 0000 00E3     */
; 0000 00E4     TCCR0=0x6C; TCNT0=0x00; OCR0=0x00;
	LDI  R30,LOW(108)
	OUT  0x33,R30
	LDI  R30,LOW(0)
	OUT  0x32,R30
	OUT  0x3C,R30
; 0000 00E5 
; 0000 00E6     // Timer/Counter 1 initialization
; 0000 00E7     /* Clock source: System Clock
; 0000 00E8     // Clock value: 460,000 kHz (142 mc - 1 cycle)
; 0000 00E9     // Mode: Normal top=FFFFh
; 0000 00EA     // OC1A output: Discon.
; 0000 00EB     // OC1B output: Discon.
; 0000 00EC     // Noise Canceler: Off
; 0000 00ED     // Input Capture on Falling Edge
; 0000 00EE     // Timer 1 Overflow Interrupt: On
; 0000 00EF     // Input Capture Interrupt: Off
; 0000 00F0     // Compare A Match Interrupt: Off
; 0000 00F1     // Compare B Match Interrupt: Off
; 0000 00F2     */
; 0000 00F3     TCCR1A=0x00; TCCR1B=0x02; TCNT1H=0x00; TCNT1L=0x00;
	OUT  0x2F,R30
	LDI  R30,LOW(2)
	OUT  0x2E,R30
	LDI  R30,LOW(0)
	OUT  0x2D,R30
	OUT  0x2C,R30
; 0000 00F4     ICR1H=0x00; ICR1L=0x00;
	OUT  0x27,R30
	OUT  0x26,R30
; 0000 00F5     OCR1AH=0x00; OCR1AL=0x00; OCR1BH=0x00; OCR1BL=0x00;
	OUT  0x2B,R30
	OUT  0x2A,R30
	OUT  0x29,R30
	OUT  0x28,R30
; 0000 00F6 
; 0000 00F7     // Timer/Counter 2 initialization
; 0000 00F8     /* Clock source: System Clock
; 0000 00F9     // Clock value: 31,250 kHz
; 0000 00FA     // Mode: Fast PWM top=FFh
; 0000 00FB     // OC2 output: Inverted PWM
; 0000 00FC     */
; 0000 00FD     // ASSR=0x00; TCCR2=0x7E; TCNT2=0x00; OCR2=0x00;
; 0000 00FE     ASSR=0x00; TCCR2=0x6c; TCNT2=0x00; OCR2=0x00;
	OUT  0x22,R30
	LDI  R30,LOW(108)
	OUT  0x25,R30
	LDI  R30,LOW(0)
	OUT  0x24,R30
	OUT  0x23,R30
; 0000 00FF     // External Interrupt(s) initialization
; 0000 0100     /*
; 0000 0101     INT0: On INT0 Mode: Falling Edge
; 0000 0102     INT1: On INT1 Mode: Falling Edge
; 0000 0103     INT2: On  INT2 Mode: Falling Edge
; 0000 0104     MCUCR=0x0A;
; 0000 0105     INT0: On INT0 Mode: Rising Edge
; 0000 0106     INT1: On INT1 Mode: Rising Edge
; 0000 0107     INT2: On  INT2 Mode: Falling Edge
; 0000 0108     MCUCR=0x0F;
; 0000 0109     INT0: On INT0 Mode: Rising Edge
; 0000 010A     INT1: On INT1 Mode: Any change
; 0000 010B     INT2: On  INT2 Mode: Falling Edge
; 0000 010C     MCUCR=0x07;
; 0000 010D     */
; 0000 010E     GICR|=0xE0; MCUCR=0x06; MCUCSR=0x00; GIFR=0xE0;
	IN   R30,0x3B
	ORI  R30,LOW(0xE0)
	OUT  0x3B,R30
	LDI  R30,LOW(6)
	OUT  0x35,R30
	LDI  R30,LOW(0)
	OUT  0x34,R30
	LDI  R30,LOW(224)
	OUT  0x3A,R30
; 0000 010F     // Timer(s)/Counter(s) Interrupt(s) initialization
; 0000 0110     TIMSK=0x45;
	LDI  R30,LOW(69)
	OUT  0x39,R30
; 0000 0111 
; 0000 0112     // USART initialization
; 0000 0113     init_uart ();
	RCALL _init_uart
; 0000 0114 
; 0000 0115     // Analog Comparator initialization
; 0000 0116     /* Analog Comparator: Off
; 0000 0117     // Analog Comparator Input Capture by Timer/Counter 1: Off
; 0000 0118     */
; 0000 0119     ACSR=0x80; SFIOR=0x00;
	LDI  R30,LOW(128)
	OUT  0x8,R30
	LDI  R30,LOW(0)
	OUT  0x30,R30
; 0000 011A 
; 0000 011B     // ADC initialization
; 0000 011C     /* ADC Clock frequency: 125,000 kHz
; 0000 011D     // ADC Voltage Reference: Int., cap. on AREF
; 0000 011E     // ADC Auto Trigger Source: Free Running
; 0000 011F     */
; 0000 0120     ADMUX=ADC_VREF_TYPE & 0xff; ADCSRA=0xA6; SFIOR&=0x1F;
	LDI  R30,LOW(192)
	OUT  0x7,R30
	LDI  R30,LOW(166)
	OUT  0x6,R30
	IN   R30,0x30
	ANDI R30,LOW(0x1F)
	OUT  0x30,R30
; 0000 0121     printf ("Старт инициализации периферии...\r\n"); delay_ms(500);
	__POINTW1FN _0x0,67
	CALL SUBOPT_0x1
	LDI  R30,LOW(500)
	LDI  R31,HIGH(500)
	CALL SUBOPT_0xB
; 0000 0122     // I2C Bus initialization
; 0000 0123     i2c_init();
	CALL _i2c_init
; 0000 0124     // DS1307 Real Time Clock initialization
; 0000 0125     /* Square wave output on pin SQW/OUT: On
; 0000 0126     // Square wave frequency: 1Hz
; 0000 0127     */
; 0000 0128     // Инициализируем часы реального времени датой разработки этой программы
; 0000 0129     mode.stop_sync_dt = 0;      // снимаем флаг запрета синхронизации
	LDI  R30,LOW(0)
	__PUTB1MN _mode,5
; 0000 012A     get_cur_dt(FORCE_INIT);                   // (1)
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _get_cur_dt
; 0000 012B     // Инициализируем все термометры
; 0000 012C     init_terms();
	RCALL _init_terms
; 0000 012D     // инициализируем дисплей
; 0000 012E     lcd_init(LCD_DISP_ON);
	LDI  R30,LOW(12)
	ST   -Y,R30
	CALL _lcd_init
; 0000 012F     // Инициализируем valcoder
; 0000 0130     valcoder = VALCODER_NO_ROTATE;
	LDI  R30,LOW(0)
	STS  _valcoder,R30
; 0000 0131     // Инициализируем меню
; 0000 0132     init_curr_menu(&main_menu[0], NUM_MENU);
	CALL SUBOPT_0xC
	CALL SUBOPT_0xD
; 0000 0133     // Инициализируем все светики
; 0000 0134     signal_green(OFF); signal_red(OFF); signal_buz(OFF); signal_white(OFF);
	CALL SUBOPT_0x4
	CALL SUBOPT_0xE
	CALL SUBOPT_0xF
; 0000 0135 } // Конец функции init
	RET
;// #include <avr_compiler.h>
;#include <io.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x80
	.EQU __sm_mask=0x70
	.EQU __sm_powerdown=0x20
	.EQU __sm_powersave=0x30
	.EQU __sm_standby=0x60
	.EQU __sm_ext_standby=0x70
	.EQU __sm_adc_noise_red=0x10
	.SET power_ctrl_reg=mcucr
	#endif
;#include <delay.h>
;#include "robowater.h"
;#include "lcd_4bit.h"
;
;#define _BV(x) (1 << (x))
;// #define lcd_e_delay()   #asm("rjmp 1f\ 1:")
;#define lcd_e_delay()   delay_us(250)
;#define lcd_e_high()    LCD_E_PORT  |=  _BV(LCD_E_PIN);
;#define lcd_e_low()     LCD_E_PORT  &= ~_BV(LCD_E_PIN);
;#define lcd_rw_high()   LCD_RW_PORT |=  _BV(LCD_RW_PIN)
;#define lcd_rw_low()    LCD_RW_PORT &= ~_BV(LCD_RW_PIN)
;#define lcd_rs_high()   LCD_RS_PORT |=  _BV(LCD_RS_PIN)
;#define lcd_rs_low()    LCD_RS_PORT &= ~_BV(LCD_RS_PIN)
;
;#define LCD_FUNCTION_DEFAULT    LCD_FUNCTION_4BIT_2LINES
;#pragma used+
;// Устанавливаем коротку задержку в 32 цикла процессора
;static void _lcd_delay(void) {
; 0001 0014 static void _lcd_delay(void) {

	.CSEG
; 0001 0015 #asm
; 0001 0016     ldi   r31,15
; 0001 0017 __lcd_delay0:
; 0001 0018     dec   r31                   ; 1 cycle
; 0001 0019     brne  __lcd_delay0          ; 1 cycle
; 0001 001A #endasm
; 0001 001B }
;// Устанавливаем длинную задержку в 262140 (4*65535) циклов процессора
;static void _long_delay(void) {
; 0001 001D static void _long_delay(void) {
; 0001 001E #asm
; 0001 001F     clr   r26
; 0001 0020     clr   r27
; 0001 0021 __long_delay0:
; 0001 0022     sbiw  r26,1         ;2 cycles
; 0001 0023     brne  __long_delay0 ;2 cycles
; 0001 0024 #endasm
; 0001 0025 }
;// Анализ состояния LCD
;/* void _lcd_ready(void)
;{
;#asm
;    in    r26,__lcd_direction
;    andi  r26,0xf                 ;set as input
;    out   __lcd_direction,r26
;    sbi   __lcd_port,__lcd_rd     ;RD=1
;    cbi   __lcd_port,__lcd_rs     ;RS=0
;__lcd_busy:
;#endasm
;    _lcd_delay();
;#asm
;    sbi   __lcd_port,__lcd_enable ;EN=1
;#endasm
;_lcd_delay();
;#asm
;    in    r26,__lcd_pin
;    cbi   __lcd_port,__lcd_enable ;EN=0
;#endasm
;    _lcd_delay();
;#asm
;    sbi   __lcd_port,__lcd_enable ;EN=1
;#endasm
;    _lcd_delay();
;#asm
;    cbi   __lcd_port,__lcd_enable ;EN=0
;    sbrc  r26,__lcd_busy_flag
;    rjmp  __lcd_busy
;#endasm
;}
;*/
;#pragma used-
;
;static void lcd_e_toggle(void);
;// #define delay(us) _delayFourCycles( ( ( 1*(_MCU_CLOCK_FREQUENCY_/4000) )*us)/1000 )
;
;static void lcd_e_toggle(void) {
; 0001 004B static void lcd_e_toggle(void) {
_lcd_e_toggle_G001:
; 0001 004C     lcd_e_high();
	CALL SUBOPT_0x10
; 0001 004D     lcd_e_delay();
; 0001 004E     lcd_e_low();
	CBI  0x18,6
; 0001 004F }
	RET
;
;static void lcd_write(byte data, byte rs) {
; 0001 0051 static void lcd_write(byte data, byte rs) {
_lcd_write_G001:
; 0001 0052     /* write data (RS=1, RW=0) or write instruction (RS=0, RW=0) */
; 0001 0053     if (rs) lcd_rs_high(); else lcd_rs_low();
;	data -> Y+1
;	rs -> Y+0
	LD   R30,Y
	CPI  R30,0
	BREQ _0x20003
	SBI  0x18,5
	RJMP _0x20004
_0x20003:
	CBI  0x18,5
; 0001 0054     lcd_rw_low();
_0x20004:
	CBI  0x18,7
; 0001 0055     /* configure data pins as output */
; 0001 0056     LCD_DATA0_DDR |= _BV(LCD_DATA0_PIN);
	SBI  0x1A,4
; 0001 0057     LCD_DATA1_DDR |= _BV(LCD_DATA1_PIN);
	SBI  0x1A,5
; 0001 0058     LCD_DATA2_DDR |= _BV(LCD_DATA2_PIN);
	SBI  0x1A,6
; 0001 0059     LCD_DATA3_DDR |= _BV(LCD_DATA3_PIN);
	SBI  0x1A,7
; 0001 005A     /* output high nibble first */
; 0001 005B     LCD_DATA3_PORT &= ~_BV(LCD_DATA3_PIN);
	CBI  0x1B,7
; 0001 005C     LCD_DATA2_PORT &= ~_BV(LCD_DATA2_PIN);
	CBI  0x1B,6
; 0001 005D     LCD_DATA1_PORT &= ~_BV(LCD_DATA1_PIN);
	CBI  0x1B,5
; 0001 005E     LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);
	CBI  0x1B,4
; 0001 005F     if(data & 0x80) LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
	LDD  R30,Y+1
	ANDI R30,LOW(0x80)
	BREQ _0x20005
	SBI  0x1B,7
; 0001 0060     if(data & 0x40) LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
_0x20005:
	LDD  R30,Y+1
	ANDI R30,LOW(0x40)
	BREQ _0x20006
	SBI  0x1B,6
; 0001 0061     if(data & 0x20) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
_0x20006:
	LDD  R30,Y+1
	ANDI R30,LOW(0x20)
	BREQ _0x20007
	SBI  0x1B,5
; 0001 0062     if(data & 0x10) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
_0x20007:
	LDD  R30,Y+1
	ANDI R30,LOW(0x10)
	BREQ _0x20008
	SBI  0x1B,4
; 0001 0063     lcd_e_toggle();
_0x20008:
	RCALL _lcd_e_toggle_G001
; 0001 0064     /* output low nibble */
; 0001 0065     LCD_DATA3_PORT &= ~_BV(LCD_DATA3_PIN);
	CBI  0x1B,7
; 0001 0066     LCD_DATA2_PORT &= ~_BV(LCD_DATA2_PIN);
	CBI  0x1B,6
; 0001 0067     LCD_DATA1_PORT &= ~_BV(LCD_DATA1_PIN);
	CBI  0x1B,5
; 0001 0068     LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);
	CBI  0x1B,4
; 0001 0069     if(data & 0x08) LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
	LDD  R30,Y+1
	ANDI R30,LOW(0x8)
	BREQ _0x20009
	SBI  0x1B,7
; 0001 006A     if(data & 0x04) LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
_0x20009:
	LDD  R30,Y+1
	ANDI R30,LOW(0x4)
	BREQ _0x2000A
	SBI  0x1B,6
; 0001 006B     if(data & 0x02) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
_0x2000A:
	LDD  R30,Y+1
	ANDI R30,LOW(0x2)
	BREQ _0x2000B
	SBI  0x1B,5
; 0001 006C     if(data & 0x01) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
_0x2000B:
	LDD  R30,Y+1
	ANDI R30,LOW(0x1)
	BREQ _0x2000C
	SBI  0x1B,4
; 0001 006D     lcd_e_toggle();
_0x2000C:
	RCALL _lcd_e_toggle_G001
; 0001 006E     /* all data pins high (inactive) */
; 0001 006F     LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
	SBI  0x1B,4
; 0001 0070     LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
	SBI  0x1B,5
; 0001 0071     LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
	SBI  0x1B,6
; 0001 0072     LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
	SBI  0x1B,7
; 0001 0073 }
	RJMP _0x20E001A
;
;static byte lcd_read(byte rs) {
; 0001 0075 static byte lcd_read(byte rs) {
_lcd_read_G001:
; 0001 0076     byte data;
; 0001 0077 
; 0001 0078     if (rs)
	ST   -Y,R16
;	rs -> Y+1
;	data -> R16
	LDD  R30,Y+1
	CPI  R30,0
	BREQ _0x2000D
; 0001 0079         lcd_rs_high();                       /* RS=1: read data      */
	SBI  0x18,5
; 0001 007A     else
	RJMP _0x2000E
_0x2000D:
; 0001 007B         lcd_rs_low();                        /* RS=0: read busy flag */
	CBI  0x18,5
; 0001 007C     lcd_rw_high();                           /* RW=1  read mode      */
_0x2000E:
	SBI  0x18,7
; 0001 007D     /* configure data pins as input */
; 0001 007E     LCD_DATA0_DDR &= ~_BV(LCD_DATA0_PIN);
	CBI  0x1A,4
; 0001 007F     LCD_DATA1_DDR &= ~_BV(LCD_DATA1_PIN);
	CBI  0x1A,5
; 0001 0080     LCD_DATA2_DDR &= ~_BV(LCD_DATA2_PIN);
	CBI  0x1A,6
; 0001 0081     LCD_DATA3_DDR &= ~_BV(LCD_DATA3_PIN);
	CBI  0x1A,7
; 0001 0082     /* read high nibble first */
; 0001 0083     lcd_e_high();
	CALL SUBOPT_0x10
; 0001 0084     lcd_e_delay();
; 0001 0085     data = 0;
	LDI  R16,LOW(0)
; 0001 0086     if ( LCD_DATA0_DPIN & _BV(LCD_DATA0_PIN) ) data |= 0x10;
	SBIC 0x19,4
	ORI  R16,LOW(16)
; 0001 0087     if ( LCD_DATA1_DPIN & _BV(LCD_DATA1_PIN) ) data |= 0x20;
	SBIC 0x1A,5
	ORI  R16,LOW(32)
; 0001 0088     if ( LCD_DATA2_DPIN & _BV(LCD_DATA2_PIN) ) data |= 0x40;
	SBIC 0x1A,6
	ORI  R16,LOW(64)
; 0001 0089     if ( LCD_DATA3_DPIN & _BV(LCD_DATA3_PIN) ) data |= 0x80;
	SBIC 0x1A,7
	ORI  R16,LOW(128)
; 0001 008A     lcd_e_low();
	CBI  0x18,6
; 0001 008B     lcd_e_delay();                       /* Enable 500ns low       */
	__DELAY_USW 230
; 0001 008C     /* read low nibble */
; 0001 008D     lcd_e_high();
	CALL SUBOPT_0x10
; 0001 008E     lcd_e_delay();
; 0001 008F     if ( LCD_DATA0_DPIN & _BV(LCD_DATA0_PIN) ) data |= 0x01;
	SBIC 0x19,4
	ORI  R16,LOW(1)
; 0001 0090     if ( LCD_DATA1_DPIN & _BV(LCD_DATA1_PIN) ) data |= 0x02;
	SBIC 0x1A,5
	ORI  R16,LOW(2)
; 0001 0091     if ( LCD_DATA2_DPIN & _BV(LCD_DATA2_PIN) ) data |= 0x04;
	SBIC 0x1A,6
	ORI  R16,LOW(4)
; 0001 0092     if ( LCD_DATA3_DPIN & _BV(LCD_DATA3_PIN) ) data |= 0x08;
	SBIC 0x1A,7
	ORI  R16,LOW(8)
; 0001 0093     lcd_e_low();
	CBI  0x18,6
; 0001 0094     return data;
	MOV  R30,R16
	LDD  R16,Y+0
	RJMP _0x20E001A
; 0001 0095 }
;
;static unsigned char lcd_waitbusy(void) {
; 0001 0097 static unsigned char lcd_waitbusy(void) {
_lcd_waitbusy_G001:
; 0001 0098 	// register unsigned char c;
; 0001 0099     while (lcd_read(0) & (1<<LCD_BUSY)) {}
_0x20017:
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _lcd_read_G001
	ANDI R30,LOW(0x80)
	BRNE _0x20017
; 0001 009A     delay_us(10);
	__DELAY_USB 12
; 0001 009B     return (lcd_read(0));
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _lcd_read_G001
	RET
; 0001 009C }
;
;static inline void lcd_newline(byte pos) {
; 0001 009E static inline void lcd_newline(byte pos) {
_lcd_newline_G001:
; 0001 009F     register unsigned char addressCounter;
; 0001 00A0 
; 0001 00A1 
; 0001 00A2     if ( pos < (LCD_START_LINE2) )
	ST   -Y,R16
;	pos -> Y+1
;	addressCounter -> R16
	LDD  R26,Y+1
	CPI  R26,LOW(0x40)
	BRSH _0x2001A
; 0001 00A3         addressCounter = LCD_START_LINE2;
	LDI  R16,LOW(64)
; 0001 00A4     else
	RJMP _0x2001B
_0x2001A:
; 0001 00A5         addressCounter = LCD_START_LINE1;
	LDI  R16,LOW(0)
; 0001 00A6     lcd_command((1<<LCD_DDRAM)+addressCounter);
_0x2001B:
	MOV  R30,R16
	SUBI R30,-LOW(128)
	ST   -Y,R30
	RCALL _lcd_command
; 0001 00A7 }
	LDD  R16,Y+0
	RJMP _0x20E001A
;
;void lcd_command(byte cmd) {
; 0001 00A9 void lcd_command(byte cmd) {
_lcd_command:
; 0001 00AA     lcd_waitbusy();
;	cmd -> Y+0
	RCALL _lcd_waitbusy_G001
; 0001 00AB     lcd_write(cmd,0);
	LD   R30,Y
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _lcd_write_G001
; 0001 00AC }
	RJMP _0x20E0019
;
;void lcd_data(byte data) {
; 0001 00AE void lcd_data(byte data) {
; 0001 00AF     lcd_waitbusy();
;	data -> Y+0
; 0001 00B0     lcd_write(data,1);
; 0001 00B1 }
;
;void lcd_gotoxy(byte x, byte y) {
; 0001 00B3 void lcd_gotoxy(byte x, byte y) {
_lcd_gotoxy:
; 0001 00B4     if ( y==0 )
;	x -> Y+1
;	y -> Y+0
	LD   R30,Y
	CPI  R30,0
	BRNE _0x2001C
; 0001 00B5         lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
	LDD  R30,Y+1
	SUBI R30,-LOW(128)
	RJMP _0x2002D
; 0001 00B6     else
_0x2001C:
; 0001 00B7         lcd_command((1<<LCD_DDRAM)+LCD_START_LINE2+x);
	LDD  R30,Y+1
	SUBI R30,-LOW(192)
_0x2002D:
	ST   -Y,R30
	RCALL _lcd_command
; 0001 00B8 }
	RJMP _0x20E001A
;
;#pragma used+
;int lcd_getxy(void) {
; 0001 00BB int lcd_getxy(void) {
; 0001 00BC     return lcd_waitbusy();
; 0001 00BD }
;#pragma used-
;
;void lcd_clrscr(void) {
; 0001 00C0 void lcd_clrscr(void) {
_lcd_clrscr:
; 0001 00C1     lcd_command(1<<LCD_CLR);
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _lcd_command
; 0001 00C2 }
	RET
;
;void lcd_home(void) {
; 0001 00C4 void lcd_home(void) {
; 0001 00C5     lcd_command(1<<LCD_HOME);
; 0001 00C6 }
;
;void lcd_putc(byte c) {
; 0001 00C8 void lcd_putc(byte c) {
_lcd_putc:
; 0001 00C9     byte pos;
; 0001 00CA     // byte charoffset;            // байт смещения от начала таблицы
; 0001 00CB     byte lcd_symtable[64] = {   // 192..255
; 0001 00CC     //{'А','Б','В','Г','Д','Е','Ж','З','И','Й','К','Л','М','Н','О','П','Р','С','Т','У','Ф','Х','Ц','Ч','Ш','Щ','Ъ','Ы','Ь','Э','Ю','Я',
; 0001 00CD     // 'а','б','в','г','д','е','ж','з','и','й','к','л','м','н','о','п','р','с','т','у','ф','х','ц','ч','ш','щ','ъ','ы','ь','э','ю','я'},
; 0001 00CE         65,160, 66,161,224, 69,163,164,165,166, 75,167, 77, 72, 79,168, 80, 67, 84,169,170, 88,225,171,172,226,173,174,173,175,176,177,
; 0001 00CF         97,178,179,180,227,101,182,183,184,185,186,187,188,189,111,190,112, 99,191,121,228,120,229,192,193,230,194,195,196,197,198,199
; 0001 00D0     };
; 0001 00D1     pos = lcd_waitbusy();   // read busy-flag and address counter
	SBIW R28,63
	SBIW R28,1
	LDI  R24,64
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x2001E*2)
	LDI  R31,HIGH(_0x2001E*2)
	CALL __INITLOCB
	ST   -Y,R16
;	c -> Y+65
;	pos -> R16
;	lcd_symtable -> Y+1
	RCALL _lcd_waitbusy_G001
	MOV  R16,R30
; 0001 00D2     if (c=='\n') lcd_newline(pos);
	__GETB2SX 65
	CPI  R26,LOW(0xA)
	BRNE _0x2001F
	ST   -Y,R16
	RCALL _lcd_newline_G001
; 0001 00D3     else
	RJMP _0x20020
_0x2001F:
; 0001 00D4         if (c < 192) lcd_write(c, 1);
	__GETB2SX 65
	CPI  R26,LOW(0xC0)
	BRSH _0x20021
	__GETB1SX 65
	RJMP _0x2002E
; 0001 00D5         else lcd_write(lcd_symtable[c-192], 1);
_0x20021:
	__GETB1SX 65
	SUBI R30,LOW(192)
	LDI  R31,0
	MOVW R26,R28
	ADIW R26,1
	ADD  R26,R30
	ADC  R27,R31
	LD   R30,X
_0x2002E:
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _lcd_write_G001
; 0001 00D6 }
_0x20020:
	LDD  R16,Y+0
	ADIW R28,63
	ADIW R28,3
	RET
;
;void lcd_puts(const char *s) {
; 0001 00D8 void lcd_puts(const char *s) {
_lcd_puts:
; 0001 00D9     while (*s != 0) lcd_putc(*s++);
;	*s -> Y+0
_0x20023:
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X
	CPI  R30,0
	BREQ _0x20025
	LD   R30,X+
	ST   Y,R26
	STD  Y+1,R27
	ST   -Y,R30
	RCALL _lcd_putc
	RJMP _0x20023
_0x20025:
; 0001 00DA }
_0x20E001A:
	ADIW R28,2
	RET
;// Функция печати на LCD строки меню. Если submenu = 1, то печатаем символ '>' на 16 позиции
;void lcd_line_menu(const char *s, byte submenu) {
; 0001 00DC void lcd_line_menu(const char *s, byte submenu) {
_lcd_line_menu:
; 0001 00DD     register byte i;
; 0001 00DE     for(i=0; i<(LCD_DISP_LENGTH-1); i++) {
	ST   -Y,R16
;	*s -> Y+2
;	submenu -> Y+1
;	i -> R16
	LDI  R16,LOW(0)
_0x20027:
	CPI  R16,15
	BRSH _0x20028
; 0001 00DF         if (*s != 0) lcd_putc(*s++); else lcd_putc(0x20);
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LD   R30,X
	CPI  R30,0
	BREQ _0x20029
	LD   R30,X+
	STD  Y+2,R26
	STD  Y+2+1,R27
	RJMP _0x2002F
_0x20029:
	LDI  R30,LOW(32)
_0x2002F:
	ST   -Y,R30
	RCALL _lcd_putc
; 0001 00E0     }
	SUBI R16,-1
	RJMP _0x20027
_0x20028:
; 0001 00E1     // Если включен флаг submenu, печатаем символ '>', иначе - ' '
; 0001 00E2     if (submenu) lcd_putc('>'); else lcd_putc(0x20);
	LDD  R30,Y+1
	CPI  R30,0
	BREQ _0x2002B
	LDI  R30,LOW(62)
	RJMP _0x20030
_0x2002B:
	LDI  R30,LOW(32)
_0x20030:
	ST   -Y,R30
	RCALL _lcd_putc
; 0001 00E3 }
	LDD  R16,Y+0
	ADIW R28,4
	RET
;
;void lcd_init(byte dispAttr) {
; 0001 00E5 void lcd_init(byte dispAttr) {
_lcd_init:
; 0001 00E6 	/* configure all port bits as output (LCD data and control lines on different ports */
; 0001 00E7     LCD_RS_DDR    |= _BV(LCD_RS_PIN);
;	dispAttr -> Y+0
	SBI  0x17,5
; 0001 00E8     LCD_RW_DDR    |= _BV(LCD_RW_PIN);
	SBI  0x17,7
; 0001 00E9     LCD_E_DDR     |= _BV(LCD_E_PIN);
	SBI  0x17,6
; 0001 00EA     LCD_DATA0_DDR |= _BV(LCD_DATA0_PIN);
	SBI  0x1A,4
; 0001 00EB     LCD_DATA1_DDR |= _BV(LCD_DATA1_PIN);
	SBI  0x1A,5
; 0001 00EC     LCD_DATA2_DDR |= _BV(LCD_DATA2_PIN);
	SBI  0x1A,6
; 0001 00ED     LCD_DATA3_DDR |= _BV(LCD_DATA3_PIN);
	SBI  0x1A,7
; 0001 00EE     delay_ms(16);        /* wait 16ms or more after power-on       */
	LDI  R30,LOW(16)
	LDI  R31,HIGH(16)
	CALL SUBOPT_0xB
; 0001 00EF 
; 0001 00F0     /* initial write to lcd is 8bit */
; 0001 00F1     LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
	SBI  0x1B,5
; 0001 00F2     LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
	SBI  0x1B,4
; 0001 00F3     lcd_e_toggle();
	RCALL _lcd_e_toggle_G001
; 0001 00F4     delay_ms(41);         /* delay, busy flag can't be checked here */
	LDI  R30,LOW(41)
	LDI  R31,HIGH(41)
	CALL SUBOPT_0xB
; 0001 00F5 
; 0001 00F6     /* repeat last command */
; 0001 00F7     lcd_e_toggle();
	CALL SUBOPT_0x11
; 0001 00F8     delay_us(64);           /* delay, busy flag can't be checked here */
; 0001 00F9 
; 0001 00FA     /* repeat last command a third time */
; 0001 00FB     lcd_e_toggle();
	CALL SUBOPT_0x11
; 0001 00FC     delay_us(64);           /* delay, busy flag can't be checked here */
; 0001 00FD 
; 0001 00FE     /* now configure for 4bit mode */
; 0001 00FF     LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
	CBI  0x1B,4
; 0001 0100     lcd_e_toggle();
	CALL SUBOPT_0x11
; 0001 0101     delay_us(64);           /* some displays need this additional delay */
; 0001 0102 
; 0001 0103     lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
	LDI  R30,LOW(40)
	ST   -Y,R30
	RCALL _lcd_command
; 0001 0104     lcd_command(LCD_DISP_OFF);              /* display off                  */
	LDI  R30,LOW(8)
	ST   -Y,R30
	RCALL _lcd_command
; 0001 0105     lcd_clrscr();                           /* display clear                */
	RCALL _lcd_clrscr
; 0001 0106     lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
	LDI  R30,LOW(6)
	ST   -Y,R30
	RCALL _lcd_command
; 0001 0107     lcd_command(dispAttr);                  /* display/cursor control       */
	LD   R30,Y
	ST   -Y,R30
	RCALL _lcd_command
; 0001 0108 }
_0x20E0019:
	ADIW R28,1
	RET
;#include <mega32.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x80
	.EQU __sm_mask=0x70
	.EQU __sm_powerdown=0x20
	.EQU __sm_powersave=0x30
	.EQU __sm_standby=0x60
	.EQU __sm_ext_standby=0x70
	.EQU __sm_adc_noise_red=0x10
	.SET power_ctrl_reg=mcucr
	#endif
;#include <stdlib.h>  // for abs
;#include <stdio.h>
;#include <delay.h>
;#include "lcd_4bit.h"
;#include "menu.h"
;#include "robowater.h"
;// DS1820 функции температурного преобразования (Биденко+Панарин)
;#include "spd1820.h"
;#include "valcoder.h"
;#include "at2404.h"
;#include "alarm.h"
;#include "signals.h"
;#include "keys.h"
;// Локальные макроподстановки
;#define MAJOR_VERSION 4
;#define MINOR_VERSION 1
;// #define NODEBUG
;// enum
;// Определение главных структур
;// Описание глобальны переменных
;// int tw_prs;             // Заданная температура воды
;// TW_in_Min -Температура Воды на входе( Подаче ) мин. ?
;// TW_out_Min -Температура Воды на выходе ( Обратка ) мин.
;// TW_out_Stop -Температура Воды на входе для поддержания в режиме стоп.
;// TA_in_Min -Температура Воздуха на входе мин -30 С.
;// TA_out_Min -Температура Воздуха на выходе мин +15 С.
;// TA_out_prs -Температура Воздуха на выходе установленная +20 С.(Заданная)
;unsigned char key_treated[7] = {0,0,0,0,0,0,0} ;
;struct st_mode mode = {0, 0, 0, 0, 0, 0, 1, 0.0,0};  // Текущий режим работы

	.DSEG
;struct st_datetime s_dt;
;// Начальные установки структуры основных переменных
;struct st_eeprom_par prim_par={
;    {{(int)0, 0}, {(int)0, 0}, {(int)0, 0}, {(int)0, 0}},
;    0xFF, 205, 0x7F, 0x7F,
;    (int)10, (int)0, (int)0,
;    (int)180, (int)100,
;    (int)1600, (int)5000,
;    (int)-2000, (int)1500, (int)2200,
;    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
;    1,  // Зима
;    0,  // Позиция текущего alarm в EEPROM
;    0,   // Сколько всего зарегистрировано в EEPROM
;    MAX_DS1820, // Сколько должно быть термометров в системе
;
;    /*{{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE}, // 28	4D	52	7E 	3	0	0	6E	1	FF	FE воздух помещение
;     {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFD}, // 28	D3	8	7E	3	0	0	E4	1	FF	FD   воздух улица
;     {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC}, // 28	8C	38	7E	3	0	0	6A	1	FF	FC   вода подача
;     {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFB}} // 28	91	9	7E	3	0	0	32	1	FF	FB   вода обратка
;    */
;     /*  Ньютона металоизделия П1
;     {{0x28,0x29,0x32,0x7e,0x03,0x00,0x00,0x60,0x01}, // 28	29	32	7E 	3	0	0	60	1	FF	FE
;     {0x28,0x13,0x3b,0x7e,0x03,0x00,0x00,0xb1,0x01}, // 28	13	3B	7E	3	0	0	B1	1	FF	FD
;     {0x28,0x1e,0x2f,0x7e,0x03,0x00,0x00,0x98,0x01}, // 28	1E	2F	7E	3	0	0	98	1	FF	FC
;     {0x28,0x39,0x46,0x7e,0x03,0x00,0x00,0x49,0x01}} // 28	39	46	7E	3	0	0	49	1	FF	FB
;    */
;     //Ньютона металоизделия П2
;     {{0x28,0x95,0x0f,0x7e,0x03,0x00,0x00,0x72,0x01}, // 28	95	F	7E 	3	0	0	72	1	FF	FE
;     {0x28,0xc1,0x1a,0x7e,0x03,0x00,0x00,0x2e,0x01}, // 28	C1	1A	7E	3	0	0	2E	1	FF	FD
;     {0x28,0x1a,0x17,0x7e,0x03,0x00,0x00,0xfe,0x01}, // 28	1A	17	7E	3	0	0	FE	1	FF	FC
;     {0x28,0xe8,0x2a,0x7e,0x03,0x00,0x00,0x8a,0x01}} // 28	E8	2A	7E	3	0	0	8A	1	FF	FB
;
;     /*  Ньютона металоизделия П3
;     {{0x28,0x50,0x32,0x7e,0x03,0x00,0x00,0x6e,0x01}, // 28	50	32	7E 	3	0	0	6E	1	FF	FE
;     {0x28,0x3e,0x1c,0x7e,0x03,0x00,0x00,0xe4,0x01}, // 28	3E	1C	7E	3	0	0	E4	1	FF	FD
;     {0x28,0xb7,0x0d,0x7e,0x03,0x00,0x00,0x29,0x01}, // 28	B7	D	7E	3	0	0	29	1	1	FF	FC
;     {0x28,0x2c,0x0c,0x7e,0x03,0x00,0x00,0xad,0x01}} // 28	2C	C	7E	3	0	0	AD	1	FF	FB
;     */
;    /* Ньютона металоизделия П4
;    {{0x28,0x4d,0x52,0x7e,0x03,0x00,0x00,0x6e,0x01}, // 28	4D	52	7E 	3	0	0	6E	1	FF	FE
;     {0x28,0xd3,0x08,0x7e,0x03,0x00,0x00,0xe4,0x01}, // 28	D3	8	7E	3	0	0	E4	1	FF	FD
;     {0x28,0x8c,0x38,0x7e,0x03,0x00,0x00,0x6a,0x01}, // 28	8C	38	7E	3	0	0	6A	1	FF	FC
;     {0x28,0x91,0x09,0x7e,0x03,0x00,0x00,0x32,0x01}} // 28	91	9	7E	3	0	0	32	1	FF	FB
;    */
;
;
;    /*    50 ЛетВЛКСМ бильярдная.
;    {{0x28,0x1b,0xc4,0x24,0x00,0x00,0x00,0xfe,0x01}, // 28	1b	c4	24	0	0	0	fe	1	FF	FE
;     {0x28,0xbb,0x0a,0x95,0x03,0x00,0x00,0xd8,0x01}, // 28	bb	a	95	3	0	0	d8	1	FF	FD
;     {0x22,0x8e,0xe1,0x03,0x00,0x00,0x00,0xf3,0x01}, // 22	8e	e1	3	0	0	0	f3	1	FF	FC
;     {0x22,0x2b,0x08,0x04,0x00,0x00,0x00,0xeb,0x01}} // 22	2b	8	4	0	0	0	eb	1	FF	FB
;    */
;
;};
;unsigned int time_integration=0;
;int tmp_delta;
;byte tap_angle_min = 0;   // Ограничение крана снизу от температуры
;// byte fan_speed = 0;  // Скорость вентилятора
;enum en_event event;                          // Текущее событие в системе
;// Описание функций
;void printallterms(void); void lcd_primary_screen(void);
;void print_prim_par(unsigned char *, unsigned char);
;// Функции основного цикла
;void check_serial(void);
;void check_peripheral(void);
;void event_processing(void);
;void mode_processing(void);
;void update_P(int);
;void update_PID(int error, int iMin, int iMax);
;void init_new_terms(unsigned char);
;// Основная программа
;void main(void) {
; 0002 0066 void main(void) {

	.CSEG
_main:
; 0002 0067     // register byte i;
; 0002 0068     byte size_prim_par;
; 0002 0069 
; 0002 006A     init();                  // Инициализация всей периферии
;	size_prim_par -> R16
	CALL _init
; 0002 006B     #asm("sei")             // Global enable interrupts
	sei
; 0002 006C     printf ("Инициализация кнопок...\r\n");
	__POINTW1FN _0x40000,0
	CALL SUBOPT_0x1
; 0002 006D     init_keys();
	CALL _init_keys
; 0002 006E     printf("Старт Ньютона металоизделия П2_1. %u.%02u. Найдено %u термометров.\r\n", MAJOR_VERSION, MINOR_VERSION, ds1820_devices);
	__POINTW1FN _0x40000,26
	ST   -Y,R31
	ST   -Y,R30
	__GETD1N 0x4
	CALL __PUTPARD1
	__GETD1N 0x1
	CALL __PUTPARD1
	CALL SUBOPT_0x9
	CALL SUBOPT_0x12
; 0002 006F     // Сохраняем в EEPROM структуру prim_par
; 0002 0070     // ppr_par = &prim_par;
; 0002 0071     size_prim_par = sizeof(prim_par);
	LDI  R16,LOW(88)
; 0002 0072     // СБРОС параметров в EEPROM к заводским установкам
; 0002 0073     if (!KEY_CANCEL && !KEY_ENTER) {
	CALL SUBOPT_0x13
	BRNE _0x40006
	CALL SUBOPT_0x14
	BREQ _0x40007
_0x40006:
	RJMP _0x40005
_0x40007:
; 0002 0074         unsigned char term_status;
; 0002 0075         ds1820_devices = MAX_DS1820;
	SBIW R28,1
;	term_status -> Y+0
	CALL SUBOPT_0x15
; 0002 0076         // Сихронизация массива термометров с EEPROM
; 0002 0077         term_status = sync_ds1820_eeprom();
; 0002 0078         eeprom_write_struct ((unsigned char *)&prim_par, size_prim_par);
	CALL SUBOPT_0x16
	ST   -Y,R16
	CALL _eeprom_write_struct
; 0002 0079         // Запускаем таймер инактивности
; 0002 007A         printf("Запись в EEPROM заводских установок.\r\n Неопознанных термометров = %u\r\n", term_status);
	__POINTW1FN _0x40000,95
	CALL SUBOPT_0x17
; 0002 007B     } else {
	RJMP _0x4015E
_0x40005:
; 0002 007C         unsigned char size_addr = size_prim_par - sizeof(prim_par.addr);
; 0002 007D         if (!KEY_CANCEL) {
	SBIW R28,1
;	size_addr -> Y+0
	MOV  R30,R16
	SUBI R30,LOW(36)
	ST   Y,R30
	CALL SUBOPT_0x13
	BRNE _0x40009
; 0002 007E             ds1820_devices = MAX_DS1820;
	LDI  R30,LOW(4)
	__PUTB1MN _prim_par,51
; 0002 007F             printf("Запись в EEPROM установок по умолчанию.\r\n");
	__POINTW1FN _0x40000,166
	CALL SUBOPT_0x1
; 0002 0080             eeprom_write_struct ((unsigned char *)&prim_par, size_addr);
	CALL SUBOPT_0x16
	LDD  R30,Y+2
	ST   -Y,R30
	CALL _eeprom_write_struct
; 0002 0081         }
; 0002 0082         if (!KEY_ENTER) {
_0x40009:
	CALL SUBOPT_0x14
	BRNE _0x4000A
; 0002 0083             unsigned char term_status;
; 0002 0084             eeprom_read_struct ((char *)&prim_par, size_addr);
	SBIW R28,1
;	size_addr -> Y+1
;	term_status -> Y+0
	CALL SUBOPT_0x16
	LDD  R30,Y+3
	ST   -Y,R30
	CALL _eeprom_read_struct
; 0002 0085             ds1820_devices = MAX_DS1820;
	CALL SUBOPT_0x15
; 0002 0086             // Сихронизация массива термометров с EEPROM
; 0002 0087             term_status = sync_ds1820_eeprom();
; 0002 0088             printf("Запись в EEPROM %u новых термометров.\r\n", term_status);
	__POINTW1FN _0x40000,208
	CALL SUBOPT_0x17
; 0002 0089             eeprom_write_struct ((unsigned char *)&prim_par, size_prim_par);
	CALL SUBOPT_0x16
	ST   -Y,R16
	CALL _eeprom_write_struct
; 0002 008A         }
	ADIW R28,1
; 0002 008B     }
_0x4000A:
_0x4015E:
	ADIW R28,1
; 0002 008C     // Восстанавливаем из EEPROM структуру prim_par
; 0002 008D     eeprom_read_struct ((char *)&prim_par, size_prim_par);
	CALL SUBOPT_0x16
	ST   -Y,R16
	CALL _eeprom_read_struct
; 0002 008E     // printf("\r\n");
; 0002 008F     read_all_terms(INIT_MODE);
	CALL SUBOPT_0x18
; 0002 0090     // print_all_menu();       // Выведем на отладочную консоль все пункты меню
; 0002 0091     sync_set_par(SYNC_TO_MENU); // Синхронизируем меню с глобальными структурами
	CALL SUBOPT_0x19
; 0002 0092     update_alert_menu();        // Обновляем меню alerts
	CALL _update_alert_menu
; 0002 0093     //printf("После чтение из EEPROM значение Tw2=%u\r\n", prim_par.Tw2);
; 0002 0094     // printf("Было %u, стало после чтение из EEPROM size=%u\r\n", sizeof(prim_par), size_prim_par);
; 0002 0095     #ifndef NODEBUG
; 0002 0096     // Если есть термометры, то выводим их значение
; 0002 0097     printallterms();
	RCALL _printallterms
; 0002 0098     #endif
; 0002 0099     lcd_primary_screen();       // выводим стартовую картинку на экранчик
	RCALL _lcd_primary_screen
; 0002 009A     // if (PINC.6) PORTD |= (1<<4); else PORTD &= ~(1<<4);
; 0002 009B     // if (PINC.7) PORTD &= ~(1<<5); else PORTD |= (1<<5);
; 0002 009C     // if (PINC.5) PORTD &= ~(1<<5); else PORTD |= (1<<5);
; 0002 009D     if (prim_par.season) signal_white(ON); else signal_white(OFF);
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x4000B
	LDI  R30,LOW(1)
	RJMP _0x4015F
_0x4000B:
	LDI  R30,LOW(0)
_0x4015F:
	ST   -Y,R30
	CALL _signal_white
; 0002 009E     FAN_SPEED = prim_par.fan_speed;
	CALL SUBOPT_0x1A
; 0002 009F     //fan_speed = FAN_SPEED;
; 0002 00A0     //if (FAN_SPEED <= FAN_SPEED_MIN) FAN_SPEED = FAN_SPEED_MIN;
; 0002 00A1     tmp_delta = abs(prim_par.TA_in_Min) + TA_IN_NOLIMIT;  // вычисление диапазона работы ограничителя крана по температуре
	CALL SUBOPT_0x1B
	CALL SUBOPT_0x1C
	CLR  R22
	CLR  R23
	__ADDD1N 500
	MOVW R4,R30
; 0002 00A2     mode.k_angle_limit = (TAP_ANGLE_LIMIT / tmp_delta) * 1000; // вычисление коэффициента ограничения крана для заданных настроек
	MOVW R30,R4
	CALL __CWD1
	CALL __CDF1
	__GETD2N 0x429C0000
	CALL __DIVF21
	__GETD2N 0x447A0000
	CALL __MULF12
	__POINTW2MN _mode,7
	CALL __CFD1
	ST   X+,R30
	ST   X,R31
; 0002 00A3     if (UL_T < TA_IN_NOLIMIT) {    // Вычисление угла ограничения (UL_T < TA_IN_NOLIMIT)
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1E
	BRGE _0x4000D
; 0002 00A4         tap_angle_min = ((long int)((TA_IN_NOLIMIT - UL_T) * mode.k_angle_limit))/1000;   // вычисление ограничения крана по температуре воздуха на входе и коэффициенту mode.k_angle_limit
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1F
; 0002 00A5     };
_0x4000D:
; 0002 00A6     if (TAP_ANGLE < tap_angle_min) TAP_ANGLE = tap_angle_min;
	CALL SUBOPT_0x20
	BRGE _0x4000E
	__POINTW2MN _parameters,30
	MOV  R30,R6
	RJMP _0x40160
; 0002 00A7        else TAP_ANGLE = prim_par.tap_angle;
_0x4000E:
	__POINTW2MN _parameters,30
	__GETB1MN _prim_par,12
_0x40160:
	LDI  R31,0
	ST   X+,R30
	ST   X,R31
; 0002 00A8     printf("Установка вентилятора. %u. Установка крана %u .\r\n", FAN_SPEED, TAP_ANGLE);
	__POINTW1FN _0x40000,248
	CALL SUBOPT_0x21
	CALL SUBOPT_0x22
	CALL SUBOPT_0x23
	CALL SUBOPT_0x24
; 0002 00A9     while(1) {
_0x40010:
; 0002 00AA         // ВНИМАНИЕ! НИЖЕ ДО ОКОНЧАНИЯ ЦИКЛА WHILE КОД НЕ ДОБАВЛЯТЬ!!!
; 0002 00AB         check_serial();
	CALL _check_serial
; 0002 00AC         poll_keys();
	CALL _poll_keys
; 0002 00AD         // if (event == ev_none) check_peripheral();
; 0002 00AE         /* if (0 == 1) */ check_peripheral();
	RCALL _check_peripheral
; 0002 00AF         /* if (0 == 1) */ event_processing();
	RCALL _event_processing
; 0002 00B0         /* if (0 == 1) */ mode_processing();
	RCALL _mode_processing
; 0002 00B1     }; // while (1)
	RJMP _0x40010
; 0002 00B2 
; 0002 00B3 } // void main(void)
_0x40013:
	RJMP _0x40013
;// Функция опроса перефирии и генерации событий по результатом опроса, а также по результатам МАТАнализа
;void check_peripheral(void) {
; 0002 00B5 void check_peripheral(void) {
_check_peripheral:
; 0002 00B6     // В этой функции запрещено (!) устанавливать режимы
; 0002 00B7     // Обрабатываем поворот valcoder'а
; 0002 00B8     if ((abs(valcoder)-VALCODER_SENSITY) >= 0) {        // Если сработал valcoder
	LDS  R30,_valcoder
	CALL SUBOPT_0x25
	SBIW R30,1
	BRLO _0x40014
; 0002 00B9         // printf ("Сгенерировали кручение (%i)...\r\n", valcoder);
; 0002 00BA         if (valcoder < 0)
	LDS  R26,_valcoder
	CPI  R26,0
	BRGE _0x40015
; 0002 00BB             event = ev_left;
	LDI  R30,LOW(1)
	RJMP _0x40161
; 0002 00BC         else
_0x40015:
; 0002 00BD             event = ev_right;
	LDI  R30,LOW(3)
_0x40161:
	STS  _event,R30
; 0002 00BE     }
; 0002 00BF     // Если поворота не было, опрашиваем другие порты
; 0002 00C0     if (CHECK_EVENT && (!KEY_ENTER)) event = ev_enter;
_0x40014:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40018
	CALL SUBOPT_0x14
	BREQ _0x40019
_0x40018:
	RJMP _0x40017
_0x40019:
	LDI  R30,LOW(2)
	STS  _event,R30
; 0002 00C1     if (CHECK_EVENT && (!KEY_CANCEL)) event = ev_cancel;
_0x40017:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x4001B
	CALL SUBOPT_0x13
	BREQ _0x4001C
_0x4001B:
	RJMP _0x4001A
_0x4001C:
	LDI  R30,LOW(4)
	STS  _event,R30
; 0002 00C2     // Обслуживаем кнопку стоп
; 0002 00C3     //if (CHECK_EVENT && (!timer_stop) && (!KEY_STOP)) event = ev_stop;
; 0002 00C4     if (CHECK_EVENT &&  (!KEY_STOP)) event = ev_stop;
_0x4001A:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x4001E
	LDI  R30,LOW(0)
	CALL SUBOPT_0x26
	BREQ _0x4001F
_0x4001E:
	RJMP _0x4001D
_0x4001F:
	LDI  R30,LOW(8)
	STS  _event,R30
; 0002 00C5     // Обслуживаем кнопку старт, Проверяя при этом наличие каких-либо аварий
; 0002 00C6     if (CHECK_EVENT && (IS_ALERT == 0) && (!KEY_START)) event = ev_start;
_0x4001D:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40021
	__GETB1MN _main_menu,28
	CPI  R30,0
	BRNE _0x40021
	LDI  R30,LOW(1)
	CALL SUBOPT_0x26
	BREQ _0x40022
_0x40021:
	RJMP _0x40020
_0x40022:
	LDI  R30,LOW(7)
	STS  _event,R30
; 0002 00C7     // Для более "живой" клавиатуры выходим, если событие сгенерировано
; 0002 00C8     // Проверка свитчиков
; 0002 00C9     if (CHECK_EVENT && (!prim_par.alert_status[0]) && (KEY_ALARM1)) event = ev_alarm1; // Пожар, перегрев вентилятора, авария частотника
_0x40020:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40024
	__GETB1MN _prim_par,36
	CPI  R30,0
	BRNE _0x40024
	LDI  R30,LOW(4)
	CALL SUBOPT_0x26
	BRNE _0x40025
_0x40024:
	RJMP _0x40023
_0x40025:
	LDI  R30,LOW(9)
	STS  _event,R30
; 0002 00CA     if (CHECK_EVENT && (!prim_par.alert_status[1]) && (KEY_ALARM2)) event = ev_alarm2; // Угроза замораживания от внешнего датчика
_0x40023:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40027
	__GETB1MN _prim_par,37
	CPI  R30,0
	BRNE _0x40027
	LDI  R30,LOW(5)
	CALL SUBOPT_0x26
	BRNE _0x40028
_0x40027:
	RJMP _0x40026
_0x40028:
	LDI  R30,LOW(10)
	STS  _event,R30
; 0002 00CB     if (CHECK_EVENT && (!prim_par.alert_status[11]) && (!KEY_FILTER)) event = ev_filter; // Загрязнение фильтра.
_0x40026:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x4002A
	__GETB1MN _prim_par,47
	CPI  R30,0
	BRNE _0x4002A
	LDI  R30,LOW(6)
	CALL SUBOPT_0x26
	BREQ _0x4002B
_0x4002A:
	RJMP _0x40029
_0x4002B:
	LDI  R30,LOW(11)
	STS  _event,R30
; 0002 00CC     // Проверка термометров
; 0002 00CD     if (CHECK_EVENT && (!prim_par.alert_status[7]) && (termometers[0].err >= MAX_OFFLINES))
_0x40029:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x4002D
	__GETB1MN _prim_par,43
	CPI  R30,0
	BRNE _0x4002D
	__GETB2MN _termometers,5
	CPI  R26,LOW(0x5)
	BRSH _0x4002E
_0x4002D:
	RJMP _0x4002C
_0x4002E:
; 0002 00CE         // printf("Нет термометра В1 (Помещение): %d, err=%d", prim_par.alert_status[7], termometers[0].err);
; 0002 00CF         event = ev_term1_nf;
	LDI  R30,LOW(15)
	STS  _event,R30
; 0002 00D0     if (CHECK_EVENT && (!prim_par.alert_status[8]) && (termometers[1].err >= MAX_OFFLINES))
_0x4002C:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40030
	__GETB1MN _prim_par,44
	CPI  R30,0
	BRNE _0x40030
	__GETB2MN _termometers,11
	CPI  R26,LOW(0x5)
	BRSH _0x40031
_0x40030:
	RJMP _0x4002F
_0x40031:
; 0002 00D1         // Нет термометра В 2 - Улица
; 0002 00D2         event = ev_term2_nf;
	LDI  R30,LOW(16)
	STS  _event,R30
; 0002 00D3     if (CHECK_EVENT && (!prim_par.alert_status[9]) && (termometers[2].err >= MAX_OFFLINES))
_0x4002F:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40033
	__GETB1MN _prim_par,45
	CPI  R30,0
	BRNE _0x40033
	__GETB2MN _termometers,17
	CPI  R26,LOW(0x5)
	BRSH _0x40034
_0x40033:
	RJMP _0x40032
_0x40034:
; 0002 00D4         // Нет термометра В 3 - Подача
; 0002 00D5         event = ev_term3_nf;
	LDI  R30,LOW(17)
	STS  _event,R30
; 0002 00D6     if (CHECK_EVENT && (!prim_par.alert_status[10]) && (termometers[3].err >= MAX_OFFLINES))
_0x40032:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40036
	__GETB1MN _prim_par,46
	CPI  R30,0
	BRNE _0x40036
	__GETB2MN _termometers,23
	CPI  R26,LOW(0x5)
	BRSH _0x40037
_0x40036:
	RJMP _0x40035
_0x40037:
; 0002 00D7         // Нет термометра В 4 - Обратка
; 0002 00D8         event = ev_term4_nf;
	LDI  R30,LOW(18)
	STS  _event,R30
; 0002 00D9     // Здесь осуществляет матанализ для генерации событий
; 0002 00DA     if (UL_T < TA_IN_NOLIMIT) {
_0x40035:
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1E
	BRLT PC+3
	JMP _0x40038
; 0002 00DB         if (CHECK_EVENT && !(prim_par.alert_status[8] || prim_par.alert_status[2]) &&
; 0002 00DC             (termometers[1].t < (prim_par.TA_in_Min-5))) // Температура на улице ниже критической  на 5 градусов.UL_T
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x4003A
	__GETB1MN _prim_par,44
	CPI  R30,0
	BRNE _0x4003B
	__GETB1MN _prim_par,38
	CPI  R30,0
	BREQ _0x4003C
_0x4003B:
	RJMP _0x4003A
_0x4003C:
	__GETW2MN _termometers,6
	CALL SUBOPT_0x1B
	SBIW R30,5
	CP   R26,R30
	CPC  R27,R31
	BRLT _0x4003D
_0x4003A:
	RJMP _0x40039
_0x4003D:
; 0002 00DD             event = ev_freezing1;
	LDI  R30,LOW(12)
	STS  _event,R30
; 0002 00DE         if (CHECK_EVENT && !(prim_par.alert_status[7] || prim_par.alert_status[3]) &&
_0x40039:
; 0002 00DF             (termometers[0].t < prim_par.TA_out_Min)) // Температура в помещения ниже критической POM_T
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x4003F
	__GETB1MN _prim_par,43
	CPI  R30,0
	BRNE _0x40040
	__GETB1MN _prim_par,39
	CPI  R30,0
	BREQ _0x40041
_0x40040:
	RJMP _0x4003F
_0x40041:
	__GETW1MN _prim_par,32
	LDS  R26,_termometers
	LDS  R27,_termometers+1
	CP   R26,R30
	CPC  R27,R31
	BRLT _0x40042
_0x4003F:
	RJMP _0x4003E
_0x40042:
; 0002 00E0             event = ev_freezing2;
	LDI  R30,LOW(13)
	STS  _event,R30
; 0002 00E1         if (CHECK_EVENT && !(prim_par.alert_status[10] || prim_par.alert_status[5]) &&
_0x4003E:
; 0002 00E2             (termometers[3].t < prim_par.TW_out_Min)) // Температура воды обратки ниже критической WOUT_T
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40044
	__GETB1MN _prim_par,46
	CPI  R30,0
	BRNE _0x40045
	__GETB1MN _prim_par,41
	CPI  R30,0
	BREQ _0x40046
_0x40045:
	RJMP _0x40044
_0x40046:
	__GETW2MN _termometers,18
	__GETW1MN _prim_par,26
	CP   R26,R30
	CPC  R27,R31
	BRLT _0x40047
_0x40044:
	RJMP _0x40043
_0x40047:
; 0002 00E3             event = ev_freezing3;
	LDI  R30,LOW(14)
	STS  _event,R30
; 0002 00E4     }
_0x40043:
; 0002 00E5     if (CHECK_EVENT && (mode.initrun)) {
_0x40038:
	LDS  R26,_event
	CPI  R26,LOW(0x0)
	BRNE _0x40049
	__GETB1MN _mode,2
	CPI  R30,0
	BRNE _0x4004A
_0x40049:
	RJMP _0x40048
_0x4004A:
; 0002 00E6         mode.initrun -= 4;
	__GETB1MN _mode,2
	SUBI R30,LOW(4)
	__PUTB1MN _mode,2
; 0002 00E7         if ((mode.initrun) && (IS_ALERT == 0)) event = ev_start;
	__GETB1MN _mode,2
	CPI  R30,0
	BREQ _0x4004C
	__GETB1MN _main_menu,28
	CPI  R30,0
	BREQ _0x4004D
_0x4004C:
	RJMP _0x4004B
_0x4004D:
	LDI  R30,LOW(7)
	RJMP _0x40162
; 0002 00E8        else
_0x4004B:
; 0002 00E9             event = ev_stop;
	LDI  R30,LOW(8)
_0x40162:
	STS  _event,R30
; 0002 00EA         mode.initrun = 0;
	LDI  R30,LOW(0)
	__PUTB1MN _mode,2
; 0002 00EB     }
; 0002 00EC     #ifndef NODEBUG
; 0002 00ED     // if (event) printf ("Сгенерировано новое событие: %u\r\n", (unsigned char)event);
; 0002 00EE     //if (event) printf ("-");
; 0002 00EF     #endif
; 0002 00F0 }
_0x40048:
	RET
;// Обработка событий в системе
;void event_processing(void) {
; 0002 00F2 void event_processing(void) {
_event_processing:
; 0002 00F3     // Только здесь можно менять режимы. Но здесь нельзя опрашивать периферию, делать матанализ
; 0002 00F4     #ifndef NODEBUG
; 0002 00F5     // if (event != ev_none)
; 0002 00F6         // printf ("%02u:%02u Текущее событие = %u\r\n", s_dt.cMM, s_dt.cSS, (unsigned char)event);
; 0002 00F7     #endif
; 0002 00F8     // Также здесь выполняются инициализационные действия для процессов: Вкл./выкл индикатор, запустить бибикалку, нарисовать строку меню и т.п.
; 0002 00F9     switch (event) {
	LDS  R30,_event
; 0002 00FA         case ev_secunda:                // Обрабатываем ежесекундное событие.
	CPI  R30,LOW(0x5)
	BREQ PC+3
	JMP _0x40052
; 0002 00FB             MAIN_T = read_term(0);       // Выводим информацию о главном термометре !!!
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _read_term
	STS  _main_menu,R30
	STS  _main_menu+1,R31
; 0002 00FC             switch (mode.menu) {
	LDS  R30,_mode
; 0002 00FD                 case 0: lcd_primary_screen(); break;
	CPI  R30,0
	BRNE _0x40056
	RCALL _lcd_primary_screen
	RJMP _0x40055
; 0002 00FE                 case 1: lcd_menu(0); break;
_0x40056:
	CPI  R30,LOW(0x1)
	BRNE _0x40058
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _lcd_menu
; 0002 00FF                 default: ;
_0x40058:
; 0002 0100                 // case 2: lcd_edit(0); break;
; 0002 0101             }
_0x40055:
; 0002 0102             //if (!mode.print && (mode.run ==1)) printf("-");
; 0002 0103             if (mode.print && (mode.run ==1)) printf("-");
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x4005A
	__GETB2MN _mode,1
	CPI  R26,LOW(0x1)
	BREQ _0x4005B
_0x4005A:
	RJMP _0x40059
_0x4005B:
	__POINTW1FN _0x40000,298
	CALL SUBOPT_0x1
; 0002 0104             if (mode.print && (mode.run ==3)) printf ("До следующего измерения ПУСК: %u\r\n", time_integration);
_0x40059:
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x4005D
	__GETB2MN _mode,1
	CPI  R26,LOW(0x3)
	BREQ _0x4005E
_0x4005D:
	RJMP _0x4005C
_0x4005E:
	__POINTW1FN _0x40000,300
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x27
	CALL SUBOPT_0xA
; 0002 0105             if (mode.print && (mode.run ==0)) printf ("До следующего измерения СТОП: %u\r\n", timer_fan);
_0x4005C:
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x40060
	__GETB2MN _mode,1
	CPI  R26,LOW(0x0)
	BREQ _0x40061
_0x40060:
	RJMP _0x4005F
_0x40061:
	__POINTW1FN _0x40000,335
	ST   -Y,R31
	ST   -Y,R30
	LDS  R30,_timer_fan
	CALL SUBOPT_0x28
	CALL SUBOPT_0xA
; 0002 0106             event = ev_none;            // Очищаем событие
_0x4005F:
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 0107             break;
	RJMP _0x40051
; 0002 0108         case ev_left:                   // printf ("Обрабатываем прокрутку valcoder влево\r\n");
_0x40052:
	CPI  R30,LOW(0x1)
	BREQ _0x40063
; 0002 0109         case ev_right:                  // printf ("Обрабатываем прокрутку valcoder вправо\r\n");
	CPI  R30,LOW(0x3)
	BRNE _0x40064
_0x40063:
; 0002 010A             // Запускаем таймер инактивности
; 0002 010B             //timer1_valcoder = TIMER_INACTIVE;
; 0002 010C             timer1_valcoder = TIMER_INACTIVE; // prim_par.T_z
	LDI  R30,LOW(60)
	STS  _timer1_valcoder,R30
; 0002 010D             valcoder = VALCODER_NO_ROTATE;
	LDI  R30,LOW(0)
	STS  _valcoder,R30
; 0002 010E             signal_buz(OFF);
	ST   -Y,R30
	CALL _signal_buz
; 0002 010F             // printf ("Обрабатываем прокрутку valcoder (%d), в режиме %d - ", event-2, mode.menu);
; 0002 0110             switch (mode.menu) {
	LDS  R30,_mode
; 0002 0111                 case 0:
	CPI  R30,0
	BRNE _0x40068
; 0002 0112                     sync_set_par(SYNC_TO_MENU);
	CALL SUBOPT_0x19
; 0002 0113                     lcd_menu(mode.menu++); break;   // Выводим меню без изменения позиции printf ("entering...");
	CALL SUBOPT_0x29
	RJMP _0x40067
; 0002 0114                 case 1: lcd_menu(event-2); break;       // printf ("navigating...");
_0x40068:
	CPI  R30,LOW(0x1)
	BRNE _0x40069
	LDS  R30,_event
	SUBI R30,LOW(2)
	ST   -Y,R30
	CALL _lcd_menu
	RJMP _0x40067
; 0002 0115                 case 2: lcd_edit(event-2); break;       // printf ("editing...");
_0x40069:
	CPI  R30,LOW(0x2)
	BRNE _0x4006B
	LDS  R30,_event
	SUBI R30,LOW(2)
	ST   -Y,R30
	CALL _lcd_edit
; 0002 0116                 default: ;                              // printf ("defaulting...");
_0x4006B:
; 0002 0117             }
_0x40067:
; 0002 0118             // printf ("\r\n");
; 0002 0119             event = ev_none;            // Очищаем событие
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 011A             break;
	RJMP _0x40051
; 0002 011B         case ev_enter:                  // Если нажат Enter
_0x40064:
	CPI  R30,LOW(0x2)
	BRNE _0x4006C
; 0002 011C             // LAMP_ECHO_PORT |= (1<<LAMP_ECHO_PIN); timer1_lamp = ENTER_CANCEL_OVERFLOW; if (mode.menu <= 2)
; 0002 011D             key_treated[2]=1;
	LDI  R30,LOW(1)
	__PUTB1MN _key_treated,2
; 0002 011E             event = ev_none;            // Очищаем событие
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 011F             signal_buz(SHORT);
	CALL SUBOPT_0x2A
; 0002 0120             timer1_valcoder = TIMER_INACTIVE;     // prim_par.T_z Запускаем таймер инактивности
	LDI  R30,LOW(60)
	STS  _timer1_valcoder,R30
; 0002 0121             switch (mode.menu) {
	LDS  R30,_mode
; 0002 0122                 // lcd_primary_screen();
; 0002 0123                 // Обрабатываем нажатие enter c учетом того, что значение mode.menu еще старое
; 0002 0124                 case 0:
	CPI  R30,0
	BRNE _0x40070
; 0002 0125                     sync_set_par(SYNC_TO_MENU);
	CALL SUBOPT_0x19
; 0002 0126                     lcd_menu(mode.menu++); break;           // Если находились в главном экране, запускаем прорисовку меню
	CALL SUBOPT_0x29
	RJMP _0x4006F
; 0002 0127                 case 1: lcd_init_edit(); break;             // Если находились в меню, то анализируем
_0x40070:
	CPI  R30,LOW(0x1)
	BRNE _0x40071
	CALL _lcd_init_edit
	RJMP _0x4006F
; 0002 0128                 case 2: lcd_save_edit(); mode.menu = 1; break;
_0x40071:
	CPI  R30,LOW(0x2)
	BRNE _0x4006F
	CALL _lcd_save_edit
	LDI  R30,LOW(1)
	STS  _mode,R30
; 0002 0129             };
_0x4006F:
; 0002 012A             break;
	RJMP _0x40051
; 0002 012B         case ev_timer:
_0x4006C:
	CPI  R30,LOW(0x6)
	BRNE _0x40073
; 0002 012C             // Запускаем таймер инактивности
; 0002 012D             if (mode.menu) timer1_valcoder = TIMER_INACTIVE; // prim_par.T_z.....TIMER_INACTIVE;
	LDS  R30,_mode
	CPI  R30,0
	BREQ _0x40074
	LDI  R30,LOW(60)
	STS  _timer1_valcoder,R30
; 0002 012E         case ev_cancel:
_0x40074:
	RJMP _0x40075
_0x40073:
	CPI  R30,LOW(0x4)
	BRNE _0x40076
_0x40075:
; 0002 012F             if (event == ev_cancel) {
	LDS  R26,_event
	CPI  R26,LOW(0x4)
	BRNE _0x40077
; 0002 0130                 signal_buz(SHORT);
	CALL SUBOPT_0x2A
; 0002 0131                 key_treated[3]=1;
	LDI  R30,LOW(1)
	__PUTB1MN _key_treated,3
; 0002 0132                 timer1_valcoder = TIMER_INACTIVE;     //prim_par.T_z  ....Запускаем таймер инактивности ()
	LDI  R30,LOW(60)
	STS  _timer1_valcoder,R30
; 0002 0133             }
; 0002 0134             event = ev_none;            // Очищаем событие
_0x40077:
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 0135             // print_prim_par((unsigned char *)&prim_par, sizeof(prim_par));
; 0002 0136             switch (mode.menu) {
	LDS  R30,_mode
; 0002 0137                 case 0: lcd_primary_screen(); break;
	CPI  R30,0
	BRNE _0x4007B
	RCALL _lcd_primary_screen
	RJMP _0x4007A
; 0002 0138                 case 1: --mode.menu; lcd_esc_edit(); break;
_0x4007B:
	CPI  R30,LOW(0x1)
	BRNE _0x4007C
	CALL SUBOPT_0x2B
	RJMP _0x4007A
; 0002 0139                 case 2: --mode.menu; lcd_esc_edit(); break;
_0x4007C:
	CPI  R30,LOW(0x2)
	BRNE _0x4007D
	CALL SUBOPT_0x2B
	RJMP _0x4007A
; 0002 013A                 case 3: mode.menu = 1; break;
_0x4007D:
	CPI  R30,LOW(0x3)
	BRNE _0x4007A
	LDI  R30,LOW(1)
	STS  _mode,R30
; 0002 013B             };
_0x4007A:
; 0002 013C              lcd_clrscr();
	CALL _lcd_clrscr
; 0002 013D             break;
	RJMP _0x40051
; 0002 013E         case ev_start:      // пуск установки
_0x40076:
	CPI  R30,LOW(0x7)
	BREQ PC+3
	JMP _0x4007F
; 0002 013F             key_treated[1]=1;
	LDI  R30,LOW(1)
	__PUTB1MN _key_treated,1
; 0002 0140             printf ("Нажата кнопка ПУСК. ");
	__POINTW1FN _0x40000,370
	CALL SUBOPT_0x1
; 0002 0141             switch (mode.run) {
	__GETB1MN _mode,1
; 0002 0142                 case 0: { // Процесс старта вентилятора
	CPI  R30,0
	BREQ PC+3
	JMP _0x40083
; 0002 0143                     if (prim_par.season) {
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x40084
; 0002 0144                         signal_white(ON);
	CALL SUBOPT_0x2C
; 0002 0145                         mode.pomp = 1;
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 0146                         mode.run = 1;                // Устанавливаем режим Прогрев
	__PUTB1MN _mode,1
; 0002 0147                         timer_start = prim_par.T_z; // TIMER_INACTIVE  ...Запускаем таймер STRT
	CALL SUBOPT_0x2D
	STS  _timer_start,R30
	STS  _timer_start+1,R31
; 0002 0148                         TAP_ANGLE = PWM_MAX;
	CALL SUBOPT_0x2E
; 0002 0149                         printf("Включен режим Прогрев. LIMIT = %d, Время прогрева = %d\r\n", mode.k_angle_limit,prim_par.T_z);
	__POINTW1FN _0x40000,391
	ST   -Y,R31
	ST   -Y,R30
	__GETW1MN _mode,7
	CALL SUBOPT_0x23
	CALL SUBOPT_0x2D
	CALL SUBOPT_0x23
	CALL SUBOPT_0x24
; 0002 014A                         signal_green(MEANDR);
	LDI  R30,LOW(4)
	ST   -Y,R30
	CALL _signal_green
; 0002 014B                     } else {
	RJMP _0x40085
_0x40084:
; 0002 014C                         signal_white(OFF);
	CALL SUBOPT_0xF
; 0002 014D                         mode.pomp = 0;
	LDI  R30,LOW(0)
	__PUTB1MN _mode,3
; 0002 014E                         mode.run = 3;
	LDI  R30,LOW(3)
	__PUTB1MN _mode,1
; 0002 014F                         mode.fan = 1;
	LDI  R30,LOW(1)
	__PUTB1MN _mode,4
; 0002 0150                         signal_green(ON);
	CALL SUBOPT_0x2
; 0002 0151                         printf("Включен режим Пуск\r\n");
	__POINTW1FN _0x40000,448
	CALL SUBOPT_0x1
; 0002 0152                         };
_0x40085:
; 0002 0153                     FAN_SPEED = prim_par.fan_speed;
	CALL SUBOPT_0x1A
; 0002 0154                     if (FAN_SPEED <= FAN_SPEED_MIN) FAN_SPEED = FAN_SPEED_MIN;
	CALL SUBOPT_0x2F
	BRGE _0x40086
	CALL SUBOPT_0x30
; 0002 0155                     count_fan = 0;
_0x40086:
	LDI  R30,LOW(0)
	STS  _count_fan,R30
; 0002 0156                     time_integration = 0;
	CALL SUBOPT_0x31
; 0002 0157                     signal_buz(LONG);
	CALL SUBOPT_0x32
; 0002 0158                     break;
	RJMP _0x40082
; 0002 0159                 } //mode.run=0 ;
; 0002 015A                 case 1: signal_buz(SHORT); signal_green(SHORT); printf("Режим Прогрев.\r\n"); break; //mode.run=1;
_0x40083:
	CPI  R30,LOW(0x1)
	BRNE _0x40087
	CALL SUBOPT_0x2A
	CALL SUBOPT_0x33
	__POINTW1FN _0x40000,469
	CALL SUBOPT_0x1
	RJMP _0x40082
; 0002 015B                 case 2: signal_buz(SHORT); signal_green(LONG); printf("Режим Остановки.\r\n"); break; //mode.run=2 ;
_0x40087:
	CPI  R30,LOW(0x2)
	BRNE _0x40088
	CALL SUBOPT_0x2A
	LDI  R30,LOW(3)
	ST   -Y,R30
	CALL _signal_green
	__POINTW1FN _0x40000,486
	CALL SUBOPT_0x1
	RJMP _0x40082
; 0002 015C                 case 3: signal_buz(SHORT); signal_green(ON); printf("Режим Пуск.\r\n");break; //mode.run=3
_0x40088:
	CPI  R30,LOW(0x3)
	BRNE _0x4008A
	CALL SUBOPT_0x2A
	CALL SUBOPT_0x2
	__POINTW1FN _0x40000,505
	CALL SUBOPT_0x1
; 0002 015D             default: break;
_0x4008A:
; 0002 015E             };
_0x40082:
; 0002 015F             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 0160             break;
	RJMP _0x40051
; 0002 0161         case ev_stop:
_0x4007F:
	CPI  R30,LOW(0x8)
	BREQ PC+3
	JMP _0x4008B
; 0002 0162             key_treated[0]=1;
	LDI  R30,LOW(1)
	STS  _key_treated,R30
; 0002 0163             printf ("Нажата кнопка СТОП. ");
	__POINTW1FN _0x40000,519
	CALL SUBOPT_0x1
; 0002 0164             switch (mode.run) {
	__GETB1MN _mode,1
; 0002 0165                 case 0: signal_buz(SHORT); time_integration = 0; signal_green(OFF); printf(" Режим СТОП.\r\n"); break; //mode.run=0 ;
	CPI  R30,0
	BRNE _0x4008F
	CALL SUBOPT_0x2A
	CALL SUBOPT_0x31
	CALL SUBOPT_0x4
	__POINTW1FN _0x40000,540
	CALL SUBOPT_0x1
	RJMP _0x4008E
; 0002 0166                 case 1: mode.run = 2;
_0x4008F:
	CPI  R30,LOW(0x1)
	BRNE _0x40090
	LDI  R30,LOW(2)
	__PUTB1MN _mode,1
; 0002 0167                         timer_start = 0;
	LDI  R30,LOW(0)
	STS  _timer_start,R30
	STS  _timer_start+1,R30
; 0002 0168                         signal_green(SHORT);  signal_buz(LONG);
	CALL SUBOPT_0x33
	CALL SUBOPT_0x32
; 0002 0169                         printf ("Включен режим Остановки\r\n");
	__POINTW1FN _0x40000,555
	CALL SUBOPT_0x1
; 0002 016A                         timer_stop = TIME_STOP;    // Запускаем таймер STOP
	LDI  R30,LOW(10)
	STS  _timer_stop,R30
; 0002 016B                         time_integration = 0; break; //mode.run=1;
	CALL SUBOPT_0x31
	RJMP _0x4008E
; 0002 016C                 case 2: signal_buz(SHORT); time_integration = 0; printf("Режим Остановки.\r\n"); break; //mode.run=2 ;
_0x40090:
	CPI  R30,LOW(0x2)
	BRNE _0x40091
	CALL SUBOPT_0x2A
	CALL SUBOPT_0x31
	__POINTW1FN _0x40000,486
	CALL SUBOPT_0x1
	RJMP _0x4008E
; 0002 016D                 case 3: mode.run = 2;
_0x40091:
	CPI  R30,LOW(0x3)
	BRNE _0x40093
	LDI  R30,LOW(2)
	__PUTB1MN _mode,1
; 0002 016E                         signal_green(LONG); signal_buz(LONG);
	LDI  R30,LOW(3)
	ST   -Y,R30
	CALL _signal_green
	CALL SUBOPT_0x32
; 0002 016F                         printf ("Включен режим Остановки\r\n");
	__POINTW1FN _0x40000,555
	CALL SUBOPT_0x1
; 0002 0170                         timer_stop = TIME_STOP;    // Запускаем таймер STOP
	LDI  R30,LOW(10)
	STS  _timer_stop,R30
; 0002 0171                         time_integration = 0; break; //mode.run=3
	CALL SUBOPT_0x31
; 0002 0172             default: break;
_0x40093:
; 0002 0173             };
_0x4008E:
; 0002 0174             mode.fan = 0;  // Выключение Вентилятора
	LDI  R30,LOW(0)
	__PUTB1MN _mode,4
; 0002 0175             event = ev_none;
	STS  _event,R30
; 0002 0176             break;
	RJMP _0x40051
; 0002 0177         case ev_alarm1:   // Пожар, перегрев вентилятора, авария частотника
_0x4008B:
	CPI  R30,LOW(0x9)
	BRNE _0x40094
; 0002 0178             signal_red(ON); signal_buz(MEANDR);
	CALL SUBOPT_0x34
; 0002 0179             mode.run = 0;
	CALL SUBOPT_0x3
; 0002 017A             mode.fan = 0;
; 0002 017B             if (prim_par.season) mode.pomp = 1; // Проверить
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x40095
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 017C             TAP_ANGLE = PWM_MAX;
_0x40095:
	CALL SUBOPT_0x2E
; 0002 017D             signal_white(SHORT);
	LDI  R30,LOW(2)
	ST   -Y,R30
	CALL _signal_white
; 0002 017E             signal_green(OFF);
	CALL SUBOPT_0x4
; 0002 017F             alarm_reg(0, 1, get_alert_str(0), 0);
	CALL SUBOPT_0x35
	LDI  R30,LOW(0)
	CALL SUBOPT_0x36
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _alarm_reg
; 0002 0180             printf ("Авария: %s\r\n", get_alert_str(0));
	__POINTW1FN _0x40000,581
	CALL SUBOPT_0x37
	CALL SUBOPT_0x38
; 0002 0181             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 0182             break;
	RJMP _0x40051
; 0002 0183         case ev_alarm2:   // Угроза замораживания от внешнего датчика
_0x40094:
	CPI  R30,LOW(0xA)
	BRNE _0x40096
; 0002 0184             signal_red(ON); signal_buz(MEANDR);
	CALL SUBOPT_0x34
; 0002 0185             signal_green(SHORT);
	CALL SUBOPT_0x33
; 0002 0186             mode.run = 0;
	CALL SUBOPT_0x3
; 0002 0187             mode.fan = 0;
; 0002 0188             mode.pomp = 1;
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 0189             TAP_ANGLE = PWM_MAX;
	CALL SUBOPT_0x2E
; 0002 018A             alarm_reg(0, 1, get_alert_str(1), 1);
	CALL SUBOPT_0x35
	LDI  R30,LOW(1)
	CALL SUBOPT_0x36
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL _alarm_reg
; 0002 018B             printf ("АВАРИЯ: %s\r\n", get_alert_str(1));
	CALL SUBOPT_0x39
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 018C             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 018D             break;
	RJMP _0x40051
; 0002 018E         case ev_freezing1:  // Температура на улице ниже критической UL_T   (Если не повторяется в течении часа восстановление)
_0x40096:
	CPI  R30,LOW(0xC)
	BRNE _0x40097
; 0002 018F             alarm_reg(0, 1, get_alert_str(2), 2);
	CALL SUBOPT_0x35
	LDI  R30,LOW(2)
	CALL SUBOPT_0x36
	LDI  R30,LOW(2)
	ST   -Y,R30
	CALL _alarm_reg
; 0002 0190             //signal_red(SHORT); signal_buz(MEANDR);
; 0002 0191             //signal_green(SHORT);
; 0002 0192             //mode.run = 0; // Режим оттаивания
; 0002 0193             //mode.fan = 0;
; 0002 0194             if (prim_par.season) mode.pomp = 1;
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x40098
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 0195             TAP_ANGLE = PWM_MAX;
_0x40098:
	CALL SUBOPT_0x2E
; 0002 0196             printf ("АВАРИЯ: %s\r\n", get_alert_str(2));
	CALL SUBOPT_0x39
	LDI  R30,LOW(2)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 0197             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 0198             break;
	RJMP _0x40051
; 0002 0199         case ev_freezing2: // Температура в помещения ниже критической POM_T
_0x40097:
	CPI  R30,LOW(0xD)
	BRNE _0x40099
; 0002 019A             alarm_reg(0, 1, get_alert_str(3), 3);
	CALL SUBOPT_0x35
	LDI  R30,LOW(3)
	CALL SUBOPT_0x36
	LDI  R30,LOW(3)
	CALL SUBOPT_0x3A
; 0002 019B             signal_red(ON); signal_buz(MEANDR);
; 0002 019C             signal_green(OFF);
	CALL SUBOPT_0x4
; 0002 019D             mode.run = 0;  // Режим оттаивания
	CALL SUBOPT_0x3
; 0002 019E             mode.fan = 0;
; 0002 019F             if (prim_par.season) mode.pomp = 1;
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x4009A
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 01A0             TAP_ANGLE = PWM_MAX;
_0x4009A:
	CALL SUBOPT_0x2E
; 0002 01A1             printf ("АВАРИЯ: %s\r\n", get_alert_str(3));
	CALL SUBOPT_0x39
	LDI  R30,LOW(3)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 01A2             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 01A3             break;
	RJMP _0x40051
; 0002 01A4         case ev_freezing3: // Температура воды обратки ниже критической POM_T
_0x40099:
	CPI  R30,LOW(0xE)
	BRNE _0x4009B
; 0002 01A5             alarm_reg(0, 1, get_alert_str(5), 5);
	CALL SUBOPT_0x35
	LDI  R30,LOW(5)
	CALL SUBOPT_0x36
	LDI  R30,LOW(5)
	CALL SUBOPT_0x3A
; 0002 01A6             signal_red(ON); signal_buz(MEANDR);
; 0002 01A7             signal_green(OFF);
	CALL SUBOPT_0x4
; 0002 01A8             mode.run = 0;  // Режим оттаивания
	CALL SUBOPT_0x3
; 0002 01A9             mode.fan = 0;
; 0002 01AA             if (prim_par.season) mode.pomp = 1;
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x4009C
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 01AB             TAP_ANGLE = PWM_MAX;
_0x4009C:
	CALL SUBOPT_0x2E
; 0002 01AC             printf ("АВАРИЯ: %s\r\n", get_alert_str(5));
	CALL SUBOPT_0x39
	LDI  R30,LOW(5)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 01AD             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 01AE             break;
	RJMP _0x40051
; 0002 01AF         case ev_term1_nf:   // Термометр В1 помещение
_0x4009B:
	CPI  R30,LOW(0xF)
	BRNE _0x4009D
; 0002 01B0             alarm_reg(MAX_OFFLINES, termometers[0].err, get_alert_str(7), 7);
	CALL SUBOPT_0x3B
	__GETB1MN _termometers,5
	CALL SUBOPT_0x3C
	LDI  R30,LOW(7)
	CALL SUBOPT_0x36
	LDI  R30,LOW(7)
	CALL SUBOPT_0x3A
; 0002 01B1             signal_red(ON); signal_buz(MEANDR);
; 0002 01B2             signal_green(OFF);
	CALL SUBOPT_0x4
; 0002 01B3             mode.run = 0;
	CALL SUBOPT_0x3
; 0002 01B4             mode.fan = 0;
; 0002 01B5             if (prim_par.season) mode.pomp = 1;
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x4009E
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 01B6             TAP_ANGLE = PWM_MAX;
_0x4009E:
	CALL SUBOPT_0x2E
; 0002 01B7             printf ("АВАРИЯ: %s\r\n", get_alert_str(7));
	CALL SUBOPT_0x39
	LDI  R30,LOW(7)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 01B8             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 01B9             break;
	RJMP _0x40051
; 0002 01BA         case ev_term2_nf:  // Термометр В2 Улица
_0x4009D:
	CPI  R30,LOW(0x10)
	BRNE _0x4009F
; 0002 01BB             alarm_reg(MAX_OFFLINES, termometers[1].err, get_alert_str(8), 8);
	CALL SUBOPT_0x3B
	__GETB1MN _termometers,11
	CALL SUBOPT_0x3C
	LDI  R30,LOW(8)
	CALL SUBOPT_0x36
	LDI  R30,LOW(8)
	CALL SUBOPT_0x3D
; 0002 01BC             signal_red(LONG); signal_buz(MEANDR);
; 0002 01BD             signal_green(OFF);
; 0002 01BE             mode.run = 0;
	CALL SUBOPT_0x3
; 0002 01BF             mode.fan = 0;
; 0002 01C0             if (prim_par.season) mode.pomp = 1;
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x400A0
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 01C1             TAP_ANGLE = PWM_MAX;
_0x400A0:
	CALL SUBOPT_0x2E
; 0002 01C2             printf ("АВАРИЯ: %s\r\n", get_alert_str(8));
	CALL SUBOPT_0x39
	LDI  R30,LOW(8)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 01C3             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 01C4             break;
	RJMP _0x40051
; 0002 01C5         case ev_term3_nf:  // Термометр В3 Подача
_0x4009F:
	CPI  R30,LOW(0x11)
	BRNE _0x400A1
; 0002 01C6             // Нет его, ну и хрен с ним
; 0002 01C7             alarm_reg(MAX_OFFLINES, termometers[2].err, get_alert_str(9), 9);
	CALL SUBOPT_0x3B
	__GETB1MN _termometers,17
	CALL SUBOPT_0x3C
	LDI  R30,LOW(9)
	CALL SUBOPT_0x36
	LDI  R30,LOW(9)
	ST   -Y,R30
	CALL _alarm_reg
; 0002 01C8             printf ("ПРЕДУПРЕЖДЕНИЕ: %s\r\n", get_alert_str(9));
	__POINTW1FN _0x40000,607
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(9)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 01C9             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 01CA             break;
	RJMP _0x40051
; 0002 01CB         case ev_term4_nf:  // Термометр В4 Обратка
_0x400A1:
	CPI  R30,LOW(0x12)
	BRNE _0x400A2
; 0002 01CC             alarm_reg(MAX_OFFLINES, termometers[3].err, get_alert_str(10), 10);
	CALL SUBOPT_0x3B
	__GETB1MN _termometers,23
	CALL SUBOPT_0x3C
	LDI  R30,LOW(10)
	CALL SUBOPT_0x36
	LDI  R30,LOW(10)
	CALL SUBOPT_0x3D
; 0002 01CD             signal_red(LONG); signal_buz(MEANDR);
; 0002 01CE             signal_green(OFF);
; 0002 01CF             mode.run = 0;
	CALL SUBOPT_0x3
; 0002 01D0             mode.fan = 0;
; 0002 01D1             if (prim_par.season) mode.pomp = 1;
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x400A3
	LDI  R30,LOW(1)
	__PUTB1MN _mode,3
; 0002 01D2             TAP_ANGLE = PWM_MAX;
_0x400A3:
	CALL SUBOPT_0x2E
; 0002 01D3             printf ("АВАРИЯ: %s\r\n", get_alert_str(10));
	CALL SUBOPT_0x39
	LDI  R30,LOW(10)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 01D4             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 01D5             break;
	RJMP _0x40051
; 0002 01D6         case ev_filter:  // Загрязнение фильтра.
_0x400A2:
	CPI  R30,LOW(0xB)
	BRNE _0x400A5
; 0002 01D7             alarm_reg(0, 1, get_alert_str(11), 11);
	CALL SUBOPT_0x35
	LDI  R30,LOW(11)
	CALL SUBOPT_0x36
	LDI  R30,LOW(11)
	ST   -Y,R30
	CALL _alarm_reg
; 0002 01D8             event = ev_none;
	LDI  R30,LOW(0)
	STS  _event,R30
; 0002 01D9             printf ("АВАРИЯ: %s\r\n", get_alert_str(11));
	CALL SUBOPT_0x39
	LDI  R30,LOW(11)
	ST   -Y,R30
	CALL SUBOPT_0x38
; 0002 01DA             signal_red(SHORT);
	LDI  R30,LOW(2)
	ST   -Y,R30
	CALL _signal_red
; 0002 01DB             break;
; 0002 01DC         default:
_0x400A5:
; 0002 01DD             break;
; 0002 01DE     };
_0x40051:
; 0002 01DF }
	RET
;// Обработка режима работы системы
;void mode_processing(void) {
; 0002 01E1 void mode_processing(void) {
_mode_processing:
; 0002 01E2     // В ЭТОЙ ФУНКЦИИ ЗАПРЕЩЕНО ИЗМЕНЕНИЕ РЕЖИМОВ И ГЕНЕРАЦИЯ СОБЫТИЙ. ТОЛЬКО ПОДДЕРЖКА!
; 0002 01E3     int water_out_bound;
; 0002 01E4     int water_out_bound_1;
; 0002 01E5     static int error_w_stop = 0;
; 0002 01E6     POM_T = termometers[0].t;
	CALL __SAVELOCR4
;	water_out_bound -> R16,R17
;	water_out_bound_1 -> R18,R19
	LDS  R30,_termometers
	LDS  R31,_termometers+1
	__PUTW1MN _parameters,5
; 0002 01E7     UL_T = termometers[1].t;
	__GETW1MN _termometers,6
	__PUTW1MN _parameters,10
; 0002 01E8     SET_T = prim_par.TA_out_prs;
	CALL SUBOPT_0x3E
; 0002 01E9     WIN_T = termometers[2].t;
	__GETW1MN _termometers,12
	__PUTW1MN _parameters,15
; 0002 01EA     WOUT_T = termometers[3].t;
	__GETW1MN _termometers,18
	__PUTW1MN _parameters,20
; 0002 01EB     OCR0 = (unsigned char)TAP_ANGLE;
	__GETB1MN _parameters,30
	OUT  0x3C,R30
; 0002 01EC     OCR2 = (unsigned char)FAN_SPEED;
	__GETB1MN _parameters,40
	OUT  0x23,R30
; 0002 01ED 
; 0002 01EE     // WHITE = prim_par.season;
; 0002 01EF     MOTOR = mode.fan;
	__GETB1MN _mode,4
	CPI  R30,0
	BRNE _0x400A6
	CBI  0x12,4
	RJMP _0x400A7
_0x400A6:
	SBI  0x12,4
_0x400A7:
; 0002 01F0     POMP = mode.pomp;
	__GETB1MN _mode,3
	CPI  R30,0
	BRNE _0x400A8
	CBI  0x12,5
	RJMP _0x400A9
_0x400A8:
	SBI  0x12,5
_0x400A9:
; 0002 01F1     FAN_VAR = mode.fan;
	__POINTW2MN _parameters,45
	__GETB1MN _mode,4
	CALL SUBOPT_0x3F
; 0002 01F2     POMP_VAR = mode.pomp;
	CALL SUBOPT_0x40
; 0002 01F3     switch (mode.run) {
	__GETB1MN _mode,1
; 0002 01F4         case 0:
	CPI  R30,0
	BREQ PC+3
	JMP _0x400AD
; 0002 01F5             time_integration = 0;
	CALL SUBOPT_0x31
; 0002 01F6             if (prim_par.season) {
	__GETB1MN _prim_par,48
	CPI  R30,0
	BRNE PC+3
	JMP _0x400AE
; 0002 01F7             // Вычисление ограничения закрытия крана TAP_ANGLE = tap_angle_min
; 0002 01F8                 if (prim_par.season && (UL_T < TA_IN_NOLIMIT)) {
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x400B0
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1E
	BRLT _0x400B1
_0x400B0:
	RJMP _0x400AF
_0x400B1:
; 0002 01F9                     //int tmp_delta = abs(prim_par.TA_in_Min) + TA_IN_NOLIMIT;
; 0002 01FA                     //mode.k_angle_limit = (TAP_ANGLE_LIMIT / tmp_delta) * 1000;
; 0002 01FB                     tap_angle_min = ((long int)((TA_IN_NOLIMIT - UL_T) * mode.k_angle_limit))/1000;   // вычисление ограничения крана по температуре воздуха на входе и коэффициенту mode.k_angle_limit
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1F
; 0002 01FC                     if (tap_angle_min < 100) tap_angle_min = 100 ;
	LDI  R30,LOW(100)
	CP   R6,R30
	BRSH _0x400B2
	MOV  R6,R30
; 0002 01FD                 }
_0x400B2:
; 0002 01FE                 // Процесс поддержания температуры калорифера в режиме СТОП Зимой
; 0002 01FF                 error_w_stop = (prim_par.TW_out_Stop - WOUT_T)/100;
_0x400AF:
	__GETW2MN _prim_par,28
	__GETW1MN _parameters,20
	SUB  R26,R30
	SBC  R27,R31
	CALL SUBOPT_0x41
	STS  _error_w_stop_S0020003,R30
	STS  _error_w_stop_S0020003+1,R31
; 0002 0200                 water_out_bound = prim_par.TW_out_Stop - 200;
	CALL SUBOPT_0x42
	SUBI R30,LOW(200)
	SBCI R31,HIGH(200)
	MOVW R16,R30
; 0002 0201                 water_out_bound_1 = prim_par.TW_out_Stop - 500;
	CALL SUBOPT_0x42
	SUBI R30,LOW(500)
	SBCI R31,HIGH(500)
	CALL SUBOPT_0x43
; 0002 0202                 // Разогрев калорифера
; 0002 0203                 if ((WOUT_T <= water_out_bound) && (timer_fan == 0)) {
	BRLT _0x400B4
	LDS  R26,_timer_fan
	CPI  R26,LOW(0x0)
	BREQ _0x400B5
_0x400B4:
	RJMP _0x400B3
_0x400B5:
; 0002 0204                     timer_fan = TIME_COOL_STOP;
	LDI  R30,LOW(20)
	STS  _timer_fan,R30
; 0002 0205                     // forcheck_event = ev_pomp;
; 0002 0206                     TAP_ANGLE = TAP_ANGLE + error_w_stop;
	CALL SUBOPT_0x22
	CALL SUBOPT_0x44
; 0002 0207                     if (TAP_ANGLE < tap_angle_min) TAP_ANGLE = tap_angle_min ;   // TAP_ANGLE - Состояние выхода на PWM
	CALL SUBOPT_0x20
	BRGE _0x400B6
	CALL SUBOPT_0x45
; 0002 0208                     if (TAP_ANGLE > PWM_MAX) TAP_ANGLE = PWM_MAX;         // TAP_ANGLE - Состояние выхода на PWM
_0x400B6:
	CALL SUBOPT_0x46
	BRLT _0x400B7
	CALL SUBOPT_0x2E
; 0002 0209                     if (WOUT_T < water_out_bound_1) {
_0x400B7:
	CALL SUBOPT_0x47
	CP   R26,R18
	CPC  R27,R19
	BRGE _0x400B8
; 0002 020A                         //if (!mode.print) printf("Разогрев калорифера: %d, Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
; 0002 020B                         // if (mode.print) printf("Разогрев калорифера: %d, Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
; 0002 020C                         signal_white(LONG);
	LDI  R30,LOW(3)
	ST   -Y,R30
	CALL _signal_white
; 0002 020D                         mode.pomp = 1;
	LDI  R30,LOW(1)
	RJMP _0x40163
; 0002 020E                     } else {
_0x400B8:
; 0002 020F                         signal_white(ON);
	CALL SUBOPT_0x2C
; 0002 0210                         mode.pomp = 0;
	LDI  R30,LOW(0)
_0x40163:
	__PUTB1MN _mode,3
; 0002 0211                     }
; 0002 0212                     if (mode.print) printf("Разогрев калорифера: %d, Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x400BA
	__POINTW1FN _0x40000,628
	CALL SUBOPT_0x48
	CALL SUBOPT_0x22
	CALL SUBOPT_0x23
	CALL SUBOPT_0x49
	MOV  R30,R6
	CALL SUBOPT_0x28
	CALL SUBOPT_0x47
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
; 0002 0213                 }
_0x400BA:
; 0002 0214                 // Охлаждение калорифера
; 0002 0215                 water_out_bound = prim_par.TW_out_Stop + 250;
_0x400B3:
	CALL SUBOPT_0x42
	SUBI R30,LOW(-250)
	SBCI R31,HIGH(-250)
	MOVW R16,R30
; 0002 0216                 water_out_bound_1 = prim_par.TW_out_Stop + 500;
	CALL SUBOPT_0x42
	SUBI R30,LOW(-500)
	SBCI R31,HIGH(-500)
	CALL SUBOPT_0x43
; 0002 0217                 if ((WOUT_T > water_out_bound) && (timer_fan == 0)) {
	BRGE _0x400BC
	LDS  R26,_timer_fan
	CPI  R26,LOW(0x0)
	BREQ _0x400BD
_0x400BC:
	RJMP _0x400BB
_0x400BD:
; 0002 0218                     timer_fan = TIME_COOL_STOP;
	LDI  R30,LOW(20)
	STS  _timer_fan,R30
; 0002 0219                     // printf("Угол крана расчетный :%d  \r\n",   TAP_ANGLE);
; 0002 021A                     if (TAP_ANGLE < tap_angle_min) TAP_ANGLE = tap_angle_min;         // TAP_ANGLE - Состояние выхода на PWM
	CALL SUBOPT_0x20
	BRGE _0x400BE
	CALL SUBOPT_0x45
; 0002 021B                     if (TAP_ANGLE > PWM_MAX) TAP_ANGLE = PWM_MAX;         // TAP_ANGLE - Состояние выхода на PWM
_0x400BE:
	CALL SUBOPT_0x46
	BRLT _0x400BF
	CALL SUBOPT_0x2E
; 0002 021C                     if ((WOUT_T >= water_out_bound) && (mode.pomp == 1)) {
_0x400BF:
	CALL SUBOPT_0x47
	CP   R26,R16
	CPC  R27,R17
	BRLT _0x400C1
	__GETB2MN _mode,3
	CPI  R26,LOW(0x1)
	BREQ _0x400C2
_0x400C1:
	RJMP _0x400C0
_0x400C2:
; 0002 021D                         //if (!mode.print) printf("Охлаждение калорифера: %d, Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
; 0002 021E                         //if (mode.print) printf("Охлаждение калорифера: %d, Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
; 0002 021F                         signal_white(ON);
	CALL SUBOPT_0x2C
; 0002 0220                         mode.pomp = 0;
	LDI  R30,LOW(0)
	__PUTB1MN _mode,3
; 0002 0221                     };
_0x400C0:
; 0002 0222                     if (WOUT_T >= water_out_bound_1)  TAP_ANGLE = TAP_ANGLE + error_w_stop;
	CALL SUBOPT_0x47
	CP   R26,R18
	CPC  R27,R19
	BRLT _0x400C3
	CALL SUBOPT_0x22
	CALL SUBOPT_0x44
; 0002 0223                     if (mode.print) printf("Охлаждение калорифера: %d, Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
_0x400C3:
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x400C4
	__POINTW1FN _0x40000,746
	CALL SUBOPT_0x48
	CALL SUBOPT_0x22
	CALL SUBOPT_0x23
	CALL SUBOPT_0x49
	MOV  R30,R6
	CALL SUBOPT_0x28
	CALL SUBOPT_0x47
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
; 0002 0224                 }
_0x400C4:
; 0002 0225                 // Поддержание калорифера
; 0002 0226                 if (timer_fan == 0) {
_0x400BB:
	LDS  R30,_timer_fan
	CPI  R30,0
	BRNE _0x400C5
; 0002 0227                     timer_fan = TIME_COOL_STOP;
	LDI  R30,LOW(20)
	STS  _timer_fan,R30
; 0002 0228                     if (WIN_T >= prim_par.TW_out_Stop)  mode.pomp = 0;
	__GETW2MN _parameters,15
	CALL SUBOPT_0x42
	CP   R26,R30
	CPC  R27,R31
	BRLT _0x400C6
	LDI  R30,LOW(0)
	__PUTB1MN _mode,3
; 0002 0229                     //if (!mode.print) printf("Поддержание калорифера: %d,  Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
; 0002 022A                     if (mode.print) printf("Поддержание калорифера: %d,  Угол крана расчетный :%d, Угол крана измеренный :%d, угол ограничения: %d, t обратки :%d  \r\n",  error_w_stop, TAP_ANGLE, ADC_VAR1, tap_angle_min, WOUT_T/10);
_0x400C6:
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x400C7
	__POINTW1FN _0x40000,866
	CALL SUBOPT_0x48
	CALL SUBOPT_0x22
	CALL SUBOPT_0x23
	CALL SUBOPT_0x49
	MOV  R30,R6
	CALL SUBOPT_0x28
	CALL SUBOPT_0x47
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x4B
; 0002 022B                 }
_0x400C7:
; 0002 022C             } else {
_0x400C5:
	RJMP _0x400C8
_0x400AE:
; 0002 022D                 signal_white(OFF);
	CALL SUBOPT_0xF
; 0002 022E                 mode.pomp = 0;
	LDI  R30,LOW(0)
	__PUTB1MN _mode,3
; 0002 022F 
; 0002 0230             }
_0x400C8:
; 0002 0231             signal_green(OFF);
	CALL SUBOPT_0x4
; 0002 0232             break;
	RJMP _0x400AC
; 0002 0233         //case 1:
; 0002 0234         //         if (!mode.print) printf("-");
; 0002 0235         //    break;
; 0002 0236         case 3:
_0x400AD:
	CPI  R30,LOW(0x3)
	BREQ PC+3
	JMP _0x400E0
; 0002 0237             //if (IS_ALERT == 0) {
; 0002 0238                 if (prim_par.season)
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x400CA
; 0002 0239                     signal_white(ON);
	CALL SUBOPT_0x2C
; 0002 023A                 else {
	RJMP _0x400CB
_0x400CA:
; 0002 023B                     signal_white(OFF);
	CALL SUBOPT_0xF
; 0002 023C                     FAN_SPEED = prim_par.fan_speed;
	CALL SUBOPT_0x1A
; 0002 023D                 }
_0x400CB:
; 0002 023E                 //  Простой алгоритм обработки
; 0002 023F                 if (1 == 0) {
; 0002 0240                     update_P(SET_T - POM_T); // Разница между T Уст и Т помещения
; 0002 0241                     time_integration = prim_par.T_int;
; 0002 0242                 }
; 0002 0243                 if (time_integration == 0) {
	CALL SUBOPT_0x5
	SBIW R30,0
	BREQ PC+3
	JMP _0x400CD
; 0002 0244                     update_PID(SET_T - POM_T, -5000, 5000); // Разница между T Уст и Т помещения
	CALL SUBOPT_0x4C
	LDS  R26,_parameters
	LDS  R27,_parameters+1
	SUB  R26,R30
	SBC  R27,R31
	ST   -Y,R27
	ST   -Y,R26
	LDI  R30,LOW(60536)
	LDI  R31,HIGH(60536)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(5000)
	LDI  R31,HIGH(5000)
	ST   -Y,R31
	ST   -Y,R30
	RCALL _update_PID
; 0002 0245                     time_integration = prim_par.T_int;
	__GETW1MN _prim_par,24
	STS  _time_integration,R30
	STS  _time_integration+1,R31
; 0002 0246                     if (prim_par.season && (UL_T < TA_IN_NOLIMIT)) {
	__GETB1MN _prim_par,48
	CPI  R30,0
	BREQ _0x400CF
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1E
	BRLT _0x400D0
_0x400CF:
	RJMP _0x400CE
_0x400D0:
; 0002 0247                         // Вычисление ограничения закрытия крана TAP_ANGLE = tap_angle_min
; 0002 0248                         //tap_angle_min = ((long int)((TA_IN_NOLIMIT - UL_T) * mode.k_angle_limit))/1000;
; 0002 0249                         //printf("Пересчет ограничения: %d, Ул. т :%d, Коэффициент :%d \r\n",  (TA_IN_NOLIMIT - UL_T), UL_T, mode.k_angle_limit);
; 0002 024A                         // Вычисление скорсти вентилятора
; 0002 024B                         //#define FAN_SPEED_T_UP 300
; 0002 024C                         //#define FAN_SPEED_T_DOWN 100
; 0002 024D                         if ((TAP_ANGLE == PWM_MAX) && ((POM_T - FAN_SPEED_T_DOWN) < SET_T)) {
	CALL SUBOPT_0x22
	CPI  R30,LOW(0xFF)
	LDI  R26,HIGH(0xFF)
	CPC  R31,R26
	BRNE _0x400D2
	CALL SUBOPT_0x4C
	SUBI R30,LOW(200)
	SBCI R31,HIGH(200)
	MOVW R26,R30
	CALL SUBOPT_0x4D
	CP   R26,R30
	CPC  R27,R31
	BRLT _0x400D3
_0x400D2:
	RJMP _0x400D1
_0x400D3:
; 0002 024E                             count_fan++;
	CALL SUBOPT_0x4E
; 0002 024F                             if (count_fan == COUNT_FAN_MAX) {
	BRNE _0x400D4
; 0002 0250                                FAN_SPEED = FAN_SPEED - FAN_SPEED_STEP;
	CALL SUBOPT_0x4F
	SBIW R30,10
	CALL SUBOPT_0x50
; 0002 0251                                count_fan = 0;
; 0002 0252                                if  (FAN_SPEED <= FAN_SPEED_MIN) FAN_SPEED = FAN_SPEED_MIN;
	CALL SUBOPT_0x2F
	BRGE _0x400D5
	CALL SUBOPT_0x30
; 0002 0253                             //if (!mode.print) printf("Понижение скорости вентилятора расчетное : %d, измеренное : %d, Счетчик циклов :%d, POM_T :%d \r\n",  FAN_SPEED, ADC_VAR2, count_fan, POM_T);
; 0002 0254                             if (mode.print) printf("Понижение скорости вентилятора расчетное : %d, измеренное : %d, Счетчик циклов :%d, POM_T :%d \r\n",  FAN_SPEED, ADC_VAR2, count_fan, POM_T);
_0x400D5:
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x400D6
	__POINTW1FN _0x40000,988
	CALL SUBOPT_0x21
	CALL SUBOPT_0x51
	LDS  R30,_count_fan
	CALL SUBOPT_0x28
	CALL SUBOPT_0x4C
	CALL SUBOPT_0x23
	CALL SUBOPT_0x52
; 0002 0255                             }
_0x400D6:
; 0002 0256                         } else  {// count_fan = 0;
_0x400D4:
	RJMP _0x400D7
_0x400D1:
; 0002 0257                             if ((FAN_SPEED < prim_par.fan_speed) && ((POM_T + FAN_SPEED_T_UP) > SET_T)) {   //&& (TAP_ANGLE == tap_angle_min
	CALL SUBOPT_0x53
	CP   R26,R30
	CPC  R27,R31
	BRGE _0x400D9
	__GETW2MN _parameters,5
	SUBI R26,LOW(-300)
	SBCI R27,HIGH(-300)
	CALL SUBOPT_0x4D
	CP   R30,R26
	CPC  R31,R27
	BRLT _0x400DA
_0x400D9:
	RJMP _0x400D8
_0x400DA:
; 0002 0258                                 count_fan++;
	CALL SUBOPT_0x4E
; 0002 0259                                 if (count_fan == COUNT_FAN_MAX) {
	BRNE _0x400DB
; 0002 025A                                    FAN_SPEED = FAN_SPEED + FAN_SPEED_STEP;
	CALL SUBOPT_0x4F
	ADIW R30,10
	CALL SUBOPT_0x50
; 0002 025B                                    count_fan = 0;
; 0002 025C                                    //if  (prim_par.fan_speed <= FAN_SPEED) FAN_SPEED = prim_par.fan_speed;
; 0002 025D                                    if  (FAN_SPEED > prim_par.fan_speed ) FAN_SPEED = prim_par.fan_speed;
	CALL SUBOPT_0x53
	CP   R30,R26
	CPC  R31,R27
	BRGE _0x400DC
	CALL SUBOPT_0x1A
; 0002 025E                                    //if (!mode.print) printf("Увеличение скорости вентилятора расчетная: %d, измеренная : %d, Счетчик циклов :%d, Заданная скорость :%d \r\n",  FAN_SPEED, ADC_VAR2, count_fan, prim_par.fan_speed);
; 0002 025F                                    if (mode.print) printf("Увеличение скорости вентилятора расчетная: %d, измеренная : %d, Счетчик циклов :%d, Заданная скорость :%d \r\n",  FAN_SPEED, ADC_VAR2, count_fan, prim_par.fan_speed);
_0x400DC:
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x400DD
	__POINTW1FN _0x40000,1085
	CALL SUBOPT_0x21
	CALL SUBOPT_0x51
	LDS  R30,_count_fan
	CALL SUBOPT_0x28
	__GETB1MN _prim_par,13
	CALL SUBOPT_0x28
	CALL SUBOPT_0x52
; 0002 0260                                 }
_0x400DD:
; 0002 0261 
; 0002 0262                             } else count_fan = 0;
_0x400DB:
	RJMP _0x400DE
_0x400D8:
	LDI  R30,LOW(0)
	STS  _count_fan,R30
; 0002 0263                         }
_0x400DE:
_0x400D7:
; 0002 0264                         //if (!mode.print) printf("Скорость вентилятора расчетная: %d, измеренная : %d, Заданная скорость: %d, POM_T: %d, TAP_ANGLE_MIN = %d \r\n",  FAN_SPEED, ADC_VAR2, prim_par.fan_speed, POM_T, tap_angle_min);
; 0002 0265                         if (mode.print) printf("Скорость вентилятора расчетная: %d, измеренная : %d, Заданная скорость: %d, POM_T: %d, TAP_ANGLE_MIN = %d \r\n",  FAN_SPEED, ADC_VAR2, prim_par.fan_speed, POM_T, tap_angle_min);
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x400DF
	__POINTW1FN _0x40000,1194
	CALL SUBOPT_0x21
	CALL SUBOPT_0x51
	__GETB1MN _prim_par,13
	CALL SUBOPT_0x28
	CALL SUBOPT_0x4C
	CALL SUBOPT_0x23
	MOV  R30,R6
	CALL SUBOPT_0x28
	CALL SUBOPT_0x4B
; 0002 0266                     }
_0x400DF:
; 0002 0267                 }
_0x400CE:
; 0002 0268                 signal_green(ON);
_0x400CD:
	CALL SUBOPT_0x2
; 0002 0269             // }
; 0002 026A             break;
; 0002 026B         default:
_0x400E0:
; 0002 026C             break;
; 0002 026D     };
_0x400AC:
; 0002 026E 
; 0002 026F }
	CALL __LOADLOCR4
	ADIW R28,4
	RET
;void check_range(void) {
; 0002 0270 void check_range(void) {
_check_range:
; 0002 0271     // Проверяем на принадлежность диапазону
; 0002 0272     // Вычисление ограничения закрытия крана TAP_ANGLE = tap_angle_min
; 0002 0273     if (UL_T < TA_IN_NOLIMIT)  tap_angle_min = ((long int)((TA_IN_NOLIMIT - UL_T) * mode.k_angle_limit))/1000;
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1E
	BRGE _0x400E1
	CALL SUBOPT_0x1D
	CALL SUBOPT_0x1F
; 0002 0274     //printf("Пересчет ограничения: %d, Ул. т :%d, Коэффициент :%d \r\n",  (TA_IN_NOLIMIT - UL_T), UL_T, mode.k_angle_limit);
; 0002 0275     if (TAP_ANGLE < tap_angle_min)
_0x400E1:
	CALL SUBOPT_0x20
	BRGE _0x400E2
; 0002 0276         TAP_ANGLE = tap_angle_min;
	CALL SUBOPT_0x45
; 0002 0277     else
	RJMP _0x400E3
_0x400E2:
; 0002 0278         if (TAP_ANGLE > PWM_MAX)
	CALL SUBOPT_0x46
	BRLT _0x400E4
; 0002 0279             TAP_ANGLE = PWM_MAX;
	CALL SUBOPT_0x2E
; 0002 027A     // TAP_ANGLE - Состояние выхода на PWM
; 0002 027B }
_0x400E4:
_0x400E3:
	RET
;// Функция пропорционального регулирования
;void update_P(int error) {
; 0002 027D void update_P(int error) {
_update_P:
; 0002 027E     // TAP_ANGLE = TAP_ANGLE + error/100;          // TAP_ANGLE - Состояние выхода на PWM
; 0002 027F     if ((TAP_ANGLE >=0) && (TAP_ANGLE <= PWM_MAX))
;	error -> Y+0
	__GETB2MN _parameters,31
	TST  R26
	BRMI _0x400E6
	CALL SUBOPT_0x46
	BRLT _0x400E7
_0x400E6:
	RJMP _0x400E5
_0x400E7:
; 0002 0280         TAP_ANGLE = TAP_ANGLE + (error / 100) * prim_par.Ku;
	__GETWRMN 22,23,_parameters,30
	LD   R26,Y
	LDD  R27,Y+1
	CALL SUBOPT_0x41
	MOVW R26,R30
	CALL SUBOPT_0x54
	CALL __MULW12
	ADD  R30,R22
	ADC  R31,R23
	__PUTW1MN _parameters,30
; 0002 0281     check_range();
_0x400E5:
	RCALL _check_range
; 0002 0282     printf("Разность температур: %d, TAP_ANGLE :%d, time_integration :%d \r\n",  error, ((TAP_ANGLE*100)/0xFF),time_integration);
	__POINTW1FN _0x40000,1303
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	CALL SUBOPT_0x23
	CALL SUBOPT_0x22
	LDI  R26,LOW(100)
	LDI  R27,HIGH(100)
	CALL SUBOPT_0x55
	CALL SUBOPT_0x27
	CALL SUBOPT_0x12
; 0002 0283 }
	ADIW R28,2
	RET
;void update_PID(int error, int iMin, int iMax) {
; 0002 0284 void update_PID(int error, int iMin, int iMax) {
_update_PID:
; 0002 0285     static int dState = 0, iState = 0;
; 0002 0286     int pTerm, dTerm, iTerm;
; 0002 0287     int result;
; 0002 0288 
; 0002 0289     pTerm = (prim_par.Ku * error) / 10;    // calculate the proportional term
	SBIW R28,2
	CALL __SAVELOCR6
;	error -> Y+12
;	iMin -> Y+10
;	iMax -> Y+8
;	pTerm -> R16,R17
;	dTerm -> R18,R19
;	iTerm -> R20,R21
;	result -> Y+6
	CALL SUBOPT_0x54
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	CALL __MULW12
	MOVW R26,R30
	LDI  R30,LOW(10)
	LDI  R31,HIGH(10)
	CALL __DIVW21
	MOVW R16,R30
; 0002 028A     iState += error;                // calculate the integral state with appropriate limiting
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	CALL SUBOPT_0x56
	ADD  R30,R26
	ADC  R31,R27
	STS  _iState_S0020006,R30
	STS  _iState_S0020006+1,R31
; 0002 028B     // Проверяем на принадлежность диапазону
; 0002 028C     if (FAN_SPEED >= prim_par.fan_speed) {
	CALL SUBOPT_0x53
	CP   R26,R30
	CPC  R27,R31
	BRGE PC+3
	JMP _0x400E8
; 0002 028D         if ((iState > iMax) || (iState < iMin)) {
	CALL SUBOPT_0x57
	BRLT _0x400EA
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL SUBOPT_0x56
	CP   R26,R30
	CPC  R27,R31
	BRGE _0x400E9
_0x400EA:
; 0002 028E             if (iState > iMax)
	CALL SUBOPT_0x57
	BRGE _0x400EC
; 0002 028F                 iState = iMax;
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	RJMP _0x40164
; 0002 0290             else
_0x400EC:
; 0002 0291                 iState = iMin;
	LDD  R30,Y+10
	LDD  R31,Y+10+1
_0x40164:
	STS  _iState_S0020006,R30
	STS  _iState_S0020006+1,R31
; 0002 0292         }
; 0002 0293         iTerm = (prim_par.Ki * iState) / 100;    // calculate the integral term
_0x400E9:
	__GETW1MN _prim_par,18
	CALL SUBOPT_0x56
	CALL __MULW12
	MOVW R26,R30
	CALL SUBOPT_0x41
	MOVW R20,R30
; 0002 0294         dTerm = prim_par.Kd * (POM_T - dState);
	__GETWRMN 0,1,_prim_par,20
	CALL SUBOPT_0x4C
	LDS  R26,_dState_S0020006
	LDS  R27,_dState_S0020006+1
	SUB  R30,R26
	SBC  R31,R27
	MOVW R26,R0
	CALL __MULW12
	MOVW R18,R30
; 0002 0295         dState = POM_T;
	CALL SUBOPT_0x4C
	STS  _dState_S0020006,R30
	STS  _dState_S0020006+1,R31
; 0002 0296         result = pTerm + iTerm - dTerm;
	MOVW R30,R20
	ADD  R30,R16
	ADC  R31,R17
	SUB  R30,R18
	SBC  R31,R19
	STD  Y+6,R30
	STD  Y+6+1,R31
; 0002 0297         TAP_ANGLE += result / 100;
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL SUBOPT_0x41
	__GETW2MN _parameters,30
	ADD  R30,R26
	ADC  R31,R27
	__PUTW1MN _parameters,30
; 0002 0298         check_range();
	RCALL _check_range
; 0002 0299     }
; 0002 029A     if (!mode.print)
_0x400E8:
	__GETB1MN _mode,18
	CPI  R30,0
	BRNE _0x400EE
; 0002 029B     // Температура заданная, Температура измеренная, Delta, Угол крана расчетный, Угол кранаизмеренный, Угол ограничения, result, pTerm, iTerm, dTerm, Обороты расчетные,Обороты измеренныее\r\n"
; 0002 029C         printf("%02u:%02u:%02u, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\r\n",
; 0002 029D             s_dt.cHH, s_dt.cMM, s_dt.cSS,
; 0002 029E             SET_T, POM_T, error,
; 0002 029F             TAP_ANGLE, ADC_VAR1, tap_angle_min, result,
; 0002 02A0             pTerm, iTerm, dTerm,
; 0002 02A1             FAN_SPEED, ADC_VAR2);
	__POINTW1FN _0x40000,1367
	CALL SUBOPT_0x58
	CALL SUBOPT_0x59
	CALL SUBOPT_0x5A
	CALL SUBOPT_0x4D
	CALL SUBOPT_0x23
	CALL SUBOPT_0x4C
	CALL SUBOPT_0x23
	LDD  R30,Y+34
	LDD  R31,Y+34+1
	CALL SUBOPT_0x23
	CALL SUBOPT_0x22
	CALL SUBOPT_0x23
	CALL SUBOPT_0x49
	MOV  R30,R6
	CALL SUBOPT_0x28
	LDD  R30,Y+44
	LDD  R31,Y+44+1
	CALL SUBOPT_0x23
	MOVW R30,R16
	CALL SUBOPT_0x23
	MOVW R30,R20
	CALL SUBOPT_0x23
	MOVW R30,R18
	CALL SUBOPT_0x23
	CALL SUBOPT_0x4F
	CALL SUBOPT_0x23
	CALL SUBOPT_0x51
	LDI  R24,60
	CALL _printf
	ADIW R28,62
; 0002 02A2     else
	RJMP _0x400EF
_0x400EE:
; 0002 02A3         printf("Delta (x100) = %d, result = %d, TAP_ANGLE = %d, pTerm = %d, iTerm = %d, dTerm = %d\r\n",
; 0002 02A4             error, result, TAP_ANGLE, pTerm, iTerm, dTerm, POM_T);
	__POINTW1FN _0x40000,1432
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	CALL SUBOPT_0x23
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	CALL SUBOPT_0x23
	CALL SUBOPT_0x22
	CALL SUBOPT_0x23
	MOVW R30,R16
	CALL SUBOPT_0x23
	MOVW R30,R20
	CALL SUBOPT_0x23
	MOVW R30,R18
	CALL SUBOPT_0x23
	CALL SUBOPT_0x4C
	CALL SUBOPT_0x23
	LDI  R24,28
	CALL _printf
	ADIW R28,30
; 0002 02A5 }
_0x400EF:
	CALL __LOADLOCR6
	ADIW R28,14
	RET
;// Печать всех термометров
;void printallterms(void) {
; 0002 02A7 void printallterms(void) {
_printallterms:
; 0002 02A8     int term;
; 0002 02A9     register byte i;
; 0002 02AA     unsigned char resolution;
; 0002 02AB     signed char th, tl;
; 0002 02AC     unsigned char *spd;
; 0002 02AD 
; 0002 02AE     if(!ds1820_devices) return;			// если термометры не обнаружены - просто выходим из функции
	SBIW R28,2
	CALL __SAVELOCR6
;	term -> R16,R17
;	i -> R18
;	resolution -> R19
;	th -> R20
;	tl -> R21
;	*spd -> Y+6
	__GETB1MN _prim_par,51
	CPI  R30,0
	BRNE _0x400F0
	RJMP _0x20E0018
; 0002 02AF     spd = ds1820_show_spd();
_0x400F0:
	RCALL _ds1820_show_spd
	STD  Y+6,R30
	STD  Y+6+1,R31
; 0002 02B0     // printf("\t");						// печатаем знак табуляции в терминале
; 0002 02B1     for(i=0; i<ds1820_devices; i++) {
	LDI  R18,LOW(0)
_0x400F2:
	__GETB1MN _prim_par,51
	CP   R18,R30
	BRLO PC+3
	JMP _0x400F3
; 0002 02B2         ds1820_get_resolution(&ds1820_rom_codes[i][0], &resolution);
	CALL SUBOPT_0x5B
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R19
	RCALL _ds1820_get_resolution
	POP  R19
; 0002 02B3     	term = ds1820_temperature(&ds1820_rom_codes[i][0]);
	CALL SUBOPT_0x5B
	RCALL _ds1820_temperature
	MOVW R16,R30
; 0002 02B4         tl = th = 0;
	LDI  R30,LOW(0)
	MOV  R20,R30
	MOV  R21,R30
; 0002 02B5         ds1820_get_alarm(&ds1820_rom_codes[i][0], &tl, &th);
	CALL SUBOPT_0x5B
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R21
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R20
	RCALL _ds1820_get_alarm
	POP  R20
	POP  R21
; 0002 02B6         printf(" t%-u = %i(%-i.%-u)C[%02X%02X:%02x]%d:%d; ", i+1, term, term/100, abs(term%100), spd[1], spd[0], resolution, tl, th);
	__POINTW1FN _0x40000,1517
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R18
	SUBI R30,-LOW(1)
	CALL SUBOPT_0x28
	MOVW R30,R16
	CALL SUBOPT_0x23
	MOVW R26,R16
	CALL SUBOPT_0x41
	CALL SUBOPT_0x23
	MOVW R26,R16
	CALL SUBOPT_0x5C
	CALL SUBOPT_0x5D
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	ADIW R26,1
	LD   R30,X
	CALL SUBOPT_0x28
	LDD  R26,Y+28
	LDD  R27,Y+28+1
	LD   R30,X
	CALL SUBOPT_0x28
	MOV  R30,R19
	CALL SUBOPT_0x28
	MOV  R30,R21
	CALL SUBOPT_0x5E
	MOV  R30,R20
	CALL SUBOPT_0x5E
	LDI  R24,36
	CALL _printf
	ADIW R28,38
; 0002 02B7     }
	SUBI R18,-1
	RJMP _0x400F2
_0x400F3:
; 0002 02B8     printf("\r\n");
	CALL SUBOPT_0x5F
; 0002 02B9 }
	RJMP _0x20E0018
;// Чтение температуры (аргумент - номер термометра начиная с 0)
;int read_term(byte num) {
; 0002 02BB int read_term(byte num) {
_read_term:
; 0002 02BC     // float lt;
; 0002 02BD     // lt = termometers[num].scale / 127;
; 0002 02BE     // lt = (float)prim_par.elims[num].scale / 128 + 1;
; 0002 02BF     // lt = (termometers[num].t * lt) + prim_par.elims[num].shift;
; 0002 02C0     return termometers[num].t;
;	num -> Y+0
	LD   R30,Y
	CALL SUBOPT_0x60
	MOVW R26,R30
	CALL __GETW1P
	ADIW R28,1
	RET
; 0002 02C1 };
;// Полностью прорисовать главный экран
;void lcd_primary_screen(void) {
; 0002 02C3 void lcd_primary_screen(void) {
_lcd_primary_screen:
; 0002 02C4     char run_mod [8];
; 0002 02C5     register unsigned char i;
; 0002 02C6     unsigned char c_alerts = 0;
; 0002 02C7     unsigned char sign = '+';
; 0002 02C8     int lcd_term = main_menu[0].val_data;
; 0002 02C9     #ifndef NODEBUG
; 0002 02CA     // printf ("%02u:%02u Начало прорисовки экрана...", s_dt.cMM, s_dt.cSS);
; 0002 02CB     #endif
; 0002 02CC     for (i = 0; i < MAX_ALERTS; i++) {
	SBIW R28,8
	CALL __SAVELOCR5
;	run_mod -> Y+5
;	i -> R16
;	c_alerts -> R17
;	sign -> R18
;	lcd_term -> R19,R20
	LDI  R17,0
	LDI  R18,43
	__GETWRMN 19,20,0,_main_menu
	LDI  R16,LOW(0)
_0x400F5:
	CPI  R16,12
	BRSH _0x400F6
; 0002 02CD         // 9-й алерт (отсутствие 3-го термометра) нам не интересен
; 0002 02CE         if (prim_par.alert_status[i] && i != 9) c_alerts++;
	CALL SUBOPT_0x61
	BREQ _0x400F8
	CPI  R16,9
	BRNE _0x400F9
_0x400F8:
	RJMP _0x400F7
_0x400F9:
	SUBI R17,-1
; 0002 02CF     }
_0x400F7:
	SUBI R16,-1
	RJMP _0x400F5
_0x400F6:
; 0002 02D0     switch (mode.run) {
	__GETB1MN _mode,1
; 0002 02D1         case 0: sprintf(run_mod, "СТОП   "); break; //mode.run=0 ;
	CPI  R30,0
	BRNE _0x400FD
	CALL SUBOPT_0x62
	__POINTW1FN _0x40000,1560
	CALL SUBOPT_0x63
	RJMP _0x400FC
; 0002 02D2         case 1: sprintf(run_mod, "ПРОГРЕВ"); break; //mode.run=1;
_0x400FD:
	CPI  R30,LOW(0x1)
	BRNE _0x400FE
	CALL SUBOPT_0x62
	__POINTW1FN _0x40000,1568
	CALL SUBOPT_0x63
	RJMP _0x400FC
; 0002 02D3         case 2: sprintf(run_mod, "ОСТАНОВ"); break; //mode.run=2 ;
_0x400FE:
	CPI  R30,LOW(0x2)
	BRNE _0x400FF
	CALL SUBOPT_0x62
	__POINTW1FN _0x40000,1576
	CALL SUBOPT_0x63
	RJMP _0x400FC
; 0002 02D4         case 3: sprintf(run_mod, "ПУСК   "); break; //mode.run=3
_0x400FF:
	CPI  R30,LOW(0x3)
	BRNE _0x40101
	CALL SUBOPT_0x62
	__POINTW1FN _0x40000,1584
	CALL SUBOPT_0x63
; 0002 02D5         default: break;
_0x40101:
; 0002 02D6     };
_0x400FC:
; 0002 02D7     if (c_alerts)
	CPI  R17,0
	BREQ _0x40102
; 0002 02D8         sprintf(run_mod, "Авария ");
	CALL SUBOPT_0x62
	__POINTW1FN _0x40000,1592
	CALL SUBOPT_0x63
; 0002 02D9     else {
	RJMP _0x40103
_0x40102:
; 0002 02DA         signal_red(OFF);  signal_buz(OFF); // signal_green(OFF);
	CALL SUBOPT_0xE
; 0002 02DB     }
_0x40103:
; 0002 02DC     lcd_command(LCD_DISP_ON);       // Убираем курсор с LCD
	LDI  R30,LOW(12)
	ST   -Y,R30
	CALL _lcd_command
; 0002 02DD     lcd_gotoxy(0,0);        // Устанавливаем курсор в позицию 0 первой строки
	CALL SUBOPT_0x64
; 0002 02DE     sprintf(linestr, "%02u:%02u:%02u %02u.%02u  ", s_dt.cHH, s_dt.cMM, s_dt.cSS, s_dt.cdd, s_dt.cmo);
	CALL SUBOPT_0x65
	__POINTW1FN _0x40000,1600
	CALL SUBOPT_0x58
	CALL SUBOPT_0x59
	CALL SUBOPT_0x5A
	CALL SUBOPT_0x66
	CALL SUBOPT_0x67
	LDI  R24,20
	CALL _sprintf
	ADIW R28,24
; 0002 02DF     lcd_puts(linestr);
	CALL SUBOPT_0x65
	CALL _lcd_puts
; 0002 02E0     lcd_gotoxy(0,1);                // Устанавливаем курсор в позицию 0 строки 2
	CALL SUBOPT_0x7
	CALL _lcd_gotoxy
; 0002 02E1     // Выводим информацию о термометрах
; 0002 02E2     if(ds1820_devices) {
	__GETB1MN _prim_par,51
	CPI  R30,0
	BREQ _0x40104
; 0002 02E3         sign = (lcd_term < 0) ? '-' : '+';
	TST  R20
	BRPL _0x40105
	LDI  R30,LOW(45)
	RJMP _0x40106
_0x40105:
	LDI  R30,LOW(43)
_0x40106:
	MOV  R18,R30
; 0002 02E4         sprintf(linestr, "t=%c%02u.%01uC %s", sign, abs(lcd_term)/100, (abs(lcd_term)%100)/10, run_mod);
	CALL SUBOPT_0x65
	__POINTW1FN _0x40000,1627
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R18
	CALL SUBOPT_0x28
	CALL SUBOPT_0x68
	CALL SUBOPT_0x69
	CALL SUBOPT_0x68
	CALL __MODW21U
	MOVW R26,R30
	LDI  R30,LOW(10)
	LDI  R31,HIGH(10)
	CALL SUBOPT_0x69
	MOVW R30,R28
	ADIW R30,21
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x6A
; 0002 02E5         // linestr += "panarin";
; 0002 02E6     } else {
	RJMP _0x40108
_0x40104:
; 0002 02E7         sprintf(linestr, "Нет термометров");
	CALL SUBOPT_0x65
	__POINTW1FN _0x40000,1645
	CALL SUBOPT_0x63
; 0002 02E8     }
_0x40108:
; 0002 02E9     lcd_puts(linestr);
	CALL SUBOPT_0x65
	CALL _lcd_puts
; 0002 02EA     #ifndef NODEBUG
; 0002 02EB     // printf ("конец в %02u:%02u\r\n", s_dt.cMM, s_dt.cSS);
; 0002 02EC     #endif
; 0002 02ED }
	CALL __LOADLOCR5
	ADIW R28,13
	RET
;// Печать структуры prim_par
;void print_prim_par(unsigned char *struct_data, unsigned char size) {
; 0002 02EF void print_prim_par(unsigned char *struct_data, unsigned char size) {
_print_prim_par:
; 0002 02F0     register unsigned char i;
; 0002 02F1     unsigned char s_byte;
; 0002 02F2     printf("Состояние prim_par [%d bytes]: ", size);
	ST   -Y,R17
	ST   -Y,R16
;	*struct_data -> Y+3
;	size -> Y+2
;	i -> R16
;	s_byte -> R17
	__POINTW1FN _0x40000,1661
	CALL SUBOPT_0x6B
	CALL SUBOPT_0xA
; 0002 02F3     for (i=0; i<size; i++) {
	LDI  R16,LOW(0)
_0x4010A:
	LDD  R30,Y+2
	CP   R16,R30
	BRSH _0x4010B
; 0002 02F4         s_byte = *struct_data++;
	LDD  R26,Y+3
	LDD  R27,Y+3+1
	LD   R17,X+
	STD  Y+3,R26
	STD  Y+3+1,R27
; 0002 02F5         if (i < (size - 36))
	SUBI R30,LOW(36)
	CP   R16,R30
	BRSH _0x4010C
; 0002 02F6             printf(" %d", s_byte);
	__POINTW1FN _0x40000,1693
	RJMP _0x40165
; 0002 02F7         else
_0x4010C:
; 0002 02F8             printf(" %X", s_byte);
	__POINTW1FN _0x40000,1697
_0x40165:
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R17
	CALL SUBOPT_0x28
	CALL SUBOPT_0xA
; 0002 02F9         //
; 0002 02FA     }
	SUBI R16,-1
	RJMP _0x4010A
_0x4010B:
; 0002 02FB     printf("\r\n");
	CALL SUBOPT_0x5F
; 0002 02FC }
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0014
;// Функция инициализирующая новые термометры. !!! Надо здесь разбираться.
;void init_new_terms(unsigned char number) {
; 0002 02FE void init_new_terms(unsigned char number) {
_init_new_terms:
; 0002 02FF     register unsigned char i;
; 0002 0300     unsigned char is_found = 0, is_new = 0;
; 0002 0301     signed char th, tl, index;
; 0002 0302     unsigned char newterms;
; 0002 0303     // Ищем по новой все термометры
; 0002 0304     newterms = w1_search(0xf0, ds1820_rom_codes);
	SBIW R28,1
	CALL __SAVELOCR6
;	number -> Y+7
;	i -> R16
;	is_found -> R17
;	is_new -> R18
;	th -> R19
;	tl -> R20
;	index -> R21
;	newterms -> Y+6
	LDI  R17,0
	LDI  R18,0
	CALL SUBOPT_0x8
	STD  Y+6,R30
; 0002 0305     delay_ms (DS1820_ALL_DELAY);
	CALL SUBOPT_0x6
; 0002 0306     printallterms();
	RCALL _printallterms
; 0002 0307     // Вычитываем TH, TL. Иными словами вычисляем индекс.
; 0002 0308     for(i = 0; i < newterms; i++) {
	LDI  R16,LOW(0)
_0x4010F:
	LDD  R30,Y+6
	CP   R16,R30
	BRSH _0x40110
; 0002 0309         ds1820_get_alarm(&ds1820_rom_codes[i][0], &tl, &th);
	CALL SUBOPT_0x6C
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R20
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R19
	RCALL _ds1820_get_alarm
	POP  R19
	POP  R20
; 0002 030A         index = (th == OUR_SIGNATURE) ? abs(tl) - 2 : -1;
	CPI  R19,187
	BRNE _0x40111
	MOV  R30,R20
	CALL SUBOPT_0x25
	SBIW R30,2
	RJMP _0x40112
_0x40111:
	LDI  R30,LOW(255)
_0x40112:
	MOV  R21,R30
; 0002 030B         // Проверяем на совпадение с number
; 0002 030C         if (!is_found) is_found = (index == number) ? i + 1 : 0;
	CPI  R17,0
	BRNE _0x40114
	LDD  R30,Y+7
	MOV  R26,R21
	CALL SUBOPT_0x6D
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x40115
	MOV  R30,R16
	SUBI R30,-LOW(1)
	RJMP _0x40116
_0x40115:
	LDI  R30,LOW(0)
_0x40116:
	MOV  R17,R30
; 0002 030D         // Проверяем свободность
; 0002 030E         if (!is_new) is_new = (index == -1) ? 0 : i + 1;
_0x40114:
	CPI  R18,0
	BRNE _0x40118
	CPI  R21,255
	BRNE _0x40119
	LDI  R30,LOW(0)
	RJMP _0x4011A
_0x40119:
	MOV  R30,R16
	SUBI R30,-LOW(1)
_0x4011A:
	MOV  R18,R30
; 0002 030F     }
_0x40118:
	SUBI R16,-1
	RJMP _0x4010F
_0x40110:
; 0002 0310     #ifndef NODEBUG
; 0002 0311     printf ("Задан N%u (number), нашли N%u (is_found), свободный N%u (is_new)\r\n", number, is_found, is_new);
	__POINTW1FN _0x40000,1701
	CALL SUBOPT_0x6E
	MOV  R30,R17
	CALL SUBOPT_0x28
	MOV  R30,R18
	CALL SUBOPT_0x28
	CALL SUBOPT_0x12
; 0002 0312     #endif
; 0002 0313     // Если есть, то выходим из функции с соотвествующим сообщением
; 0002 0314     if (is_found) {
	CPI  R17,0
	BREQ _0x4011C
; 0002 0315         printf ("Термометр N%u существует по порядковому номеру %u\r\n", number, is_found);
	__POINTW1FN _0x40000,1768
	CALL SUBOPT_0x6E
	MOV  R30,R17
	CALL SUBOPT_0x28
	CALL SUBOPT_0x24
; 0002 0316         return;
	RJMP _0x20E0018
; 0002 0317     }
; 0002 0318     // Если нет свободных, выходим с соотвествующим сообщением
; 0002 0319     if (!is_new) {
_0x4011C:
	CPI  R18,0
	BRNE _0x4011D
; 0002 031A         printf ("Свободных термометров нет\r\n");
	__POINTW1FN _0x40000,1820
	CALL SUBOPT_0x1
; 0002 031B         return;
	RJMP _0x20E0018
; 0002 031C     }
; 0002 031D     // Если нашли, то прописываем TH, TL
; 0002 031E     tl = -2 - number; i = is_new - 1;
_0x4011D:
	LDD  R26,Y+7
	LDI  R30,LOW(254)
	SUB  R30,R26
	MOV  R20,R30
	MOV  R30,R18
	SUBI R30,LOW(1)
	MOV  R16,R30
; 0002 031F     #ifndef NODEBUG
; 0002 0320     printf ("Новый TL = %d[%02x] по номеру %u\r\n", tl, tl, i);
	__POINTW1FN _0x40000,1848
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R20
	CALL SUBOPT_0x5E
	MOV  R30,R20
	CALL SUBOPT_0x5E
	MOV  R30,R16
	CALL SUBOPT_0x28
	CALL SUBOPT_0x12
; 0002 0321     #endif
; 0002 0322     if (ds1820_set_alarm(&ds1820_rom_codes[i][0], tl, OUR_SIGNATURE)) {
	CALL SUBOPT_0x6C
	ST   -Y,R20
	LDI  R30,LOW(187)
	CALL SUBOPT_0x6F
	BREQ _0x4011E
; 0002 0323         printf ("Проинициализировали термометр N%u по порядковому номеру %u\r\n", number, is_new);
	__POINTW1FN _0x40000,1883
	CALL SUBOPT_0x6E
	MOV  R30,R18
	CALL SUBOPT_0x28
	CALL SUBOPT_0x24
; 0002 0324         delay_ms (DS1820_ALL_DELAY);
	CALL SUBOPT_0x6
; 0002 0325         // Запускаем перезагрузку
; 0002 0326         #asm
; 0002 0327             JMP  __RESET
            JMP  __RESET
; 0002 0328         #endasm
; 0002 0329     }
; 0002 032A     printf ("Не могу проинициализировать новый термометр N%u\r\n", number);
_0x4011E:
	__POINTW1FN _0x40000,1944
	CALL SUBOPT_0x6E
	CALL SUBOPT_0xA
; 0002 032B     return;
_0x20E0018:
	CALL __LOADLOCR6
	ADIW R28,8
	RET
; 0002 032C }
;void ask_turn_off(void) {
; 0002 032D void ask_turn_off(void) {
_ask_turn_off:
; 0002 032E     printf("Выключите питание и подключите все оборудование\r\n");
	__POINTW1FN _0x40000,1994
	CALL SUBOPT_0x1
; 0002 032F     while(1);
_0x4011F:
	RJMP _0x4011F
; 0002 0330 }
;// Установка номера термометра принудительно на 1-й попавшийся.
;void init_force_term(signed char number) {
; 0002 0332 void init_force_term(signed char number) {
_init_force_term:
; 0002 0333     // Описание локальных переменных
; 0002 0334     byte inbyte = 0;
; 0002 0335     // Начало
; 0002 0336     #asm("cli")
	ST   -Y,R16
;	number -> Y+1
;	inbyte -> R16
	LDI  R16,0
	cli
; 0002 0337     printf("Отключите все термометры, кроме [%02x] и нажмите клавишу SHIFT-'~'\r\nВыход из режима - выключение питания\r\n", number);
	__POINTW1FN _0x40000,2044
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+3
	CALL SUBOPT_0x5E
	CALL SUBOPT_0xA
; 0002 0338     do
_0x40123:
; 0002 0339         if (UCSRA & RX_COMPLETE) inbyte = UDR;
	SBIC 0xB,7
	IN   R16,12
; 0002 033A     while (inbyte != 0x7E);
	CPI  R16,126
	BRNE _0x40123
; 0002 033B     ds1820_devices = w1_search(0xf0, ds1820_rom_codes);
	CALL SUBOPT_0x8
	__PUTB1MN _prim_par,51
; 0002 033C     delay_ms (DS1820_ALL_DELAY);
	CALL SUBOPT_0x6
; 0002 033D     printallterms();
	RCALL _printallterms
; 0002 033E     if (!ds1820_devices)
	__GETB1MN _prim_par,51
	CPI  R30,0
	BRNE _0x40126
; 0002 033F         printf("Термометры не найдены\r\n");
	__POINTW1FN _0x40000,2151
	CALL SUBOPT_0x1
; 0002 0340     else
	RJMP _0x40127
_0x40126:
; 0002 0341         if (ds1820_set_alarm(&ds1820_rom_codes[0][0], number, OUR_SIGNATURE))
	LDI  R30,LOW(_ds1820_rom_codes)
	LDI  R31,HIGH(_ds1820_rom_codes)
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+3
	ST   -Y,R30
	LDI  R30,LOW(187)
	CALL SUBOPT_0x6F
	BREQ _0x40128
; 0002 0342             printf("Термометр [%02x] успешно проинициализирован\r\n", number);
	__POINTW1FN _0x40000,2175
	RJMP _0x40166
; 0002 0343         else
_0x40128:
; 0002 0344             printf("Не могу проинициализировать новый термометр [%02x]\r\n", number);
	__POINTW1FN _0x40000,2221
_0x40166:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+3
	CALL SUBOPT_0x5E
	CALL SUBOPT_0xA
; 0002 0345     ask_turn_off();
_0x40127:
	RCALL _ask_turn_off
; 0002 0346     #asm("sei")
	sei
; 0002 0347 }
	LDD  R16,Y+0
	RJMP _0x20E0012
;void set_term(signed char number, signed char sign) {
; 0002 0348 void set_term(signed char number, signed char sign) {
_set_term:
; 0002 0349     if (sign == OUR_SIGNATURE) {
;	number -> Y+1
;	sign -> Y+0
	LD   R26,Y
	CPI  R26,LOW(0xBB)
	BRNE _0x4012A
; 0002 034A         if (ds1820_set_alarm(&ds1820_rom_codes[number][0], -2 - number, sign))
	CALL SUBOPT_0x70
	LDD  R26,Y+3
	LDI  R30,LOW(254)
	SUB  R30,R26
	ST   -Y,R30
	LDD  R30,Y+3
	CALL SUBOPT_0x6F
	BREQ _0x4012B
; 0002 034B             printf("Термометр [%02x] успешно проинициализирован\r\n", number);
	__POINTW1FN _0x40000,2175
	RJMP _0x40167
; 0002 034C         else
_0x4012B:
; 0002 034D             printf("Не могу проинициализировать термометр [%02x]\r\n", number);
	__POINTW1FN _0x40000,2274
_0x40167:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+3
	CALL SUBOPT_0x5E
	CALL SUBOPT_0xA
; 0002 034E     } else {
	RJMP _0x4012D
_0x4012A:
; 0002 034F         if (ds1820_set_alarm(&ds1820_rom_codes[number][0], 1, sign))
	CALL SUBOPT_0x70
	LDI  R30,LOW(1)
	ST   -Y,R30
	LDD  R30,Y+3
	CALL SUBOPT_0x6F
	BREQ _0x4012E
; 0002 0350             printf("Термометр [%02x] успешно очищен\r\n", number);
	__POINTW1FN _0x40000,2321
	RJMP _0x40168
; 0002 0351         else
_0x4012E:
; 0002 0352             printf("Не могу очистить термометр [%02x]\r\n", number);
	__POINTW1FN _0x40000,2355
_0x40168:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+3
	CALL SUBOPT_0x5E
	CALL SUBOPT_0xA
; 0002 0353     }
_0x4012D:
; 0002 0354 }
	RJMP _0x20E0012
;// Переключение звука
;void toggle_sound(void) {
; 0002 0356 void toggle_sound(void) {
_toggle_sound:
; 0002 0357     if (mode.sound)
	__GETB1MN _mode,6
	CPI  R30,0
	BREQ _0x40130
; 0002 0358         printf("Звук выключен\r\n");
	__POINTW1FN _0x40000,2391
	RJMP _0x40169
; 0002 0359     else
_0x40130:
; 0002 035A         printf("Звук включен\r\n");
	__POINTW1FN _0x40000,2407
_0x40169:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R24,0
	CALL _printf
	ADIW R28,2
; 0002 035B     mode.sound = !mode.sound;
	__GETB1MN _mode,6
	CALL __LNEGB1
	__PUTB1MN _mode,6
; 0002 035C }
	RET
;// Переключение печати
;void toggle_print(void) {
; 0002 035E void toggle_print(void) {
_toggle_print:
; 0002 035F     mode.print = !mode.print;
	__GETB1MN _mode,18
	CALL __LNEGB1
	__PUTB1MN _mode,18
; 0002 0360     if (mode.print)
	__GETB1MN _mode,18
	CPI  R30,0
	BREQ _0x40132
; 0002 0361         printf("Печать включена\r\n");
	__POINTW1FN _0x40000,2422
	RJMP _0x4016A
; 0002 0362         //printf("Печать выключена\r\n Время, Температура заданная, Температура измеренная, Delta, Угол крана расчетный, Угол кранаизмеренный, Угол ограничения, result, pTerm, iTerm, dTerm, Обороты расчетные, Обороты измеренныее\r\n");
; 0002 0363     else
_0x40132:
; 0002 0364         printf("Печать выключена\r\n Время, Температура заданная, Температура измеренная, Delta, Угол крана расчетный, Угол кранаизмеренный, Угол ограничения, result, pTerm, iTerm, dTerm, Обороты расчетные, Обороты измеренныее\r\n");
	__POINTW1FN _0x40000,2440
_0x4016A:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R24,0
	CALL _printf
	ADIW R28,2
; 0002 0365         //printf("Печать включена\r\n");
; 0002 0366 }
	RET
;// Обработка событий от серийного порта
;void check_serial(void) {
; 0002 0368 void check_serial(void) {
_check_serial:
; 0002 0369     byte inbyte;    // Описание локальных переменных
; 0002 036A     register byte i;
; 0002 036B     // Обрабатываем последовательный порт
; 0002 036C     if (UCSRA & RX_COMPLETE) { // Пришло ли что-нибудь
	ST   -Y,R17
	ST   -Y,R16
;	inbyte -> R16
;	i -> R17
	SBIS 0xB,7
	RJMP _0x40134
; 0002 036D         inbyte = UDR;
	IN   R16,12
; 0002 036E         switch (inbyte) {
	MOV  R30,R16
; 0002 036F             case 0x7A:  /* 'z' */
	CPI  R30,LOW(0x7A)
	BRNE _0x40138
; 0002 0370                 printf("Время: %02u:%02u:%02u, дата:%02u.%02u.%02u, найдено %u термометров\r\n",
; 0002 0371                         s_dt.cHH, s_dt.cMM, s_dt.cSS, s_dt.cdd, s_dt.cmo, s_dt.cyy, ds1820_devices);
	__POINTW1FN _0x40000,2651
	CALL SUBOPT_0x58
	CALL SUBOPT_0x59
	CALL SUBOPT_0x5A
	CALL SUBOPT_0x66
	CALL SUBOPT_0x67
	__GETB1MN _s_dt,3
	CALL SUBOPT_0x28
	CALL SUBOPT_0x9
	LDI  R24,28
	CALL _printf
	ADIW R28,30
; 0002 0372                 printallterms();
	RCALL _printallterms
; 0002 0373                 break;
	RJMP _0x40137
; 0002 0374             case 0x73:  /* 's' */     // переключение звука
_0x40138:
	CPI  R30,LOW(0x73)
	BRNE _0x40139
; 0002 0375                 toggle_sound(); break;
	RCALL _toggle_sound
	RJMP _0x40137
; 0002 0376             case 0x77:  /* 'w' */     // символ
_0x40139:
	CPI  R30,LOW(0x77)
	BRNE _0x4013A
; 0002 0377                 printf ("Cаабытие = %u\r\n", (unsigned char)event);
	__POINTW1FN _0x40000,2720
	ST   -Y,R31
	ST   -Y,R30
	LDS  R30,_event
	RJMP _0x4016B
; 0002 0378                 break;
; 0002 0379             case 0x78:  // символ 'x'
_0x4013A:
	CPI  R30,LOW(0x78)
	BRNE _0x4013B
; 0002 037A                 toggle_print(); break;
	RCALL _toggle_print
	RJMP _0x40137
; 0002 037B                 // print_curr_menu(); break; // Печатаем текущее меню
; 0002 037C             case 0x65:  // символ 'e'
_0x4013B:
	CPI  R30,LOW(0x65)
	BRNE _0x4013C
; 0002 037D                 alarm_all_print();
	CALL _alarm_all_print
; 0002 037E                 break;
	RJMP _0x40137
; 0002 037F             case 0x64:  // символ 'd'
_0x4013C:
	CPI  R30,LOW(0x64)
	BRNE _0x4013D
; 0002 0380                 for (i=0; i < MAX_ALERTS; i++) {
	LDI  R17,LOW(0)
_0x4013F:
	CPI  R17,12
	BRSH _0x40140
; 0002 0381                     if (!(alarm_unreg(i))) {
	ST   -Y,R17
	CALL _alarm_unreg
	CPI  R30,0
	BRNE _0x40141
; 0002 0382                        printf ("Удалили активную тревогу: %s\r\n", get_alert_str(i));
	__POINTW1FN _0x40000,2736
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R17
	CALL SUBOPT_0x38
; 0002 0383                     }
; 0002 0384                 }
_0x40141:
	SUBI R17,-1
	RJMP _0x4013F
_0x40140:
; 0002 0385                 printf ("Инициализируем все термометры!\r\n");
	__POINTW1FN _0x40000,2767
	CALL SUBOPT_0x1
; 0002 0386                 read_all_terms(INIT_MODE);
	CALL SUBOPT_0x18
; 0002 0387                 break;
	RJMP _0x40137
; 0002 0388             case 0x63:                // символ 'c'
_0x4013D:
	CPI  R30,LOW(0x63)
	BRNE _0x40142
; 0002 0389                 print_prim_par((unsigned char *)&prim_par, sizeof(prim_par));
	CALL SUBOPT_0x16
	LDI  R30,LOW(88)
	ST   -Y,R30
	RCALL _print_prim_par
; 0002 038A                 break;
	RJMP _0x40137
; 0002 038B             case 0x6D:                // символ 'm'
_0x40142:
	CPI  R30,LOW(0x6D)
	BRNE _0x40143
; 0002 038C                 for(i=0; i<NUM_PARAMETERS; i++) printf("%s\t", param_str(i, parameters));
	LDI  R17,LOW(0)
_0x40145:
	CPI  R17,11
	BRSH _0x40146
	__POINTW1FN _0x40000,2800
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R17
	LDI  R30,LOW(_parameters)
	LDI  R31,HIGH(_parameters)
	CALL SUBOPT_0x71
	CALL SUBOPT_0x5D
	CALL SUBOPT_0xA
	SUBI R17,-1
	RJMP _0x40145
_0x40146:
; 0002 038D printf("\r\n");
	CALL SUBOPT_0x5F
; 0002 038E                 break;
	RJMP _0x40137
; 0002 038F             case 0x6E:                // символ 'n'
_0x40143:
	CPI  R30,LOW(0x6E)
	BRNE _0x40147
; 0002 0390                 for(i=0; i<NUM_MENU; i++) printf("%s\t", param_str(i, main_menu));
	LDI  R17,LOW(0)
_0x40149:
	CPI  R17,7
	BRSH _0x4014A
	__POINTW1FN _0x40000,2800
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R17
	CALL SUBOPT_0xC
	CALL _param_str
	CALL SUBOPT_0x5D
	CALL SUBOPT_0xA
	SUBI R17,-1
	RJMP _0x40149
_0x4014A:
; 0002 0391 printf("\r\n");
	CALL SUBOPT_0x5F
; 0002 0392                 break;
	RJMP _0x40137
; 0002 0393             case 0x4a:              // символ 'j'
_0x40147:
	CPI  R30,LOW(0x4A)
	BRNE _0x4014B
; 0002 0394                 poll_keys();
	CALL _poll_keys
; 0002 0395                 break;
	RJMP _0x40137
; 0002 0396             case 0x75:                // символ 'u' Воздух в помещении
_0x4014B:
	CPI  R30,LOW(0x75)
	BRNE _0x4014C
; 0002 0397                 init_force_term(0xFE); break;
	LDI  R30,LOW(254)
	ST   -Y,R30
	RCALL _init_force_term
	RJMP _0x40137
; 0002 0398             case 0x69:                // символ 'i' Воздух на улице
_0x4014C:
	CPI  R30,LOW(0x69)
	BRNE _0x4014D
; 0002 0399                 init_force_term(0xFD); break;
	LDI  R30,LOW(253)
	ST   -Y,R30
	RCALL _init_force_term
	RJMP _0x40137
; 0002 039A             case 0x6F:                // символ 'o' Вода
_0x4014D:
	CPI  R30,LOW(0x6F)
	BRNE _0x4014E
; 0002 039B                 init_force_term(0xFC); break;
	LDI  R30,LOW(252)
	ST   -Y,R30
	RCALL _init_force_term
	RJMP _0x40137
; 0002 039C             case 0x70:                // символ 'p'
_0x4014E:
	CPI  R30,LOW(0x70)
	BRNE _0x4014F
; 0002 039D                 init_force_term(0xFB); break;
	LDI  R30,LOW(251)
	ST   -Y,R30
	RCALL _init_force_term
	RJMP _0x40137
; 0002 039E             case 0x30:              // символ '0'
_0x4014F:
	CPI  R30,LOW(0x30)
	BRNE _0x40150
; 0002 039F                 printf("Всем найденым термометрам прописываем 0x69 0xFE - Термометр в помещении\r\n");
	__POINTW1FN _0x40000,2804
	CALL SUBOPT_0x1
; 0002 03A0                 init_new_terms(0);   // Находим непроинициализированные термометры и первому попавшему прописываем 0x69 0xFE
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _init_new_terms
; 0002 03A1                 break;
	RJMP _0x40137
; 0002 03A2             case 0x31:              // символ '1'
_0x40150:
	CPI  R30,LOW(0x31)
	BRNE _0x40151
; 0002 03A3                 printf("Всем найденым термометрам прописываем 0x69 0xFD - Термометр на улице\r\n");
	__POINTW1FN _0x40000,2878
	CALL SUBOPT_0x1
; 0002 03A4                 init_new_terms(1);
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _init_new_terms
; 0002 03A5                 break;
	RJMP _0x40137
; 0002 03A6             case 0x32:              // символ '2'
_0x40151:
	CPI  R30,LOW(0x32)
	BRNE _0x40152
; 0002 03A7                 printf("Всем найденым термометрам прописываем 0x69 0xFC - Термометр на подаче воды\r\n");
	__POINTW1FN _0x40000,2949
	CALL SUBOPT_0x1
; 0002 03A8                 init_new_terms(2);
	LDI  R30,LOW(2)
	ST   -Y,R30
	RCALL _init_new_terms
; 0002 03A9                 break;
	RJMP _0x40137
; 0002 03AA             case 0x33:              // символ '3'
_0x40152:
	CPI  R30,LOW(0x33)
	BRNE _0x40153
; 0002 03AB                 printf("Всем найденым термометрам прописываем 0x69 0xFB - Термометр на обратке воды\r\n");
	__POINTW1FN _0x40000,3026
	CALL SUBOPT_0x1
; 0002 03AC                 init_new_terms(3);
	LDI  R30,LOW(3)
	ST   -Y,R30
	RCALL _init_new_terms
; 0002 03AD                 break;
	RJMP _0x40137
; 0002 03AE             case 0x3f:              /* Shift + '?'*/
_0x40153:
	CPI  R30,LOW(0x3F)
	BRNE _0x40154
; 0002 03AF                 set_term(3, 1); break;
	LDI  R30,LOW(3)
	CALL SUBOPT_0x72
	RJMP _0x40137
; 0002 03B0             case 0x3e:              /* Shift + '>' */
_0x40154:
	CPI  R30,LOW(0x3E)
	BRNE _0x40155
; 0002 03B1                 set_term(2, 1); break;
	LDI  R30,LOW(2)
	CALL SUBOPT_0x72
	RJMP _0x40137
; 0002 03B2             case 0x3c:              /* Shift + '<' */
_0x40155:
	CPI  R30,LOW(0x3C)
	BRNE _0x40156
; 0002 03B3                 set_term(1, 1); break;
	LDI  R30,LOW(1)
	CALL SUBOPT_0x72
	RJMP _0x40137
; 0002 03B4             case 0x4d:              /* Shift + 'M' */
_0x40156:
	CPI  R30,LOW(0x4D)
	BRNE _0x40157
; 0002 03B5                 set_term(0, 1); break;
	CALL SUBOPT_0x7
	RCALL _set_term
	RJMP _0x40137
; 0002 03B6             case 0x22:              /* Shift + '"'*/
_0x40157:
	CPI  R30,LOW(0x22)
	BRNE _0x40158
; 0002 03B7                 set_term(3, OUR_SIGNATURE); break;
	LDI  R30,LOW(3)
	CALL SUBOPT_0x73
	RJMP _0x40137
; 0002 03B8             case 0x3a:              /* Shift + ':' */
_0x40158:
	CPI  R30,LOW(0x3A)
	BRNE _0x40159
; 0002 03B9                 set_term(2, OUR_SIGNATURE); break;
	LDI  R30,LOW(2)
	CALL SUBOPT_0x73
	RJMP _0x40137
; 0002 03BA             case 0x4c:              /* Shift + 'L' */
_0x40159:
	CPI  R30,LOW(0x4C)
	BRNE _0x4015A
; 0002 03BB                 set_term(1, OUR_SIGNATURE); break;
	LDI  R30,LOW(1)
	CALL SUBOPT_0x73
	RJMP _0x40137
; 0002 03BC             case 0x4b:              /* Shift + 'K' */
_0x4015A:
	CPI  R30,LOW(0x4B)
	BRNE _0x4015B
; 0002 03BD                 set_term(0, OUR_SIGNATURE); break;
	LDI  R30,LOW(0)
	CALL SUBOPT_0x73
	RJMP _0x40137
; 0002 03BE             case 0x39:              // символ '9'
_0x4015B:
	CPI  R30,LOW(0x39)
	BRNE _0x4015D
; 0002 03BF                 signal_printallbytes();
	CALL _signal_printallbytes
; 0002 03C0                 break;
	RJMP _0x40137
; 0002 03C1             default:
_0x4015D:
; 0002 03C2                 printf("Нажат символ 0x%x\r\n", inbyte);
	__POINTW1FN _0x40000,3104
	ST   -Y,R31
	ST   -Y,R30
	MOV  R30,R16
_0x4016B:
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	CALL SUBOPT_0xA
; 0002 03C3         };
_0x40137:
; 0002 03C4     }
; 0002 03C5 }
_0x40134:
	RJMP _0x20E0017
;#include <stdio.h>
;#include <stdlib.h>
;#include <delay.h>
;#include <1wire.h>
;#include "robowater.h"
;#include "spd1820.h"
;// #define NODEBUG             // Комментируя эту строку, даем возможность компилятору включить отладочный сервис
;/* #ifndef NODEBUG
;// Функция печатающая значение __ds1820_scratch_pad
;void print_scratch_pad (void) {
;    register unsigned char i;
;    unsigned char *pointer;
;    pointer = (char *) &__ds1820_scratch_pad;
;    printf("[ ");
;    for (i=0; i<9; i++) printf ("%02X ", *pointer++);
;    printf("]");
;}
;#endif */
;// DS1820 devices ROM code storage area, 9 bytes are used for each device (see the w1_search function description in the help)
;byte ds1820_rom_codes[MAX_DS1820][9];
;struct st_terms termometers[MAX_DS1820];  // Массив значений термометров с их корректировочными параметрами
;// Структура для хранения текущего ОЗУ Dallas
;struct __ds1820_scratch_pad_struct __ds1820_scratch_pad;
;// Функция записи адресов термометра из ds1820_rom_codes в структуру EEPROM, с использованием TH и TL
;unsigned char sync_ds1820_eeprom(void) {
; 0003 0019 unsigned char sync_ds1820_eeprom(void) {

	.CSEG
_sync_ds1820_eeprom:
; 0003 001A     unsigned char result = 0, i, j;
; 0003 001B     signed char th, tl, get_alarm;
; 0003 001C 
; 0003 001D     for (i = 0; i < ds1820_devices; i++) {
	CALL __SAVELOCR6
;	result -> R16
;	i -> R17
;	j -> R18
;	th -> R19
;	tl -> R20
;	get_alarm -> R21
	LDI  R16,0
	LDI  R17,LOW(0)
_0x60004:
	__GETB1MN _prim_par,51
	CP   R17,R30
	BRLO PC+3
	JMP _0x60005
; 0003 001E         get_alarm = ds1820_get_alarm(&ds1820_rom_codes[i][0], &tl, &th);
	LDI  R26,LOW(9)
	MUL  R17,R26
	MOVW R30,R0
	SUBI R30,LOW(-_ds1820_rom_codes)
	SBCI R31,HIGH(-_ds1820_rom_codes)
	ST   -Y,R31
	ST   -Y,R30
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R20
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R19
	RCALL _ds1820_get_alarm
	POP  R19
	POP  R20
	MOV  R21,R30
; 0003 001F         if (get_alarm > 0) {
	CPI  R21,1
	BRLT _0x60006
; 0003 0020             // Адрес термометра [i] начинается с нулевой позиции [0]
; 0003 0021             // Если термометр имеет необходимую сигнатуру, то присваеваем значение по смещению. tl
; 0003 0022             // Иначе присваиваем в нулевой элемент (температура в помещении)
; 0003 0023             for (j = 0; j < 9; j++)
	LDI  R18,LOW(0)
_0x60008:
	CPI  R18,9
	BRSH _0x60009
; 0003 0024                 // Если термометр имеет "левую" сигнатуру, то переписываем его в массив ufo
; 0003 0025                 if (th == OUR_SIGNATURE)
	CPI  R19,187
	BRNE _0x6000A
; 0003 0026                     prim_par.addr[abs(tl) - 2][j] = ds1820_rom_codes[i][j];
	MOV  R30,R20
	CALL SUBOPT_0x25
	SBIW R30,2
	LDI  R26,LOW(9)
	LDI  R27,HIGH(9)
	CALL __MULW12U
	__ADDW1MN _prim_par,52
	MOVW R26,R30
	RJMP _0x60041
; 0003 0027                 else {
_0x6000A:
; 0003 0028                     result++;
	SUBI R16,-1
; 0003 0029                     mode.ufo[j] = ds1820_rom_codes[i][j];
	__POINTW2MN _mode,9
_0x60041:
	MOV  R30,R18
	LDI  R31,0
	ADD  R30,R26
	ADC  R31,R27
	MOVW R22,R30
	LDI  R26,LOW(9)
	MUL  R17,R26
	MOVW R30,R0
	SUBI R30,LOW(-_ds1820_rom_codes)
	SBCI R31,HIGH(-_ds1820_rom_codes)
	MOVW R26,R30
	CLR  R30
	ADD  R26,R18
	ADC  R27,R30
	LD   R30,X
	MOVW R26,R22
	ST   X,R30
; 0003 002A                 }
	SUBI R18,-1
	RJMP _0x60008
_0x60009:
; 0003 002B         }
; 0003 002C     }
_0x60006:
	SUBI R17,-1
	RJMP _0x60004
_0x60005:
; 0003 002D     return result;
	MOV  R30,R16
	CALL __LOADLOCR6
	RJMP _0x20E0010
; 0003 002E }
;// Функция чтения адресов термометра из EEPROM в ds1820_rom_codes по порядку
;void sync_eeprom_ds1820(void) {
; 0003 0030 void sync_eeprom_ds1820(void) {
_sync_eeprom_ds1820:
; 0003 0031     register byte i, j;
; 0003 0032     // Перегоняем все данные из структуры EEPROM в массив термометров
; 0003 0033     for (i = 0; i < ds1820_devices; i++)
	ST   -Y,R17
	ST   -Y,R16
;	i -> R16
;	j -> R17
	LDI  R16,LOW(0)
_0x6000D:
	__GETB1MN _prim_par,51
	CP   R16,R30
	BRSH _0x6000E
; 0003 0034         for (j = 0; j < 9; j++)
	LDI  R17,LOW(0)
_0x60010:
	CPI  R17,9
	BRSH _0x60011
; 0003 0035             ds1820_rom_codes[i][j] = prim_par.addr[i][j];
	LDI  R26,LOW(9)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_ds1820_rom_codes)
	SBCI R31,HIGH(-_ds1820_rom_codes)
	MOVW R26,R30
	MOV  R30,R17
	LDI  R31,0
	ADD  R30,R26
	ADC  R31,R27
	PUSH R31
	PUSH R30
	__POINTW2MN _prim_par,52
	MOV  R30,R16
	CALL SUBOPT_0x74
	LDI  R26,LOW(9)
	LDI  R27,HIGH(9)
	CALL __MULW12U
	MOVW R26,R22
	ADD  R26,R30
	ADC  R27,R31
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	LD   R30,X
	POP  R26
	POP  R27
	ST   X,R30
	SUBI R17,-1
	RJMP _0x60010
_0x60011:
; 0003 0036 }
	SUBI R16,-1
	RJMP _0x6000D
_0x6000E:
_0x20E0017:
	LD   R16,Y+
	LD   R17,Y+
	RET
;// Функция внесения поправки в измерение и сохранения температуры с проверкой на допустимость
;void rectification(int unconverted, unsigned char index, unsigned char measure_mode) {
; 0003 0038 void rectification(int unconverted, unsigned char index, unsigned char measure_mode) {
_rectification:
; 0003 0039     // float lt;       // параметр для коррекции температуры
; 0003 003A     if (index >= MAX_DS1820) return;
;	unconverted -> Y+2
;	index -> Y+1
;	measure_mode -> Y+0
	LDD  R26,Y+1
	CPI  R26,LOW(0x4)
	BRLO _0x60012
	RJMP _0x20E0016
; 0003 003B     // lt = (float)prim_par.elims[index].scale / 128 + 1;
; 0003 003C     // lt = lt * unconverted + prim_par.elims[index].shift;
; 0003 003D     // termometers[index].t = (int)lt;
; 0003 003E     termometers[index].t = unconverted;
_0x60012:
	LDD  R30,Y+1
	CALL SUBOPT_0x60
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	STD  Z+0,R26
	STD  Z+1,R27
; 0003 003F     if (measure_mode == INIT_MODE) {
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRNE _0x60013
; 0003 0040         if (unconverted == NOT_FOUND)
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	CPI  R26,LOW(0xD8F1)
	LDI  R30,HIGH(0xD8F1)
	CPC  R27,R30
	BRNE _0x60014
; 0003 0041             termometers[index].err = MAX_OFFLINES;
	CALL SUBOPT_0x75
	LDI  R26,LOW(5)
	RJMP _0x60042
; 0003 0042         else
_0x60014:
; 0003 0043             termometers[index].err = 0;
	CALL SUBOPT_0x75
	LDI  R26,LOW(0)
_0x60042:
	STD  Z+0,R26
; 0003 0044         termometers[index].t_last = termometers[index].t;
	CALL SUBOPT_0x76
	MOVW R22,R30
	LDD  R30,Y+1
	CALL SUBOPT_0x60
	CALL SUBOPT_0x77
	ST   X+,R30
	ST   X,R31
; 0003 0045     } else {
	RJMP _0x60016
_0x60013:
; 0003 0046         // Проверяем разницу между предыдущим измерением и текущим
; 0003 0047         if (abs(termometers[index].t - termometers[index].t_last) < DELTA_MAX) {
	LDD  R30,Y+1
	CALL SUBOPT_0x60
	LD   R22,Z
	LDD  R23,Z+1
	CALL SUBOPT_0x76
	CALL SUBOPT_0x77
	SUB  R26,R30
	SBC  R27,R31
	ST   -Y,R27
	ST   -Y,R26
	CALL _abs
	CPI  R30,LOW(0x3E8)
	LDI  R26,HIGH(0x3E8)
	CPC  R31,R26
	BRSH _0x60017
; 0003 0048             termometers[index].t_last = termometers[index].t;
	CALL SUBOPT_0x76
	MOVW R22,R30
	LDD  R30,Y+1
	CALL SUBOPT_0x60
	CALL SUBOPT_0x77
	ST   X+,R30
	ST   X,R31
; 0003 0049             termometers[index].err = 0;
	CALL SUBOPT_0x75
	LDI  R26,LOW(0)
	STD  Z+0,R26
; 0003 004A         } else {
	RJMP _0x60018
_0x60017:
; 0003 004B             termometers[index].t = termometers[index].t_last;
	LDD  R30,Y+1
	CALL SUBOPT_0x60
	MOVW R22,R30
	CALL SUBOPT_0x76
	CALL SUBOPT_0x77
	ST   X+,R30
	ST   X,R31
; 0003 004C             termometers[index].err++;
	CALL SUBOPT_0x75
	MOVW R26,R30
	LD   R30,X
	SUBI R30,-LOW(1)
	ST   X,R30
; 0003 004D         }
_0x60018:
; 0003 004E     }
_0x60016:
; 0003 004F }
_0x20E0016:
	ADIW R28,4
	RET
;// Чтение всех Dallas с коррекцией
;void read_all_terms(unsigned char measure_mode) {
; 0003 0051 void read_all_terms(unsigned char measure_mode) {
_read_all_terms:
; 0003 0052     register byte i;
; 0003 0053     // Запись из EEPROM массива адресов термометров в режиме инициализации
; 0003 0054     if (measure_mode == INIT_MODE) {
	ST   -Y,R16
;	measure_mode -> Y+1
;	i -> R16
	LDD  R26,Y+1
	CPI  R26,LOW(0x1)
	BRNE _0x60019
; 0003 0055         sync_eeprom_ds1820();
	RCALL _sync_eeprom_ds1820
; 0003 0056         for(i = 0; i < ds1820_devices; i++) {
	LDI  R16,LOW(0)
_0x6001B:
	__GETB1MN _prim_par,51
	CP   R16,R30
	BRSH _0x6001C
; 0003 0057             ds1820_set_resolution(&ds1820_rom_codes[i][0], MAX_ACCURACY);
	CALL SUBOPT_0x6C
	LDI  R30,LOW(2)
	ST   -Y,R30
	RCALL _ds1820_set_resolution
; 0003 0058             delay_ms (DS1820_ALL_DELAY);
	CALL SUBOPT_0x6
; 0003 0059             // tmp_ret = ds1820_get_resolution(&ds1820_rom_codes[i][0], &resolution);
; 0003 005A             ds1820_run_measure(&ds1820_rom_codes[i][0]);
	CALL SUBOPT_0x6C
	RCALL _ds1820_run_measure
; 0003 005B             delay_ms (DS1820_ALL_DELAY);
	CALL SUBOPT_0x6
; 0003 005C     }    }
	SUBI R16,-1
	RJMP _0x6001B
_0x6001C:
; 0003 005D     // Вычитываем значение каждого термометра и сразу запускаем его на измерение
; 0003 005E     for (i = 0; i < ds1820_devices; i++) {
_0x60019:
	LDI  R16,LOW(0)
_0x6001E:
	__GETB1MN _prim_par,51
	CP   R16,R30
	BRSH _0x6001F
; 0003 005F         int curr_t = ds1820_temperature_10(&ds1820_rom_codes[i][0]);    // Адрес термометра [i] начинается с нулевой позиции [0]
; 0003 0060         rectification (curr_t, i, measure_mode);
	SBIW R28,2
;	measure_mode -> Y+3
;	curr_t -> Y+0
	CALL SUBOPT_0x6C
	RCALL _ds1820_temperature_10
	ST   Y,R30
	STD  Y+1,R31
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R16
	LDD  R30,Y+6
	ST   -Y,R30
	RCALL _rectification
; 0003 0061         // delay_ms(10);
; 0003 0062     }
	ADIW R28,2
	SUBI R16,-1
	RJMP _0x6001E
_0x6001F:
; 0003 0063     // Здесь есть возможный баг, связанный с тем, что в датчике температуры не прописан th и tl
; 0003 0064 }
	LDD  R16,Y+0
	RJMP _0x20E0012
;unsigned char *ds1820_show_spd() {
; 0003 0065 unsigned char *ds1820_show_spd() {
_ds1820_show_spd:
; 0003 0066     return (char *) &__ds1820_scratch_pad;
	LDI  R30,LOW(___ds1820_scratch_pad)
	LDI  R31,HIGH(___ds1820_scratch_pad)
	RET
; 0003 0067 }
;// Функция выбора конкретного DALLAS
;unsigned char ds1820_select(unsigned char *addr) {
; 0003 0069 unsigned char ds1820_select(unsigned char *addr) {
_ds1820_select:
; 0003 006A 	unsigned char i;
; 0003 006B 	if (w1_init()==0) return 0;		// Инициализируем шину 1Wire
	ST   -Y,R16
;	*addr -> Y+1
;	i -> R16
	CALL _w1_init
	CPI  R30,0
	BRNE _0x60020
	LDI  R30,LOW(0)
	RJMP _0x20E0015
; 0003 006C 	if (addr) {						// Если задан адрес dallas
_0x60020:
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	SBIW R30,0
	BREQ _0x60021
; 0003 006D 		w1_write(0x55);				// Выдаем адрес dallas (8 байт) на шину 1Wire
	LDI  R30,LOW(85)
	CALL SUBOPT_0x78
; 0003 006E 		i=0;
; 0003 006F 		do
_0x60023:
; 0003 0070 			w1_write(*(addr++));
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R30,X+
	STD  Y+1,R26
	STD  Y+1+1,R27
	ST   -Y,R30
	CALL _w1_write
; 0003 0071 		while (++i<8);
	SUBI R16,-LOW(1)
	CPI  R16,8
	BRLO _0x60023
; 0003 0072 	} else
	RJMP _0x60025
_0x60021:
; 0003 0073 		w1_write(0xcc);
	LDI  R30,LOW(204)
	ST   -Y,R30
	CALL _w1_write
; 0003 0074 	return 1;
_0x60025:
	LDI  R30,LOW(1)
_0x20E0015:
	LDD  R16,Y+0
	ADIW R28,3
	RET
; 0003 0075 }
;// Функция чтения ScratchPAD (ОЗУ) Dallas (8 байт + CRC)
;unsigned char ds1820_read_spd(unsigned char *addr) {
; 0003 0077 unsigned char ds1820_read_spd(unsigned char *addr) {
_ds1820_read_spd:
; 0003 0078 	unsigned char i, *p;
; 0003 0079     unsigned char count = 0, result;
; 0003 007A     do {
	CALL __SAVELOCR5
;	*addr -> Y+5
;	i -> R16
;	*p -> R17,R18
;	count -> R19
;	result -> R20
	LDI  R19,0
_0x60027:
; 0003 007B         ds1820_select(addr);                	// Выбираем конкретный Dallas
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	CALL SUBOPT_0x79
; 0003 007C         w1_write(0xbe);							// Даем команду "Чтение памяти"
	LDI  R30,LOW(190)
	CALL SUBOPT_0x78
; 0003 007D         i = 0;
; 0003 007E         p = (char *) &__ds1820_scratch_pad;		// Устанавливаем указатель на ОЗУ текущего Dallas
	__POINTWRM 17,18,___ds1820_scratch_pad
; 0003 007F         do
_0x6002A:
; 0003 0080             *(p++)=w1_read();
	PUSH R18
	PUSH R17
	__ADDWRN 17,18,1
	CALL _w1_read
	POP  R26
	POP  R27
	ST   X,R30
; 0003 0081         while (++i<9);
	SUBI R16,-LOW(1)
	CPI  R16,9
	BRLO _0x6002A
; 0003 0082         // Сравнение контрольной суммы на 9-м байте с подсчитанным в ОЗУ. Если все в порядке, возвращаем ненулевое значение
; 0003 0083         result = !w1_dow_crc8(&__ds1820_scratch_pad,9);
	LDI  R30,LOW(___ds1820_scratch_pad)
	LDI  R31,HIGH(___ds1820_scratch_pad)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(9)
	ST   -Y,R30
	CALL _w1_dow_crc8
	CALL __LNEGB1
	MOV  R20,R30
; 0003 0084         count++;
	SUBI R19,-1
; 0003 0085     } while	((result == 0) && (count < 3));
	CPI  R20,0
	BRNE _0x6002C
	CPI  R19,3
	BRLO _0x6002D
_0x6002C:
	RJMP _0x60028
_0x6002D:
	RJMP _0x60027
_0x60028:
; 0003 0086     return result;
	MOV  R30,R20
	CALL __LOADLOCR5
	JMP  _0x20E000F
; 0003 0087 }
;// Функция загоняющая ScratchPAD в ОЗУ Dallas (3 байта)
;unsigned char ds1820_write_spd(unsigned char *addr) {
; 0003 0089 unsigned char ds1820_write_spd(unsigned char *addr) {
_ds1820_write_spd:
; 0003 008A 	register unsigned char i;
; 0003 008B 	unsigned char *p;
; 0003 008C 	if (ds1820_select(addr)==0) return 0;	// Выбираем конкретный Dallas
	CALL __SAVELOCR3
;	*addr -> Y+3
;	i -> R16
;	*p -> R17,R18
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	CALL SUBOPT_0x79
	CPI  R30,0
	BRNE _0x6002E
	LDI  R30,LOW(0)
	RJMP _0x20E0013
; 0003 008D     w1_write(0x4e);                         // Команда на запись в ОЗУ
_0x6002E:
	LDI  R30,LOW(78)
	CALL SUBOPT_0x78
; 0003 008E     i=0;
; 0003 008F     p=(char *) &__ds1820_scratch_pad.temp_high; // Устанавливаем указатель на 2-й бат структуры Th
	__POINTWRMN 17,18,___ds1820_scratch_pad,2
; 0003 0090     do
_0x60030:
; 0003 0091         w1_write(*(p++));
	__GETW2R 17,18
	__ADDWRN 17,18,1
	LD   R30,X
	ST   -Y,R30
	CALL _w1_write
; 0003 0092     while (++i<3);
	SUBI R16,-LOW(1)
	CPI  R16,3
	BRLO _0x60030
; 0003 0093     return 1;
	LDI  R30,LOW(1)
_0x20E0013:
	CALL __LOADLOCR3
_0x20E0014:
	ADIW R28,5
	RET
; 0003 0094 }
;// Функция, дающая команду на измерение заданного Dallas
;unsigned char ds1820_run_measure(unsigned char *addr) {
; 0003 0096 unsigned char ds1820_run_measure(unsigned char *addr) {
_ds1820_run_measure:
; 0003 0097 	if (ds1820_select(addr)==0) return 0;	// Выбираем конкретный Dallas
;	*addr -> Y+0
	LD   R30,Y
	LDD  R31,Y+1
	CALL SUBOPT_0x79
	CPI  R30,0
	BRNE _0x60032
	LDI  R30,LOW(0)
	RJMP _0x20E0012
; 0003 0098 	w1_write(0x44);
_0x60032:
	LDI  R30,LOW(68)
	ST   -Y,R30
	CALL _w1_write
; 0003 0099 	return w1_init();
	CALL _w1_init
_0x20E0012:
	ADIW R28,2
	RET
; 0003 009A }
;// Функция, снимающая показания температуры со ScratchPAD (ОЗУ) Dallas
;int ds1820_temperature(unsigned char *addr) {
; 0003 009C int ds1820_temperature(unsigned char *addr) {
_ds1820_temperature:
; 0003 009D     unsigned char values[16] = { 0,6,12,19,25,31,38,44,50,56,63,69,75,81,88,94 };
; 0003 009E     unsigned char fract;
; 0003 009F 	int t10;
; 0003 00A0     if (!ds1820_read_spd(addr)) return NOT_FOUND;         // Если безуспешно, то вовращаем -99.98 градусов
	SBIW R28,16
	LDI  R24,16
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x60033*2)
	LDI  R31,HIGH(_0x60033*2)
	CALL __INITLOCB
	CALL __SAVELOCR3
;	*addr -> Y+19
;	values -> Y+3
;	fract -> R16
;	t10 -> R17,R18
	LDD  R30,Y+19
	LDD  R31,Y+19+1
	CALL SUBOPT_0x7A
	BRNE _0x60034
	LDI  R30,LOW(55537)
	LDI  R31,HIGH(55537)
	RJMP _0x20E0011
; 0003 00A1     fract = __ds1820_scratch_pad.temp_lsb & 0xF;           // values[fract] = нашей дробной части
_0x60034:
	LDS  R30,___ds1820_scratch_pad
	ANDI R30,LOW(0xF)
	MOV  R16,R30
; 0003 00A2     t10 = __ds1820_scratch_pad.temp_msb;
	__GETBRMN 17,___ds1820_scratch_pad,1
	CLR  R18
; 0003 00A3 	t10 = (((t10 << 8) | __ds1820_scratch_pad.temp_lsb) >> 4) * 100;
	MOV  R31,R17
	LDI  R30,LOW(0)
	MOVW R26,R30
	LDS  R30,___ds1820_scratch_pad
	LDI  R31,0
	OR   R30,R26
	OR   R31,R27
	CALL __ASRW4
	LDI  R26,LOW(100)
	LDI  R27,HIGH(100)
	CALL __MULW12
	__PUTW1R 17,18
; 0003 00A4     t10 += values[fract];
	MOV  R30,R16
	LDI  R31,0
	MOVW R26,R28
	ADIW R26,3
	ADD  R26,R30
	ADC  R27,R31
	LD   R30,X
	LDI  R31,0
	__ADDWRR 17,18,30,31
; 0003 00A5 	return t10;
	__GETW1R 17,18
_0x20E0011:
	CALL __LOADLOCR3
	ADIW R28,21
	RET
; 0003 00A6 }
;/*
;int ds1820_temperature_debug(unsigned char *addr) {
;    unsigned char values[16] = { 0,6,12,19,25,31,38,44,50,56,63,69,75,81,88,94 };
;    unsigned char fract;
;	int t10;
;    if (!ds1820_read_spd(addr)) return NOT_FOUND;         // Если безуспешно, то вовращаем -99.98 градусов
;    fract = __ds1820_scratch_pad.temp_lsb & 0xF;           // values[fract] = нашей дробной части
;    t10 = __ds1820_scratch_pad.temp_msb;
;	t10 = (t10 << 8) | __ds1820_scratch_pad.temp_lsb;
;    #ifndef NODEBUG
;    printf("{ t10 = %i[%02X]; ", t10, t10);
;    #endif
;    t10 = (t10 >> 4) * 100; printf("t10 = %i[%02X]; ", t10, t10);
;    // t10 = t10 * 100 + values[fract];
;    t10 += values[fract]; printf("%i[%02X]; }", t10, t10);
;	return t10;
;}
;*/
;// Функция, снимающая показания температуры и сразу запускает новые измерения
;int ds1820_temperature_10(unsigned char *addr) {
; 0003 00BA int ds1820_temperature_10(unsigned char *addr) {
_ds1820_temperature_10:
; 0003 00BB 	int t10;									// текущее преобразованное значение
; 0003 00BC     t10 = ds1820_temperature(addr);
	ST   -Y,R17
	ST   -Y,R16
;	*addr -> Y+2
;	t10 -> R16,R17
	CALL SUBOPT_0x7B
	RCALL _ds1820_temperature
	MOVW R16,R30
; 0003 00BD 	(void) ds1820_run_measure(addr);
	CALL SUBOPT_0x7B
	RCALL _ds1820_run_measure
; 0003 00BE 	return t10;
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20E000E
; 0003 00BF }
;// Функция, снимающая показания температуры со ScratchPAD (ОЗУ) Dallas вместе с Th и Tl
;int ds1820_temperature_10lh(unsigned char *addr, signed char *temp_low, signed char *temp_high) {
; 0003 00C1 int ds1820_temperature_10lh(unsigned char *addr, signed char *temp_low, signed char *temp_high) {
; 0003 00C2 	int t10;									// текущее преобразованное значение
; 0003 00C3     t10 = ds1820_temperature(addr);
;	*addr -> Y+6
;	*temp_low -> Y+4
;	*temp_high -> Y+2
;	t10 -> R16,R17
; 0003 00C4     *temp_low = __ds1820_scratch_pad.temp_low;  // Вовращаем нижнюю границу Alarm
; 0003 00C5     *temp_high = __ds1820_scratch_pad.temp_high;// Возвращаем верхнюю границу Alarm
; 0003 00C6 	(void) ds1820_run_measure(addr);
; 0003 00C7 	return t10;
; 0003 00C8 }
;// Функция установки параметров ТН и ТL выбранного DALLAS
;unsigned char ds1820_set_alarm(unsigned char *addr, signed char temp_low, signed char temp_high) {
; 0003 00CA unsigned char ds1820_set_alarm(unsigned char *addr, signed char temp_low, signed char temp_high) {
_ds1820_set_alarm:
; 0003 00CB 	if (!ds1820_read_spd(addr)) return 0;
;	*addr -> Y+2
;	temp_low -> Y+1
;	temp_high -> Y+0
	CALL SUBOPT_0x7C
	BRNE _0x60035
	LDI  R30,LOW(0)
	JMP  _0x20E000E
; 0003 00CC     __ds1820_scratch_pad.temp_low = temp_low;
_0x60035:
	LDD  R30,Y+1
	__PUTB1MN ___ds1820_scratch_pad,3
; 0003 00CD     __ds1820_scratch_pad.temp_high = temp_high;
	LD   R30,Y
	__PUTB1MN ___ds1820_scratch_pad,2
; 0003 00CE     if (ds1820_write_spd(addr)==0) return 0;
	CALL SUBOPT_0x7B
	RCALL _ds1820_write_spd
	CPI  R30,0
	BRNE _0x60036
	LDI  R30,LOW(0)
	JMP  _0x20E000E
; 0003 00CF 	if (!ds1820_read_spd(addr)) return 0;
_0x60036:
	CALL SUBOPT_0x7C
	BRNE _0x60037
	LDI  R30,LOW(0)
	JMP  _0x20E000E
; 0003 00D0 	if ((__ds1820_scratch_pad.temp_low!=temp_low) || (__ds1820_scratch_pad.temp_high!=temp_high)) return 0;
_0x60037:
	__GETB2MN ___ds1820_scratch_pad,3
	LDD  R30,Y+1
	CP   R30,R26
	BRNE _0x60039
	__GETB2MN ___ds1820_scratch_pad,2
	LD   R30,Y
	CP   R30,R26
	BREQ _0x60038
_0x60039:
	LDI  R30,LOW(0)
	JMP  _0x20E000E
; 0003 00D1     if (ds1820_select(addr)==0) return 0;
_0x60038:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	CALL SUBOPT_0x79
	CPI  R30,0
	BRNE _0x6003B
	LDI  R30,LOW(0)
	JMP  _0x20E000E
; 0003 00D2 	w1_write(0x48);                             // Даем команду на запись в ПЗУ
_0x6003B:
	CALL SUBOPT_0x7D
; 0003 00D3 	delay_ms(15);
; 0003 00D4 	return w1_init();
	CALL _w1_init
	JMP  _0x20E000E
; 0003 00D5 }
;// Функция добавлена 12.03.2010
;// Функция, вычитывающая из указанного Dallas temp_high и temp_low
;// Возвращает в случае успешного чтения ненулевое значение
;// Функция чтения параметров ТН и ТL выбранного DALLAS
;signed char ds1820_get_alarm(unsigned char *addr, signed char *temp_low, signed char *temp_high) {
; 0003 00DA signed char ds1820_get_alarm(unsigned char *addr, signed char *temp_low, signed char *temp_high) {
_ds1820_get_alarm:
; 0003 00DB     if (!ds1820_read_spd(addr)) return -98;         // Если безуспешно, то вовращаем -99.98 градусов
;	*addr -> Y+4
;	*temp_low -> Y+2
;	*temp_high -> Y+0
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x7A
	BRNE _0x6003C
	LDI  R30,LOW(158)
	RJMP _0x20E0010
; 0003 00DC 	// if (ds1820_read_spd(addr)==0) return 0;     // Вычитываем ScratchPAD (ОЗУ) Dallas
; 0003 00DD     *temp_low = __ds1820_scratch_pad.temp_low;  // Вовращаем нижнюю границу Alarm
_0x6003C:
	__GETB1MN ___ds1820_scratch_pad,3
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ST   X,R30
; 0003 00DE     *temp_high = __ds1820_scratch_pad.temp_high;// Возвращаем верхнюю границу Alarm
	__GETB1MN ___ds1820_scratch_pad,2
	CALL SUBOPT_0x7E
; 0003 00DF     // print_scratch_pad();
; 0003 00E0     return 1;
_0x20E0010:
	ADIW R28,6
	RET
; 0003 00E1 }
;// Функция установки точности выбранного DALLAS
;unsigned char ds1820_set_resolution(unsigned char *addr, unsigned char resolution) {
; 0003 00E3 unsigned char ds1820_set_resolution(unsigned char *addr, unsigned char resolution) {
_ds1820_set_resolution:
; 0003 00E4     unsigned char temp_resolution;
; 0003 00E5     if (!ds1820_read_spd(addr)) return 0; // Вычитываем память выбранного DALLAS
	ST   -Y,R16
;	*addr -> Y+2
;	resolution -> Y+1
;	temp_resolution -> R16
	CALL SUBOPT_0x7C
	BRNE _0x6003D
	LDI  R30,LOW(0)
	LDD  R16,Y+0
	JMP  _0x20E000E
; 0003 00E6     temp_resolution = (resolution << 5) | 0x1F;
_0x6003D:
	LDD  R30,Y+1
	SWAP R30
	ANDI R30,0xF0
	LSL  R30
	ORI  R30,LOW(0x1F)
	MOV  R16,R30
; 0003 00E7     // temp_resolution = 0x7F;
; 0003 00E8     __ds1820_scratch_pad.conf = temp_resolution;
	__PUTBMRN ___ds1820_scratch_pad,4,16
; 0003 00E9     // print_scratch_pad();
; 0003 00EA     if (ds1820_write_spd(addr)==0) return 0;
	CALL SUBOPT_0x7B
	RCALL _ds1820_write_spd
	CPI  R30,0
	BRNE _0x6003E
	LDI  R30,LOW(0)
	LDD  R16,Y+0
	JMP  _0x20E000E
; 0003 00EB     ds1820_read_spd(addr);
_0x6003E:
	CALL SUBOPT_0x7B
	RCALL _ds1820_read_spd
; 0003 00EC     if (__ds1820_scratch_pad.conf!=temp_resolution) return 0;
	__GETB2MN ___ds1820_scratch_pad,4
	CP   R16,R26
	BREQ _0x6003F
	LDI  R30,LOW(0)
	LDD  R16,Y+0
	JMP  _0x20E000E
; 0003 00ED     // print_scratch_pad();
; 0003 00EE 	ds1820_select(addr);
_0x6003F:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	CALL SUBOPT_0x79
; 0003 00EF 	w1_write(0x48);             // Записываем в ПЗУ Dallas
	CALL SUBOPT_0x7D
; 0003 00F0 	delay_ms(15);
; 0003 00F1     return w1_init();
	CALL _w1_init
	LDD  R16,Y+0
	JMP  _0x20E000E
; 0003 00F2 }
;// Функция чтения параметров ТН и ТL выбранного DALLAS
;signed char ds1820_get_resolution(unsigned char *addr, unsigned char *resolution) {
; 0003 00F4 signed char ds1820_get_resolution(unsigned char *addr, unsigned char *resolution) {
_ds1820_get_resolution:
; 0003 00F5     if (!ds1820_read_spd(addr)) return -99;         // Если безуспешно, то вовращаем -99.98 градусов
;	*addr -> Y+2
;	*resolution -> Y+0
	CALL SUBOPT_0x7C
	BRNE _0x60040
	LDI  R30,LOW(157)
	JMP  _0x20E000E
; 0003 00F6 	// if (ds1820_read_spd(addr)==0) return 0;     // Вычитываем ScratchPAD (ОЗУ) Dallas
; 0003 00F7     // *resolution = __ds1820_scratch_pad.conf >> 5;  // Вовращаем resolution
; 0003 00F8     *resolution = __ds1820_scratch_pad.conf;  // Вовращаем resolution
_0x60040:
	__GETB1MN ___ds1820_scratch_pad,4
	CALL SUBOPT_0x7E
; 0003 00F9     // print_scratch_pad();
; 0003 00FA     return 1;
	JMP  _0x20E000E
; 0003 00FB }
;#include <mega32.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x80
	.EQU __sm_mask=0x70
	.EQU __sm_powerdown=0x20
	.EQU __sm_powersave=0x30
	.EQU __sm_standby=0x60
	.EQU __sm_ext_standby=0x70
	.EQU __sm_adc_noise_red=0x10
	.SET power_ctrl_reg=mcucr
	#endif
;#include <delay.h>
;#include "robowater.h"
;#include "valcoder.h"
;
;// byte valcoder0, valcoder1;      // Биты прерываний
;// word counter0, counter1;        // счетчик кол-ва прерываний от valcoder
;// int valcoder;                   // Направление вращения
;signed char valcoder;              // Направление вращения
;
;// Внешние прерывания Valcoder'а
;interrupt [EXT_INT0] void ext_int0_isr(void) {
; 0004 000C interrupt [2] void ext_int0_isr(void) {

	.CSEG
_ext_int0_isr:
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0004 000D     // counter0++;
; 0004 000E     // valcoder0 = 1;
; 0004 000F     // Проверяем, обработали ли прокрутку valcoder'а
; 0004 0010     // if (valcoder == VALCODER_NO_ROTATE) {
; 0004 0011     // Проверяем VALCODER_PIN1
; 0004 0012     if (VALCODER_PIN1) valcoder--; else valcoder++;
	SBIS 0x10,3
	RJMP _0x80003
	LDS  R30,_valcoder
	SUBI R30,LOW(1)
	RJMP _0x80005
_0x80003:
	LDS  R30,_valcoder
	SUBI R30,-LOW(1)
_0x80005:
	STS  _valcoder,R30
; 0004 0013     // }
; 0004 0014     // Устраняем дребезг прерывания
; 0004 0015     GIFR |= (1<<6);
	IN   R30,0x3A
	ORI  R30,0x40
	OUT  0x3A,R30
; 0004 0016     // Запрещаем прерывание INT0 (выставляем 0 в 6 бите)
; 0004 0017     GICR &= ~(1<<6);
	IN   R30,0x3B
	ANDI R30,0xBF
	RJMP _0x80006
; 0004 0018     // Ставим небольшую задержку
; 0004 0019     // delay_ms(VALCODER_INT_DELAY);
; 0004 001A }
;interrupt [EXT_INT1] void ext_int1_isr(void) {
; 0004 001B interrupt [3] void ext_int1_isr(void) {
_ext_int1_isr:
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0004 001C     // counter1++;
; 0004 001D     // valcoder1 = 1;
; 0004 001E     // Прежде чем разрешать прерывание, делаем небольшую задержку
; 0004 001F     // delay_ms(VALCODER_INT_DELAY);
; 0004 0020     // Разрешаем прерывание INT0 (выставляем 1 в 6 бите)
; 0004 0021     GICR |= (1<<6);
	IN   R30,0x3B
	ORI  R30,0x40
_0x80006:
	OUT  0x3B,R30
; 0004 0022     // GIFR |= (1<<7);
; 0004 0023 }
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	RETI
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;// DS1307 Real Time Clock functions
;#include <ds1307.h>
;#include <delay.h>
;
;#include "robowater.h"
;#include "menu.h"
;#include "spd1820.h"
;#include "alarm.h"
;#include "at2404.h"
;
;// Объявление макроподстановок
;// #define MENU_PARAMETERS 12
;
;// Структура основных переменных
;// extern struct st_prim_par prim_par;
;
;// signed char curr_menu_level1 = 0, next_menu_level1 = 1;  // Текущий и следующий пункт меню
;struct st_array_pos curr_menu;                // Позиции в меню
;struct st_array_pos dt_curr_menu;             // Здесь сохраняем главное меню во время входа в меню установки даты и времени
;// struct st_array_pos menu_level2;  // Позиции в меню второго уровня
;//    {1, e_clatsman, "ЗИМА "},              // [9] Режим обогрева (1 - зима, 0 -лето)
;struct st_parameter main_menu[NUM_MENU]= {   // Меню первого уровня
;    {-9900, e_temperature, 0, 1},     // [0]
;    {0, e_isfour, 1, 2},              // [1] Основной режим (00 - стоп, 01 - прогрев, 10 - остановка, 11 - пуск)
;    {1, e_winter, 0, 3},              // [2] ЗИМА
;    {0, e_dt, 1, 4},                  // [3] Установка даты и времени
;    {0, e_empty, 1, 5},               // [4] Вход в меню просмотра параметров
;    {0, e_alarm, 0, 6},               // [5] АВАРИЙ НЕТ
;    {0, e_empty, 0, 7}                // [6] Вход в меню тонких настроек
;};

	.DSEG
;
;struct st_parameter sdt[NUM_DT]= {   // Меню Установки времени и даты
;    {20, e_hour, 1, 8},             // [0]
;    {05, e_minute, 1, 9},           // [1]
;    {19, e_day, 1, 10},             // [2]
;    {03, e_month, 1, 11},           // [3]
;    {11, e_year, 1, 12},            // [4]
;    {0, e_winter, 1, 41},           // [5] ЗИМА
;    {0, e_password, 1, 42}          // [6]
;  };
;
;struct st_parameter parameters[NUM_PARAMETERS]= {
;    {2200, e_room, 1, 15},          // [0] Заданная температура воздуха TA_out_prs
;    {2000, e_temperature, 0, 13},   // [1] Температура воздуха в помещении
;    {-350, e_temperature, 0, 14},   // [2] Температура воздуха на улице
;    {7200, e_temperature, 0, 16},   // [3] Температура воды на входе
;    {6500, e_temperature, 0, 17},   // [4] Температура воды на выходе
;    {40, e_percent, 0, 18},         // [5] Текущее состояние крана (АЦП)
;    {42, e_percent, 1, 19},         // [6] Заданное состояние крана (расчетное PWM)
;    {95, e_percent, 0, 20},         // [7] Текущее состояние вентилятора (АЦП)
;    {100, e_percent, 1, 21},        // [8] Заданное состояние вентилятора (расчетное PWM)
;    {1, e_clatsman, 0, 22},         // [9] Положение воздушной заслонки (0 - открыта, 1 - закрыта)
;    {1, e_clatsman, 1, 23}          // [10] Работа насоса (1 - вкл., 0 - выкл.)
;};
;struct st_parameter settings[NUM_SETTINGS]={
;    {-2500, e_world, 1, 24},        // [0] температура воздуха мин TA_in_Min
;    {3500, e_water, 1, 25},         // [1] температура воды СТОП TW_out_Stop
;    {1000, e_water, 1, 26},         // [2] температура воды выход TW_out_Min
;    {1500, e_room, 1, 27},          // [3] температура воздуха мин TA_out_Min
;    {30, e_stime, 1, 28},           // [4] время прогрева T_z ?
;    {10, e_stime, 1, 29},           // [5] время интегрирования T_int
;    {1, e_coef, 1, 30},             // [6] Коэффициэнт усиления Ku
;    {0, e_coef, 1, 31},             // [7] Коэффициэнт Интегрирования Ki
;    {0, e_coef, 1, 32},             // [8] Коэффициэнт Дифференцирования Kd
;    {0, e_temperature, 1, 33},      // [9] Смещение Ta2
;    {0, e_scale, 1, 34},            // [10] Множитель Ta2
;    {0, e_temperature, 1, 35},      // [11] Смещение Ta1
;    {0, e_scale, 1, 36},            // [12] Множитель Ta1
;    {0, e_temperature, 1, 37},      // [13] Смещение Tw1
;    {0, e_scale, 1, 38},            // [14] Множитель Tw1
;    {0, e_temperature, 1, 39},      // [15] Смещение Tw2
;    {0, e_scale, 1, 40}             // [16] Множитель Tw2
;};
;#define ALERT_POS 61
;struct st_parameter alerts[MAX_ALERTS] = {
;    {0, e_alert, 0, ALERT_POS},
;    {0, e_alert, 0, ALERT_POS + 1},
;    {0, e_alert, 0, ALERT_POS + 2},
;    {0, e_alert, 0, ALERT_POS + 3},
;    {0, e_alert, 0, ALERT_POS + 4},
;    {0, e_alert, 0, ALERT_POS + 5},
;    {0, e_alert, 0, ALERT_POS + 6},
;    {0, e_alert, 0, ALERT_POS + 7},
;    {0, e_alert, 0, ALERT_POS + 8},
;    {0, e_alert, 0, ALERT_POS + 9},
;    {0, e_alert, 0, ALERT_POS + 10},
;    {0, e_alert, 0, ALERT_POS + 11}
;};
;flash lcd_str all_menu_str[] = {
;        "Помещение ",  // [0]
;        "РЕЖИМ ",      // [1]
;        "СЕЗОН ",      // [2]
;        "Уст. ",       // [3]
;        "Параметры ",  // [4]
;        "АВАРИЙ ",      // [5]
;        "НАСТРОЙКА...",    // [6]
;        "Уст.Час. ",   // [7]
;        "Уст Мин ",    // [8]
;        "Уст.день. ",  // [9]
;        "Уст Мес. ",   // [10]
;        "Уст ГОД. ",   // [11]
;        "ПОМЕЩ. ",     // [12]
;        "УЛ.Т ",       // [13]
;        "Уст.Т ",      // [14] TA_out_prs
;        "Вод ВХ. ",    // [15]
;        "Вод ВЫХ.",    // [16]
;        "КРАН ",       // [17]
;        "УСТ.КРАН. ",  // [18]
;        "ВЕНТИЛЯТОР ", // [19]
;        "Уст. ВЕНТ. ", // [20]
;        "ЗАСЛ. ",      // [21]
;        "НАСОС ",      // [22]
;        "TA IN Min ",  // [23] TA_in_Min
;        "TW STOP ",    // [24] TW_out_Stop
;        "TW Min ",     // [25] TW_out_Min
;        "TA Min ",     // [26] TA_out_Min
;        "ПРОГРЕВ ",    // [27] T_z
;        "ВР.ИНТ. ",     // [28] T_int
;        "КУ=",         // [29]
;        "КИ=",         // [30]
;        "КД=",         // [31]
;        "См.П.=",      // [32] 0xFE
;        "Шк.П.=",     // [33] 0xFE
;        "См.Ул.=",    // [34] 0xFD
;        "Шк.Ул.=",    // [35] 0xFD
;        "См.ВВх=",    // [36] 0xFC
;        "Шк.ВВх=",    // [37] 0xFC
;        "См.ВВых=",   // [38] 0xFB
;        "Шк.ВВых=",   // [39] 0xFB
;        "Сезон=",     // [40]
;        "Пароль="     // [41]
;
;    };
;char linestr[20];           // Строка для LCD
;bit need_eeprom_write;      // Флаг, если необходимо записать в EEPROM
;// Функция синхронизации структуры основных переменных
;void sync_set_par(byte sync) {
; 0005 008C void sync_set_par(byte sync) {

	.CSEG
_sync_set_par:
; 0005 008D     register byte i, j;
; 0005 008E     // Если входим в меню
; 0005 008F     if (sync == SYNC_TO_MENU) {
	ST   -Y,R17
	ST   -Y,R16
;	sync -> Y+2
;	i -> R16
;	j -> R17
	LDD  R26,Y+2
	CPI  R26,LOW(0x1)
	BREQ PC+3
	JMP _0xA0008
; 0005 0090         main_menu[2].val_data = prim_par.season;
	__POINTW2MN _main_menu,10
	__GETB1MN _prim_par,48
	CALL SUBOPT_0x3F
; 0005 0091         settings[0].val_data = prim_par.TA_in_Min;
	CALL SUBOPT_0x1B
	STS  _settings,R30
	STS  _settings+1,R31
; 0005 0092         settings[1].val_data = prim_par.TW_out_Stop;
	CALL SUBOPT_0x42
	__PUTW1MN _settings,5
; 0005 0093         settings[2].val_data = prim_par.TW_out_Min;
	__GETW1MN _prim_par,26
	__PUTW1MN _settings,10
; 0005 0094         settings[3].val_data = prim_par.TA_out_Min;
	__GETW1MN _prim_par,32
	__PUTW1MN _settings,15
; 0005 0095         settings[4].val_data = prim_par.T_z;
	CALL SUBOPT_0x2D
	__PUTW1MN _settings,20
; 0005 0096         settings[5].val_data = prim_par.T_int;
	__GETW1MN _prim_par,24
	__PUTW1MN _settings,25
; 0005 0097         settings[6].val_data = prim_par.Ku;
	CALL SUBOPT_0x54
	__PUTW1MN _settings,30
; 0005 0098         settings[7].val_data = prim_par.Ki;
	__GETW1MN _prim_par,18
	__PUTW1MN _settings,35
; 0005 0099         settings[8].val_data = prim_par.Kd;
	__GETW1MN _prim_par,20
	__PUTW1MN _settings,40
; 0005 009A         if (mode.run == 0) {
	__GETB1MN _mode,1
	CPI  R30,0
	BRNE _0xA0009
; 0005 009B             parameters[8].val_data = prim_par.fan_speed  ;
	CALL SUBOPT_0x1A
; 0005 009C         };
_0xA0009:
; 0005 009D         //parameters[8].val_data = fan_speed;
; 0005 009E         parameters[0].val_data = prim_par.TA_out_prs;
	CALL SUBOPT_0x3E
; 0005 009F         parameters[10].val_data = mode.pomp;
	CALL SUBOPT_0x40
; 0005 00A0         // printf("Чтени времени и даты \r\n");
; 0005 00A1         sdt[0].val_data = s_dt.cHH;
	LDS  R30,_s_dt
	LDI  R31,0
	STS  _sdt,R30
	STS  _sdt+1,R31
; 0005 00A2         sdt[1].val_data = s_dt.cMM;
	__POINTW2MN _sdt,5
	__GETB1MN _s_dt,1
	CALL SUBOPT_0x3F
; 0005 00A3         sdt[2].val_data = s_dt.cdd;
	__POINTW2MN _sdt,10
	__GETB1MN _s_dt,5
	CALL SUBOPT_0x3F
; 0005 00A4         sdt[3].val_data = s_dt.cmo;
	__POINTW2MN _sdt,15
	__GETB1MN _s_dt,4
	CALL SUBOPT_0x3F
; 0005 00A5         sdt[4].val_data = s_dt.cyy;
	__POINTW2MN _sdt,20
	__GETB1MN _s_dt,3
	CALL SUBOPT_0x3F
; 0005 00A6         SEASON = prim_par.season;
	__POINTW2MN _sdt,25
	__GETB1MN _prim_par,48
	CALL SUBOPT_0x3F
; 0005 00A7         for (i = 0; i < MAX_DS1820; i++) {
	LDI  R16,LOW(0)
_0xA000B:
	CPI  R16,4
	BRSH _0xA000C
; 0005 00A8             j = 2*i + 9;
	CALL SUBOPT_0x7F
; 0005 00A9             settings[j++].val_data = prim_par.elims[i].shift;
	MOV  R30,R17
	SUBI R17,-1
	LDI  R26,LOW(5)
	MUL  R30,R26
	MOVW R30,R0
	CALL SUBOPT_0x80
	SUBI R30,LOW(-_prim_par)
	SBCI R31,HIGH(-_prim_par)
	CALL SUBOPT_0x77
	ST   X+,R30
	ST   X,R31
; 0005 00AA             settings[j].val_data = (int)(prim_par.elims[i].scale);
	LDI  R26,LOW(5)
	MUL  R17,R26
	MOVW R30,R0
	CALL SUBOPT_0x80
	__ADDW1MN _prim_par,2
	LD   R30,Z
	LDI  R31,0
	SBRC R30,7
	SER  R31
	MOVW R26,R22
	ST   X+,R30
	ST   X,R31
; 0005 00AB         }
	SUBI R16,-1
	RJMP _0xA000B
_0xA000C:
; 0005 00AC     } else {
	RJMP _0xA000D
_0xA0008:
; 0005 00AD         if (mode.stop_sync_dt) {
	__GETB1MN _mode,5
	CPI  R30,0
	BRNE PC+3
	JMP _0xA000E
; 0005 00AE             if ((s_dt.cHH != sdt[0].val_data) || (s_dt.cMM != sdt[1].val_data)) {
	CALL SUBOPT_0x81
	LDS  R26,_s_dt
	CALL SUBOPT_0x82
	BRNE _0xA0010
	__GETB2MN _s_dt,1
	CALL SUBOPT_0x83
	CALL SUBOPT_0x82
	BREQ _0xA000F
_0xA0010:
; 0005 00AF                 s_dt.cHH = sdt[0].val_data;
	LDS  R30,_sdt
	STS  _s_dt,R30
; 0005 00B0                 s_dt.cMM = sdt[1].val_data;
	__GETB1MN _sdt,5
	__PUTB1MN _s_dt,1
; 0005 00B1                 s_dt.cSS = 0;
	LDI  R30,LOW(0)
	__PUTB1MN _s_dt,2
; 0005 00B2                 set_cur_dt();
	CALL _set_cur_dt
; 0005 00B3                 printf("Запись времени %02u:%02u:00\r\n",sdt[0].val_data, sdt[1].val_data);
	__POINTW1FN _0xA0000,0
	CALL SUBOPT_0x84
	CALL SUBOPT_0x83
	CALL SUBOPT_0x23
	CALL SUBOPT_0x24
; 0005 00B4                 printf("Дата %02u.%02u.20%02u\r\n", sdt[2].val_data, sdt[3].val_data, sdt[4].val_data);
	__POINTW1FN _0xA0000,30
	CALL SUBOPT_0x85
	CALL SUBOPT_0x86
	CALL SUBOPT_0x23
	CALL SUBOPT_0x87
	CALL SUBOPT_0x23
	CALL SUBOPT_0x12
; 0005 00B5             };
_0xA000F:
; 0005 00B6             if ((s_dt.cdd != sdt[2].val_data) || (s_dt.cmo != sdt[3].val_data) || (s_dt.cyy != sdt[4].val_data)) {
	__GETB2MN _s_dt,5
	__GETW1MN _sdt,10
	CALL SUBOPT_0x82
	BRNE _0xA0013
	__GETB2MN _s_dt,4
	CALL SUBOPT_0x86
	CALL SUBOPT_0x82
	BRNE _0xA0013
	__GETB2MN _s_dt,3
	CALL SUBOPT_0x87
	CALL SUBOPT_0x82
	BREQ _0xA0012
_0xA0013:
; 0005 00B7                 s_dt.cdd = sdt[2].val_data;
	__GETB1MN _sdt,10
	__PUTB1MN _s_dt,5
; 0005 00B8                 s_dt.cmo = sdt[3].val_data;
	__GETB1MN _sdt,15
	__PUTB1MN _s_dt,4
; 0005 00B9                 s_dt.cyy = sdt[4].val_data;
	__GETB1MN _sdt,20
	__PUTB1MN _s_dt,3
; 0005 00BA                 set_cur_dt();
	CALL _set_cur_dt
; 0005 00BB                 printf("Запись даты %02u.%02u.20%02u\r\n", sdt[2].val_data, sdt[3].val_data, sdt[4].val_data);
	__POINTW1FN _0xA0000,54
	CALL SUBOPT_0x85
	CALL SUBOPT_0x86
	CALL SUBOPT_0x23
	CALL SUBOPT_0x87
	CALL SUBOPT_0x23
	CALL SUBOPT_0x12
; 0005 00BC                 printf("Время %02u:%02u:00\r\n",sdt[0].val_data, sdt[1].val_data);
	__POINTW1FN _0xA0000,85
	CALL SUBOPT_0x84
	CALL SUBOPT_0x83
	CALL SUBOPT_0x23
	CALL SUBOPT_0x24
; 0005 00BD             };
_0xA0012:
; 0005 00BE         } else {
	RJMP _0xA0015
_0xA000E:
; 0005 00BF             // Проверяем каждый параметр и если он отличается от начального, то выставляем флаг необходимости записи в EEPROM
; 0005 00C0             for (i = 0; i < MAX_DS1820; i++) {
	LDI  R16,LOW(0)
_0xA0017:
	CPI  R16,4
	BRSH _0xA0018
; 0005 00C1                 j = 2*i + 9;
	CALL SUBOPT_0x7F
; 0005 00C2                 if (prim_par.elims[i].shift != settings[j].val_data) {
	LDI  R26,LOW(3)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_prim_par)
	SBCI R31,HIGH(-_prim_par)
	LD   R22,Z
	LDD  R23,Z+1
	CALL SUBOPT_0x88
	MOVW R26,R30
	CALL __GETW1P
	CP   R30,R22
	CPC  R31,R23
	BREQ _0xA0019
; 0005 00C3                     prim_par.elims[i].shift = settings[j].val_data; need_eeprom_write = 1;
	LDI  R26,LOW(3)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_prim_par)
	SBCI R31,HIGH(-_prim_par)
	MOVW R22,R30
	CALL SUBOPT_0x88
	CALL SUBOPT_0x77
	ST   X+,R30
	ST   X,R31
	SET
	BLD  R2,0
; 0005 00C4                 }
; 0005 00C5                 j++;
_0xA0019:
	SUBI R17,-1
; 0005 00C6                 if (prim_par.elims[i].scale != (signed char)settings[j].val_data) {
	LDI  R26,LOW(3)
	MUL  R16,R26
	MOVW R30,R0
	__ADDW1MN _prim_par,2
	LD   R22,Z
	CALL SUBOPT_0x88
	LD   R30,Z
	CP   R30,R22
	BREQ _0xA001A
; 0005 00C7                     prim_par.elims[i].scale = (signed char)settings[j].val_data; need_eeprom_write = 1;
	LDI  R26,LOW(3)
	MUL  R16,R26
	MOVW R30,R0
	__ADDW1MN _prim_par,2
	MOVW R22,R30
	CALL SUBOPT_0x88
	LD   R30,Z
	MOVW R26,R22
	ST   X,R30
	SET
	BLD  R2,0
; 0005 00C8                 }
; 0005 00C9             }
_0xA001A:
	SUBI R16,-1
	RJMP _0xA0017
_0xA0018:
; 0005 00CA             if (prim_par.TA_in_Min != settings[0].val_data) {
	__GETW2MN _prim_par,30
	LDS  R30,_settings
	LDS  R31,_settings+1
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA001B
; 0005 00CB                 prim_par.TA_in_Min = settings[0].val_data; need_eeprom_write = 1;
	__PUTW1MN _prim_par,30
	SET
	BLD  R2,0
; 0005 00CC             }
; 0005 00CD             if (prim_par.TW_out_Stop != settings[1].val_data) {
_0xA001B:
	__GETW2MN _prim_par,28
	__GETW1MN _settings,5
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA001C
; 0005 00CE                 prim_par.TW_out_Stop = settings[1].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,5
	__PUTW1MN _prim_par,28
	SET
	BLD  R2,0
; 0005 00CF             }
; 0005 00D0             if (prim_par.TW_out_Min != settings[2].val_data) {
_0xA001C:
	__GETW2MN _prim_par,26
	__GETW1MN _settings,10
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA001D
; 0005 00D1                 prim_par.TW_out_Min = settings[2].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,10
	__PUTW1MN _prim_par,26
	SET
	BLD  R2,0
; 0005 00D2             }
; 0005 00D3             if (prim_par.TA_out_Min != settings[3].val_data) {
_0xA001D:
	__GETW2MN _prim_par,32
	__GETW1MN _settings,15
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA001E
; 0005 00D4                 prim_par.TA_out_Min = settings[3].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,15
	__PUTW1MN _prim_par,32
	SET
	BLD  R2,0
; 0005 00D5             }
; 0005 00D6             if (prim_par.T_z != settings[4].val_data) {
_0xA001E:
	__GETW2MN _prim_par,22
	__GETW1MN _settings,20
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA001F
; 0005 00D7                 prim_par.T_z = settings[4].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,20
	__PUTW1MN _prim_par,22
	SET
	BLD  R2,0
; 0005 00D8             }
; 0005 00D9             if (prim_par.T_int != settings[5].val_data) {
_0xA001F:
	__GETW2MN _prim_par,24
	__GETW1MN _settings,25
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA0020
; 0005 00DA                 prim_par.T_int = settings[5].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,25
	__PUTW1MN _prim_par,24
	SET
	BLD  R2,0
; 0005 00DB             }
; 0005 00DC             if (prim_par.Ku != settings[6].val_data) {
_0xA0020:
	__GETW2MN _prim_par,16
	__GETW1MN _settings,30
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA0021
; 0005 00DD                 prim_par.Ku = settings[6].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,30
	__PUTW1MN _prim_par,16
	SET
	BLD  R2,0
; 0005 00DE             }
; 0005 00DF             if (prim_par.Ki != settings[7].val_data) {
_0xA0021:
	__GETW2MN _prim_par,18
	__GETW1MN _settings,35
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA0022
; 0005 00E0                 prim_par.Ki = settings[7].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,35
	__PUTW1MN _prim_par,18
	SET
	BLD  R2,0
; 0005 00E1             }
; 0005 00E2             if (prim_par.Kd != settings[8].val_data) {
_0xA0022:
	__GETW2MN _prim_par,20
	__GETW1MN _settings,40
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA0023
; 0005 00E3                 prim_par.Kd = settings[8].val_data; need_eeprom_write = 1;
	__GETW1MN _settings,40
	__PUTW1MN _prim_par,20
	SET
	BLD  R2,0
; 0005 00E4             }
; 0005 00E5             if (prim_par.TA_out_prs != parameters[0].val_data) {
_0xA0023:
	__GETW2MN _prim_par,34
	CALL SUBOPT_0x4D
	CP   R30,R26
	CPC  R31,R27
	BREQ _0xA0024
; 0005 00E6                 prim_par.TA_out_prs = parameters[0].val_data; need_eeprom_write = 1;
	CALL SUBOPT_0x4D
	__PUTW1MN _prim_par,34
	SET
	BLD  R2,0
; 0005 00E7             };
_0xA0024:
; 0005 00E8             if (mode.run == 0) {
	__GETB1MN _mode,1
	CPI  R30,0
	BRNE _0xA0025
; 0005 00E9             if (prim_par.fan_speed  != parameters[8].val_data) {
	__GETB2MN _prim_par,13
	CALL SUBOPT_0x4F
	CALL SUBOPT_0x82
	BREQ _0xA0026
; 0005 00EA                 if (parameters[8].val_data <= FAN_SPEED_MIN) parameters[8].val_data = FAN_SPEED_MIN;
	CALL SUBOPT_0x2F
	BRGE _0xA0027
	CALL SUBOPT_0x30
; 0005 00EB                     prim_par.fan_speed = parameters[8].val_data; need_eeprom_write = 1;
_0xA0027:
	__GETB1MN _parameters,40
	__PUTB1MN _prim_par,13
	SET
	BLD  R2,0
; 0005 00EC                 };
_0xA0026:
; 0005 00ED             };
_0xA0025:
; 0005 00EE             if (mode.pomp  != parameters[10].val_data) {
	__GETB2MN _mode,3
	__GETW1MN _parameters,50
	CALL SUBOPT_0x82
	BREQ _0xA0028
; 0005 00EF                 mode.pomp = parameters[10].val_data;
	__GETB1MN _parameters,50
	__PUTB1MN _mode,3
; 0005 00F0             };
_0xA0028:
; 0005 00F1             if (mode.run != main_menu[1].val_data) {
	__GETB2MN _mode,1
	__GETW1MN _main_menu,5
	CALL SUBOPT_0x82
	BREQ _0xA0029
; 0005 00F2                 mode.initrun = (unsigned char)main_menu[1].val_data + 4;
	__GETB1MN _main_menu,5
	SUBI R30,-LOW(4)
	__PUTB1MN _mode,2
; 0005 00F3             };
_0xA0029:
; 0005 00F4             for (i = 0; i < MAX_ALERTS; i++) {
	LDI  R16,LOW(0)
_0xA002B:
	CPI  R16,12
	BRSH _0xA002C
; 0005 00F5                 if (prim_par.alert_status[i] && (alerts[i].val_data == 0)) {
	CALL SUBOPT_0x61
	BREQ _0xA002E
	CALL SUBOPT_0x89
	BREQ _0xA002F
_0xA002E:
	RJMP _0xA002D
_0xA002F:
; 0005 00F6                  alarm_unreg (i);
	ST   -Y,R16
	RCALL _alarm_unreg
; 0005 00F7                  printf ("Удалили активную тревогу: %s\r\n", get_alert_str(i));
	__POINTW1FN _0xA0000,106
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R16
	CALL SUBOPT_0x38
; 0005 00F8                  read_all_terms(INIT_MODE);
	CALL SUBOPT_0x18
; 0005 00F9                  printf ("Инициализируем все термометры!\r\n");
	__POINTW1FN _0xA0000,137
	CALL SUBOPT_0x1
; 0005 00FA                  }
; 0005 00FB             }
_0xA002D:
	SUBI R16,-1
	RJMP _0xA002B
_0xA002C:
; 0005 00FC         };
_0xA0015:
; 0005 00FD         // Выставление сезона находится в меню установки часов. Необходимо принудительно записивать в eeprom
; 0005 00FE         if (prim_par.season != SEASON) {
	__GETB2MN _prim_par,48
	__GETW1MN _sdt,25
	CALL SUBOPT_0x82
	BREQ _0xA0030
; 0005 00FF             prim_par.season = SEASON; need_eeprom_write = 1;
	__GETB1MN _sdt,25
	__PUTB1MN _prim_par,48
	SET
	BLD  R2,0
; 0005 0100             SEASON_MAIN = SEASON;
	__GETW1MN _sdt,25
	__PUTW1MN _main_menu,10
; 0005 0101         }
; 0005 0102      };
_0xA0030:
_0xA000D:
; 0005 0103 }
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E000D
;// Функция, которая возвращает строку со строковым названием параметра, и его числовым значением
;// Аргументы - номер элемента массива и указатель на массив
;// Возврат - указатель на строку linestr
;char *param_str(byte num_line, struct st_parameter parameter[]) {
; 0005 0107 char *param_str(byte num_line, struct st_parameter parameter[]) {
_param_str:
; 0005 0108     int pr_data;
; 0005 0109     struct st_parameter *st_pointer;
; 0005 010A     st_pointer = &parameter[num_line];          // Передаем конкретный указатель на структуру текущего элемента массива
	CALL __SAVELOCR4
;	num_line -> Y+6
;	parameter -> Y+4
;	pr_data -> R16,R17
;	*st_pointer -> R18,R19
	LDD  R30,Y+6
	LDI  R31,0
	__GETWRS 22,23,4
	CALL SUBOPT_0x8A
	ADD  R30,R22
	ADC  R31,R23
	MOVW R18,R30
; 0005 010B     pr_data = st_pointer->val_data;
	MOVW R26,R18
	LD   R16,X+
	LD   R17,X
; 0005 010C     /* struct st_parameter *pnt; pnt = parameter + num_line; */
; 0005 010D     return (par_str(st_pointer, 0, pr_data));
	ST   -Y,R19
	ST   -Y,R18
	LDI  R30,LOW(0)
	ST   -Y,R30
	ST   -Y,R17
	ST   -Y,R16
	RCALL _par_str
	CALL __LOADLOCR4
_0x20E000F:
	ADIW R28,7
	RET
; 0005 010E }
;// Универсальная функция возвращающая строку с преобразованным типовым значением.
;// 1) Аргумент - указатель на структуру параметра
;// 2) Флаг - признак вывода только значения. (0 - выводить строковое название, 1 - не выводить строковое название)
;// 3) Данные, которые нужно подставить
;// Возврат - указатель на строку linestr
;char *par_str(struct st_parameter *st_pointer, unsigned char only_val, int pr_data) {
; 0005 0114 char *par_str(struct st_parameter *st_pointer, unsigned char only_val, int pr_data) {
_par_str:
; 0005 0115     char *pr_name;
; 0005 0116     char prompt[] = "=> ";
; 0005 0117     unsigned char sign = (pr_data < 0) ? '-' : '+';
; 0005 0118     if (only_val) pr_name = prompt; else pr_name = getmenustr(st_pointer->str_num);
	SBIW R28,4
	LDI  R30,LOW(61)
	ST   Y,R30
	LDI  R30,LOW(62)
	STD  Y+1,R30
	LDI  R30,LOW(32)
	STD  Y+2,R30
	LDI  R30,LOW(0)
	STD  Y+3,R30
	CALL __SAVELOCR3
;	*st_pointer -> Y+10
;	only_val -> Y+9
;	pr_data -> Y+7
;	*pr_name -> R16,R17
;	prompt -> Y+3
;	sign -> R18
	LDD  R26,Y+8
	TST  R26
	BRPL _0xA0031
	LDI  R30,LOW(45)
	RJMP _0xA0032
_0xA0031:
	LDI  R30,LOW(43)
_0xA0032:
	MOV  R18,R30
	LDD  R30,Y+9
	CPI  R30,0
	BREQ _0xA0034
	MOVW R30,R28
	ADIW R30,3
	RJMP _0xA00DA
_0xA0034:
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	LDD  R26,Z+4
	ST   -Y,R26
	RCALL _getmenustr
_0xA00DA:
	MOVW R16,R30
; 0005 0119     switch (st_pointer->val_type) {
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	ADIW R26,2
	LD   R30,X
; 0005 011A         case e_empty:
	CPI  R30,0
	BRNE _0xA0039
; 0005 011B             sprintf(linestr, "%s", pr_name);
	CALL SUBOPT_0x65
	CALL SUBOPT_0x8B
	CALL SUBOPT_0x8C
; 0005 011C             break;
	RJMP _0xA0038
; 0005 011D         case e_clatsman:
_0xA0039:
	CPI  R30,LOW(0x1)
	BRNE _0xA003A
; 0005 011E             // Если указан тип клацман, то печатаем со словом ВКЛ. или Выкл.
; 0005 011F             if(pr_data)
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	SBIW R30,0
	BREQ _0xA003B
; 0005 0120                 sprintf(linestr, "%sВКЛ.", pr_name);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,173
	RJMP _0xA00DB
; 0005 0121             else
_0xA003B:
; 0005 0122                 sprintf(linestr, "%sВыкл.", pr_name);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,180
_0xA00DB:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R16
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x8C
; 0005 0123             break;
	RJMP _0xA0038
; 0005 0124         case e_percent:
_0xA003A:
	CPI  R30,LOW(0x4)
	BRNE _0xA003D
; 0005 0125             // Если указан тип проценты, то печатаем как проценты
; 0005 0126             sprintf(linestr, "%s%u%%", pr_name, (pr_data*100)/0xFF);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,188
	CALL SUBOPT_0x8D
	LDD  R26,Y+15
	LDD  R27,Y+15+1
	LDI  R30,LOW(100)
	LDI  R31,HIGH(100)
	CALL SUBOPT_0x55
	CALL SUBOPT_0x8E
; 0005 0127             //sprintf(linestr, "%s%u%%", pr_name, pr_data);
; 0005 0128             break;
	RJMP _0xA0038
; 0005 0129         case e_coef:
_0xA003D:
	CPI  R30,LOW(0x9)
	BRNE _0xA003E
; 0005 012A             // Если указан тип коэффициент, то печатаем как просто число
; 0005 012B             sprintf(linestr, "%s%u", pr_name, pr_data);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,195
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 012C             break;
	RJMP _0xA0038
; 0005 012D         case e_scale:
_0xA003E:
	CPI  R30,LOW(0xA)
	BRNE _0xA003F
; 0005 012E             // Если указан тип шкалы, то печатаем как знаковый байт (-128..127)
; 0005 012F             sprintf(linestr, "%s%d", pr_name, pr_data);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,200
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 0130             break;
	RJMP _0xA0038
; 0005 0131         case e_isfour:
_0xA003F:
	CPI  R30,LOW(0x3)
	BRNE _0xA0040
; 0005 0132             main_menu[1].val_data = mode.run;
	__POINTW2MN _main_menu,5
	__GETB1MN _mode,1
	CALL SUBOPT_0x3F
; 0005 0133             // Если указан тип режим, то печатаем со словами (00 - стоп, 01 - прогрев, 10 - остановка, 11 - пуск)
; 0005 0134             switch (pr_data) {
	LDD  R30,Y+7
	LDD  R31,Y+7+1
; 0005 0135                 case 0: sprintf(linestr, "%sСТОП", pr_name);  break;   //mode.run=0 ;
	SBIW R30,0
	BRNE _0xA0044
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,205
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8C
	RJMP _0xA0043
; 0005 0136                 case 1: sprintf(linestr, "%sПРОГРЕВ", pr_name); break; //mode.run=1;
_0xA0044:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0xA0045
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,212
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8C
	RJMP _0xA0043
; 0005 0137                 case 2: sprintf(linestr, "%sОСТАНОВ", pr_name); break; //mode.run=2 ;
_0xA0045:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0xA0046
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,222
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8C
	RJMP _0xA0043
; 0005 0138                 case 3: sprintf(linestr, "%sПУСК", pr_name);  ; break; //mode.run=3
_0xA0046:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0xA0048
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,232
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8C
; 0005 0139                 default: break;
_0xA0048:
; 0005 013A             };
_0xA0043:
; 0005 013B             break;
	RJMP _0xA0038
; 0005 013C         case e_password:
_0xA0040:
	CPI  R30,LOW(0x18)
	BRNE _0xA0049
; 0005 013D             // Если указан признак ввода пароля, то просто указываем несколько символов '**'
; 0005 013E             if (only_val) sprintf(linestr, "%s%u", pr_name, pr_data);
	LDD  R30,Y+9
	CPI  R30,0
	BREQ _0xA004A
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,195
	RJMP _0xA00DC
; 0005 013F             else sprintf(linestr, "%s **", pr_name, pr_data);
_0xA004A:
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,239
_0xA00DC:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R16
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 0140             break;
	RJMP _0xA0038
; 0005 0141         case e_alarm:
_0xA0049:
	CPI  R30,LOW(0x16)
	BRNE _0xA004C
; 0005 0142             // Если указан признак аварий, то выводим либо слово нет, либо количество аварий и '!'
; 0005 0143             if (pr_data) sprintf(linestr, "%s%u!", pr_name, pr_data);
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	SBIW R30,0
	BREQ _0xA004D
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,245
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 0144             else sprintf(linestr, "%sНЕТ", pr_name);
	RJMP _0xA004E
_0xA004D:
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,251
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8C
; 0005 0145             break;
_0xA004E:
	RJMP _0xA0038
; 0005 0146         case e_alert:
_0xA004C:
	CPI  R30,LOW(0x17)
	BRNE _0xA004F
; 0005 0147             if (pr_data) sprintf(linestr, "%s%u!", pr_name, pr_data);
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	SBIW R30,0
	BREQ _0xA0050
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,245
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 0148             else sprintf(linestr, "%s", pr_name);
	RJMP _0xA0051
_0xA0050:
	CALL SUBOPT_0x65
	CALL SUBOPT_0x8B
	CALL SUBOPT_0x8C
; 0005 0149             break;
_0xA0051:
	RJMP _0xA0038
; 0005 014A         case e_winter:
_0xA004F:
	CPI  R30,LOW(0x2)
	BRNE _0xA0052
; 0005 014B             // Если указан сезона, то выводим ЗИМА/ЛЕТО
; 0005 014C             if (pr_data)
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	SBIW R30,0
	BREQ _0xA0053
; 0005 014D                 sprintf(linestr, "%sЗИМА", pr_name);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,257
	RJMP _0xA00DD
; 0005 014E             else
_0xA0053:
; 0005 014F                 sprintf(linestr, "%sЛЕТО", pr_name);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,264
_0xA00DD:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R16
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x8C
; 0005 0150             break;
	RJMP _0xA0038
; 0005 0151         case e_time:
_0xA0052:
	CPI  R30,LOW(0x13)
	BRNE _0xA0055
; 0005 0152             // Если указан тип время, то выбираем из структуры времени и печатаем как чч.мм.сс
; 0005 0153             sprintf(linestr, "%s%02u:%02u", pr_name, s_dt.cHH, s_dt.cMM);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,271
	CALL SUBOPT_0x8D
	LDS  R30,_s_dt
	CALL SUBOPT_0x28
	CALL SUBOPT_0x59
	LDI  R24,12
	CALL _sprintf
	ADIW R28,16
; 0005 0154             break;
	RJMP _0xA0038
; 0005 0155         case e_date:
_0xA0055:
	CPI  R30,LOW(0x14)
	BRNE _0xA0056
; 0005 0156             // Если указан тип дата, то выбираем из структуры даты и печатаем как дд.мм.гг
; 0005 0157             sprintf(linestr, "%s%02u.%02u.%02u", pr_name, s_dt.cdd, s_dt.cmo, s_dt.cyy);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,283
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x66
	CALL SUBOPT_0x67
	__GETB1MN _s_dt,3
	CALL SUBOPT_0x28
	CALL SUBOPT_0x6A
; 0005 0158             break;
	RJMP _0xA0038
; 0005 0159         case e_dt:
_0xA0056:
	CPI  R30,LOW(0x12)
	BRNE _0xA0057
; 0005 015A             sprintf(linestr, "%s Вр./Дат.", pr_name);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,300
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8C
; 0005 015B             break;
	RJMP _0xA0038
; 0005 015C         case e_stime:
_0xA0057:
	CPI  R30,LOW(0xB)
	BRNE _0xA0058
; 0005 015D             // Если указан тип дата, то выбираем из структуры даты и печатаем как дд.мм.гг
; 0005 015E             sprintf(linestr, "%s%03u", pr_name, pr_data);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,312
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 015F             break;
	RJMP _0xA0038
; 0005 0160         case e_temperature:
_0xA0058:
	CPI  R30,LOW(0x5)
	BREQ _0xA005A
; 0005 0161         case e_room:
	CPI  R30,LOW(0x6)
	BRNE _0xA005B
_0xA005A:
; 0005 0162         case e_world:
	RJMP _0xA005C
_0xA005B:
	CPI  R30,LOW(0x7)
	BRNE _0xA005D
_0xA005C:
; 0005 0163         case e_water:
	RJMP _0xA005E
_0xA005D:
	CPI  R30,LOW(0x8)
	BRNE _0xA005F
_0xA005E:
; 0005 0164             // Если указан тип температуры, то печатаем как температуру
; 0005 0165             sprintf(linestr, "%s%c%u.%-01uC", pr_name, sign, abs(pr_data)/100, abs(pr_data%100)/10);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,319
	CALL SUBOPT_0x8D
	MOV  R30,R18
	CALL SUBOPT_0x28
	LDD  R30,Y+19
	LDD  R31,Y+19+1
	CALL SUBOPT_0x1C
	MOVW R26,R30
	LDI  R30,LOW(100)
	LDI  R31,HIGH(100)
	CALL SUBOPT_0x69
	LDD  R26,Y+23
	LDD  R27,Y+23+1
	CALL SUBOPT_0x5C
	MOVW R26,R30
	LDI  R30,LOW(10)
	LDI  R31,HIGH(10)
	CALL SUBOPT_0x69
	CALL SUBOPT_0x6A
; 0005 0166             break;
	RJMP _0xA0038
; 0005 0167         case e_hour:
_0xA005F:
	CPI  R30,LOW(0xE)
	BREQ _0xA0061
; 0005 0168         case e_minute:
	CPI  R30,LOW(0xD)
	BRNE _0xA0062
_0xA0061:
; 0005 0169         case e_day:
	RJMP _0xA0063
_0xA0062:
	CPI  R30,LOW(0xF)
	BRNE _0xA0064
_0xA0063:
; 0005 016A         case e_month:
	RJMP _0xA0065
_0xA0064:
	CPI  R30,LOW(0x10)
	BRNE _0xA0066
_0xA0065:
; 0005 016B             // Если указан тип [часы, минуты, день, месяц], то печатаем как есть
; 0005 016C             sprintf(linestr, "%s%u", pr_name, pr_data);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,195
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 016D             break;
	RJMP _0xA0038
; 0005 016E         case e_year:
_0xA0066:
	CPI  R30,LOW(0x11)
	BRNE _0xA0068
; 0005 016F             // Если указан тип год, то печатаем как есть с тысячелетием
; 0005 0170             sprintf(linestr, "%s20%u", pr_name, pr_data);
	CALL SUBOPT_0x65
	__POINTW1FN _0xA0000,333
	CALL SUBOPT_0x8D
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x8E
; 0005 0171             break;
	RJMP _0xA0038
; 0005 0172         default:
_0xA0068:
; 0005 0173             linestr[0] = 0;
	LDI  R30,LOW(0)
	STS  _linestr,R30
; 0005 0174     };
_0xA0038:
; 0005 0175     return(linestr);
	LDI  R30,LOW(_linestr)
	LDI  R31,HIGH(_linestr)
	CALL __LOADLOCR3
	ADIW R28,12
	RET
; 0005 0176 }
;// Функция, инициализирующая menu_level1
;void init_curr_menu(struct st_parameter *lmenu, unsigned char lmax) {
; 0005 0178 void init_curr_menu(struct st_parameter *lmenu, unsigned char lmax) {
_init_curr_menu:
; 0005 0179     curr_menu.line0 = 0; curr_menu.line1 = 1;
;	*lmenu -> Y+1
;	lmax -> Y+0
	LDI  R30,LOW(0)
	STS  _curr_menu,R30
	LDI  R30,LOW(1)
	__PUTB1MN _curr_menu,1
; 0005 017A 
; 0005 017B     // curr_menu.menu = &main_menu[0];         // Текущий указатель устанавливаем на главное меню
; 0005 017C     curr_menu.menu = lmenu;         // Текущий указатель устанавливаем на главное меню
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	__PUTW1MN _curr_menu,3
; 0005 017D     // curr_menu.maximum = MENU_LEVEL1;
; 0005 017E     curr_menu.maximum = lmax;
	LD   R30,Y
	__PUTB1MN _curr_menu,5
; 0005 017F     curr_menu.lcd = 0; // curr_menu.value = lmenu->val_data;
	LDI  R30,LOW(0)
	__PUTB1MN _curr_menu,2
; 0005 0180 }
	RJMP _0x20E000D
;/* void set_curr_line(unsigned char line) {
;//     curr_menu.lcd = line;
;//}
;// unsigned char get_curr_line(void) {
;//    return curr_menu.lcd;
;//}
;*/
;// Функция, модифицирующая структуру содержащую указатели на текущий и следующий элемент. direction - (-1, 0, 1)
;void calc_pos(struct st_array_pos *array_pos, byte maxlines, signed char direction) {
; 0005 0189 void calc_pos(struct st_array_pos *array_pos, byte maxlines, signed char direction) {
_calc_pos:
; 0005 018A     // Увеличиваем или уменьшаем текущий элемент массива строк
; 0005 018B     // array_pos->line0 = array_pos->line0 + direction;
; 0005 018C     array_pos->line0 += direction;      // выборка элемента структуры по адресу array_pos
;	*array_pos -> Y+2
;	maxlines -> Y+1
;	direction -> Y+0
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	MOV  R0,R26
	LD   R30,X
	LD   R26,Y
	ADD  R30,R26
	MOV  R26,R0
	ST   X,R30
; 0005 018D     // Начинаем проверки на укладываемость в диапазоне
; 0005 018E     if (array_pos->line0 >= maxlines) array_pos->line0 = 0;
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LD   R26,X
	LDD  R30,Y+1
	CALL SUBOPT_0x6D
	CP   R26,R30
	CPC  R27,R31
	BRLT _0xA0069
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(0)
	ST   X,R30
; 0005 018F     if (array_pos->line0 < 0) { array_pos->line0 = maxlines - 1; array_pos->line1 = 0; return; }
_0xA0069:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LD   R26,X
	CPI  R26,0
	BRGE _0xA006A
	LDD  R30,Y+1
	SUBI R30,LOW(1)
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ST   X,R30
	ADIW R26,1
	LDI  R30,LOW(0)
	ST   X,R30
	RJMP _0x20E000E
; 0005 0190     // Анализируем то, что мы будем возвращать
; 0005 0191     if ((array_pos->line0 + 1) == maxlines) array_pos->line1 = 0; else array_pos->line1 = array_pos->line0 + 1;
_0xA006A:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LD   R30,X
	SUBI R30,-LOW(1)
	MOV  R26,R30
	LDD  R30,Y+1
	CALL SUBOPT_0x6D
	CP   R30,R26
	CPC  R31,R27
	BRNE _0xA006B
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,1
	LDI  R30,LOW(0)
	ST   X,R30
	RJMP _0xA006C
_0xA006B:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LD   R30,X
	SUBI R30,-LOW(1)
	__PUTB1SNS 2,1
; 0005 0192 }
_0xA006C:
_0x20E000E:
	ADIW R28,4
	RET
;// Функция вывода текущего и следующего пункта меню
;void lcd_menu(signed char direction) {
; 0005 0194 void lcd_menu(signed char direction) {
_lcd_menu:
; 0005 0195     // printf ("Syncing...\r\n");
; 0005 0196 
; 0005 0197     // Если valcoder крутится вправо и курсор был на 1 линии, то ставим ему признак перевода на 2 линию
; 0005 0198     if ((curr_menu.lcd == 0) && (direction > 0))    // Анализируем, где находится курсор и куда крутим valcoder
;	direction -> Y+0
	__GETB2MN _curr_menu,2
	CPI  R26,LOW(0x0)
	BRNE _0xA006E
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRGE _0xA006F
_0xA006E:
	RJMP _0xA006D
_0xA006F:
; 0005 0199         curr_menu.lcd = 1;
	LDI  R30,LOW(1)
	__PUTB1MN _curr_menu,2
; 0005 019A     else
	RJMP _0xA0070
_0xA006D:
; 0005 019B         // Если valcoder крутится влево и курсор был на 2 линии, то ставим ему признак перевода на 1 линию
; 0005 019C         if ((curr_menu.lcd == 1) && (direction < 0))
	__GETB2MN _curr_menu,2
	CPI  R26,LOW(0x1)
	BRNE _0xA0072
	LD   R26,Y
	CPI  R26,0
	BRLT _0xA0073
_0xA0072:
	RJMP _0xA0071
_0xA0073:
; 0005 019D            curr_menu.lcd = 0;
	LDI  R30,LOW(0)
	__PUTB1MN _curr_menu,2
; 0005 019E         else
	RJMP _0xA0074
_0xA0071:
; 0005 019F             // Если направление отличается от нуля, то модифицируем текущие пункты меню
; 0005 01A0             if (direction) calc_pos(&curr_menu, curr_menu.maximum, direction);
	LD   R30,Y
	CPI  R30,0
	BREQ _0xA0075
	LDI  R30,LOW(_curr_menu)
	LDI  R31,HIGH(_curr_menu)
	ST   -Y,R31
	ST   -Y,R30
	__GETB1MN _curr_menu,5
	ST   -Y,R30
	LDD  R30,Y+3
	ST   -Y,R30
	RCALL _calc_pos
; 0005 01A1     // printf("LCDLine=%u, dir=%u, line0=%u, line1=%u\r\n", curr_menu.lcd, direction, curr_menu.line0, curr_menu.line1);
; 0005 01A2     lcd_gotoxy(0,0);        // Устанавливаем курсор в позицию 0 строки 0
_0xA0075:
_0xA0074:
_0xA0070:
	CALL SUBOPT_0x64
; 0005 01A3     lcd_line_menu(param_str(curr_menu.line0, curr_menu.menu), curr_menu.menu[curr_menu.line0].can_edit);
	LDS  R30,_curr_menu
	CALL SUBOPT_0x90
	CALL SUBOPT_0x91
	LDS  R30,_curr_menu
	CALL SUBOPT_0x74
	CALL SUBOPT_0x8A
	CALL SUBOPT_0x92
; 0005 01A4     lcd_gotoxy(0,1);        // Устанавливаем курсор в позицию 0 строки 1
	CALL SUBOPT_0x7
	CALL _lcd_gotoxy
; 0005 01A5     lcd_line_menu(param_str(curr_menu.line1, curr_menu.menu), curr_menu.menu[curr_menu.line1].can_edit);
	__GETB1MN _curr_menu,1
	CALL SUBOPT_0x90
	CALL SUBOPT_0x91
	__GETB1MN _curr_menu,1
	CALL SUBOPT_0x74
	CALL SUBOPT_0x8A
	CALL SUBOPT_0x92
; 0005 01A6     // Устанавливаем курсор в ту строку, на которую указывает флага curr_menu.lcd
; 0005 01A7     if (curr_menu.lcd) lcd_gotoxy(LCD_DISP_LENGTH-1,1); else lcd_gotoxy(LCD_DISP_LENGTH-1,0);
	__GETB1MN _curr_menu,2
	CPI  R30,0
	BREQ _0xA0076
	LDI  R30,LOW(15)
	ST   -Y,R30
	LDI  R30,LOW(1)
	RJMP _0xA00DE
_0xA0076:
	LDI  R30,LOW(15)
	ST   -Y,R30
	LDI  R30,LOW(0)
_0xA00DE:
	ST   -Y,R30
	CALL _lcd_gotoxy
; 0005 01A8     // Даем команду на моргание курсором
; 0005 01A9     lcd_command(LCD_DISP_ON_CURSOR_BLINK);
	LDI  R30,LOW(15)
	ST   -Y,R30
	CALL _lcd_command
; 0005 01AA }
	ADIW R28,1
	RET
;// Функция, инициализирующая режим редактирования
;void lcd_init_edit(void) {
; 0005 01AC void lcd_init_edit(void) {
_lcd_init_edit:
; 0005 01AD     struct st_parameter *lmenu;     // Временная переменная, которая будет ссылаться на выбранный элемент меню
; 0005 01AE     byte num_line;                  // Временная переменная, содержащая текущий элемент меню
; 0005 01AF     // Устанавливаем указатель на параметры в зависимости от строки дисплея
; 0005 01B0     if (curr_menu.lcd) num_line = curr_menu.line1; else num_line = curr_menu.line0;
	CALL SUBOPT_0x93
;	*lmenu -> R16,R17
;	num_line -> R18
	BREQ _0xA0078
	__GETBRMN 18,_curr_menu,1
	RJMP _0xA0079
_0xA0078:
	LDS  R18,_curr_menu
; 0005 01B1     // Если сейчас нулевой уровень меню и выбранная позиция num_line > 4
; 0005 01B2     if ((curr_menu.level == 0) && (num_line >= 3)) {
_0xA0079:
	__GETB2MN _curr_menu,10
	CPI  R26,LOW(0x0)
	BRNE _0xA007B
	CPI  R18,3
	BRSH _0xA007C
_0xA007B:
	RJMP _0xA007A
_0xA007C:
; 0005 01B3         sync_set_par(SYNC_TO_MENU); // Синхронизируем меню с глобальными структурами
	CALL SUBOPT_0x19
; 0005 01B4         switch (num_line) {
	MOV  R30,R18
; 0005 01B5             case 3:
	CPI  R30,LOW(0x3)
	BRNE _0xA0080
; 0005 01B6                     dt_curr_menu = curr_menu;
	LDI  R30,LOW(_curr_menu)
	LDI  R31,HIGH(_curr_menu)
	LDI  R26,LOW(_dt_curr_menu)
	LDI  R27,HIGH(_dt_curr_menu)
	LDI  R24,11
	CALL __COPYMML
; 0005 01B7                     init_curr_menu(&sdt[0], NUM_DT);
	LDI  R30,LOW(_sdt)
	LDI  R31,HIGH(_sdt)
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xD
; 0005 01B8                     curr_menu.level = 1; // printf("Вход в меню установки даты и времени\r\n");
	LDI  R30,LOW(1)
	__PUTB1MN _curr_menu,10
; 0005 01B9                     mode.stop_sync_dt = 1;
	__PUTB1MN _mode,5
; 0005 01BA                     // sync_set_taym(SYNC_TO_MENU);
; 0005 01BB                     break;
	RJMP _0xA007F
; 0005 01BC             case 4: init_curr_menu(&parameters[0], NUM_PARAMETERS);
_0xA0080:
	CPI  R30,LOW(0x4)
	BRNE _0xA0081
	LDI  R30,LOW(_parameters)
	LDI  R31,HIGH(_parameters)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(11)
	CALL SUBOPT_0x94
; 0005 01BD                     curr_menu.level = 1; // printf("Вход в меню ПАРАМЕТРЫ\r\n");
; 0005 01BE                     break;
	RJMP _0xA007F
; 0005 01BF             case 5:
_0xA0081:
	CPI  R30,LOW(0x5)
	BRNE _0xA0082
; 0005 01C0                     if (IS_ALERT) {
	__GETB1MN _main_menu,28
	CPI  R30,0
	BREQ _0xA0083
; 0005 01C1                         init_curr_menu(&alerts[0], MAX_ALERTS);
	LDI  R30,LOW(_alerts)
	LDI  R31,HIGH(_alerts)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(12)
	CALL SUBOPT_0x94
; 0005 01C2                         curr_menu.level = 1; // printf("Вход в меню ALERTS\r\n");
; 0005 01C3                     }
; 0005 01C4                     break;
_0xA0083:
	RJMP _0xA007F
; 0005 01C5             case 6:
_0xA0082:
	CPI  R30,LOW(0x6)
	BRNE _0xA0086
; 0005 01C6                     if (SETTINGS_OPEN) {
	__GETB1MN _main_menu,33
	CPI  R30,0
	BREQ _0xA0085
; 0005 01C7                         init_curr_menu(&settings[0], NUM_SETTINGS);
	LDI  R30,LOW(_settings)
	LDI  R31,HIGH(_settings)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(17)
	CALL SUBOPT_0x94
; 0005 01C8                         curr_menu.level = 1 ;//printf ("Вход в меню НАСТРОЙКИ\r\n");
; 0005 01C9                     }
; 0005 01CA                     break;
_0xA0085:
; 0005 01CB             default: ;
_0xA0086:
; 0005 01CC         }
_0xA007F:
; 0005 01CD         mode.menu = 1;              // Общий режим - меню
	LDI  R30,LOW(1)
	STS  _mode,R30
; 0005 01CE         lcd_menu(0);
	RJMP _0x20E000C
; 0005 01CF         return;
; 0005 01D0     }
; 0005 01D1     lmenu = &(curr_menu.menu)[num_line];
_0xA007A:
	CALL SUBOPT_0x95
	CALL SUBOPT_0x8A
	ADD  R30,R22
	ADC  R31,R23
	MOVW R16,R30
; 0005 01D2     if (lmenu->can_edit == 0) {
	MOVW R26,R16
	ADIW R26,3
	LD   R30,X
	CPI  R30,0
	BRNE _0xA0087
; 0005 01D3         lcd_menu(0);
	RJMP _0x20E000C
; 0005 01D4         return;
; 0005 01D5     } else {
_0xA0087:
; 0005 01D6         mode.menu += lmenu->can_edit; // mode.menu = mode.menu + lmenu->can_edit (значение элемента can_edit указателя lmenu на структуру)
	MOVW R26,R16
	ADIW R26,3
	LD   R30,X
	LDS  R26,_mode
	ADD  R30,R26
	STS  _mode,R30
; 0005 01D7     }
; 0005 01D8     curr_menu.par = lmenu;
	CALL SUBOPT_0x96
; 0005 01D9     curr_menu.val_data = lmenu->val_data;        // Устанавливаем в текущем меню параметр для редактирования
	MOVW R26,R16
	CALL __GETW1P
	CALL SUBOPT_0x97
; 0005 01DA     lcd_edit(0);
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _lcd_edit
; 0005 01DB }
	RJMP _0x20E000B
;// Функция, обрабатывающая выход по Enter
;void lcd_save_edit (void) {
; 0005 01DD void lcd_save_edit (void) {
_lcd_save_edit:
; 0005 01DE     struct st_parameter *lmenu;     // Временная переменная, которая будет ссылаться на выбранный элемент меню
; 0005 01DF     byte num_line;                  // Временная переменная, содержащая текущий элемент меню
; 0005 01E0     // Устанавливаем указатель на параметры в зависимости от строки дисплея
; 0005 01E1     if (curr_menu.lcd) num_line = curr_menu.line1; else num_line = curr_menu.line0;
	CALL SUBOPT_0x93
;	*lmenu -> R16,R17
;	num_line -> R18
	BREQ _0xA0089
	__GETBRMN 18,_curr_menu,1
	RJMP _0xA008A
_0xA0089:
	LDS  R18,_curr_menu
; 0005 01E2     lmenu = &(curr_menu.menu)[num_line];
_0xA008A:
	CALL SUBOPT_0x95
	CALL SUBOPT_0x8A
	ADD  R30,R22
	ADC  R31,R23
	MOVW R16,R30
; 0005 01E3     curr_menu.par = lmenu;
	CALL SUBOPT_0x96
; 0005 01E4     lmenu->val_data = curr_menu.val_data;
	CALL SUBOPT_0x98
	MOVW R26,R16
	ST   X+,R30
	ST   X,R31
; 0005 01E5     sync_set_par(SYNC_FROM_MENU);
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _sync_set_par
; 0005 01E6     if (mode.stop_sync_dt) {
	__GETB1MN _mode,5
	CPI  R30,0
	BREQ _0xA008B
; 0005 01E7         // printf ("Вход в меню main_menu \r\n"); // Синхронизация по выходу
; 0005 01E8         // init_curr_menu(&main_menu[0], NUM_MENU);
; 0005 01E9         curr_menu = dt_curr_menu;
	CALL SUBOPT_0x99
; 0005 01EA         curr_menu.level = 0;
	CALL SUBOPT_0x9A
; 0005 01EB         mode.stop_sync_dt = 0;      // снимаем флаг запрета синхронизации
; 0005 01EC     }
; 0005 01ED     // Здесь параметр надо записать в EEPROM !!!!
; 0005 01EE     if (need_eeprom_write) {
_0xA008B:
	SBRS R2,0
	RJMP _0xA008C
; 0005 01EF         eeprom_write_struct ((char *)&prim_par, sizeof(prim_par));
	CALL SUBOPT_0x16
	CALL SUBOPT_0x9B
; 0005 01F0         // Снимаем флаг необходимости записи в EEPROM
; 0005 01F1         need_eeprom_write = 0;
	CLT
	BLD  R2,0
; 0005 01F2     }
; 0005 01F3     lcd_menu(0);
_0xA008C:
	RJMP _0x20E000C
; 0005 01F4     return;
; 0005 01F5 }
;// Функция, инициализирующая/деинициализирующая режим редактирования (0 - инициализация, 1 - выход по Enter, -1 - выход по Cancel
;void lcd_esc_edit(void) {
; 0005 01F7 void lcd_esc_edit(void) {
_lcd_esc_edit:
; 0005 01F8     struct st_parameter *lmenu;     // Временная переменная, которая будет ссылаться на выбранный элемент меню
; 0005 01F9     byte num_line;                  // Временная переменная, содержащая текущий элемент меню
; 0005 01FA     // Устанавливаем указатель на параметры в зависимости от строки дисплея
; 0005 01FB     if (curr_menu.lcd) num_line = curr_menu.line1; else num_line = curr_menu.line0;
	CALL SUBOPT_0x93
;	*lmenu -> R16,R17
;	num_line -> R18
	BREQ _0xA008D
	__GETBRMN 18,_curr_menu,1
	RJMP _0xA008E
_0xA008D:
	LDS  R18,_curr_menu
; 0005 01FC     // Перенесен блок в lcd_init_edit
; 0005 01FD     lmenu = &(curr_menu.menu)[num_line];
_0xA008E:
	CALL SUBOPT_0x95
	CALL SUBOPT_0x8A
	ADD  R30,R22
	ADC  R31,R23
	MOVW R16,R30
; 0005 01FE     // Если не нулевой уровень и нажата кнопка Cancel или ev_timer
; 0005 01FF     // printf("INIT EDIT(%d): %s = %i-->%i [%u]\r\n", initmode, lmenu->val_name, curr_menu.val_data, lmenu->val_data, curr_menu.level);
; 0005 0200     if (curr_menu.level || mode.stop_sync_dt) {
	__GETB1MN _curr_menu,10
	CPI  R30,0
	BRNE _0xA0090
	__GETB1MN _mode,5
	CPI  R30,0
	BREQ _0xA008F
_0xA0090:
; 0005 0201         // printf ("Вход в меню main_menu \r\n"); // Синхронизация по выходу
; 0005 0202         if (mode.stop_sync_dt)
	__GETB1MN _mode,5
	CPI  R30,0
	BREQ _0xA0092
; 0005 0203             curr_menu = dt_curr_menu;
	CALL SUBOPT_0x99
; 0005 0204         else
	RJMP _0xA0093
_0xA0092:
; 0005 0205             init_curr_menu(&main_menu[0], NUM_MENU);
	CALL SUBOPT_0xC
	CALL SUBOPT_0xD
; 0005 0206         curr_menu.level = 0;
_0xA0093:
	CALL SUBOPT_0x9A
; 0005 0207         mode.stop_sync_dt = 0;
; 0005 0208         return;
	RJMP _0x20E000B
; 0005 0209     }
; 0005 020A     // Перенесен блок в lcd_init_edit
; 0005 020B     curr_menu.par = lmenu;
_0xA008F:
	CALL SUBOPT_0x96
; 0005 020C     // printf("INIT EDIT(%d): %s = %i [%i]\r\n", initmode, lmenu->val_name, lmenu->val_data, curr_menu.val_data);
; 0005 020D     curr_menu.val_data = 0;
	CALL SUBOPT_0x9C
; 0005 020E     lcd_menu(0);
_0x20E000C:
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _lcd_menu
; 0005 020F     return;
_0x20E000B:
	CALL __LOADLOCR3
_0x20E000D:
	ADIW R28,3
	RET
; 0005 0210 }
;// Функция редактирующая текущий параметр меню. В качестве параметра передается вращение valcoder
;void lcd_edit(signed char direction) {
; 0005 0212 void lcd_edit(signed char direction) {
_lcd_edit:
; 0005 0213     struct st_parameter *lmenu;
; 0005 0214     lmenu = curr_menu.par;
	ST   -Y,R17
	ST   -Y,R16
;	direction -> Y+2
;	*lmenu -> R16,R17
	__GETWRMN 16,17,_curr_menu,6
; 0005 0215     // printf("EDIT (%d): LCDLine=%u, line0=%u, line1=%u\r\n", direction, curr_menu.lcd, curr_menu.line0, curr_menu.line1);
; 0005 0216     // (Де-)Инкрементацию делать надо в зависимости от типа переменной.
; 0005 0217     switch (lmenu->val_type) {
	MOVW R26,R16
	ADIW R26,2
	LD   R30,X
; 0005 0218         case e_empty:
	CPI  R30,0
	BRNE _0xA0097
; 0005 0219             // curr_menu.val_data - не меняет свое значение
; 0005 021A             break;
	RJMP _0xA0096
; 0005 021B         case e_clatsman:
_0xA0097:
	CPI  R30,LOW(0x1)
	BREQ _0xA0099
; 0005 021C         case e_winter:
	CPI  R30,LOW(0x2)
	BRNE _0xA009A
_0xA0099:
; 0005 021D             // curr_menu.val_data - принимает значение 0 или 1
; 0005 021E             if (direction) if(curr_menu.val_data) curr_menu.val_data = 0; else curr_menu.val_data = 1;
	LDD  R30,Y+2
	CPI  R30,0
	BREQ _0xA009B
	CALL SUBOPT_0x98
	SBIW R30,0
	BREQ _0xA009C
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0xA00DF
_0xA009C:
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
_0xA00DF:
	__PUTW1MN _curr_menu,8
; 0005 021F             // curr_menu.val_data = ~curr_menu.val_data;
; 0005 0220             break;
_0xA009B:
	RJMP _0xA0096
; 0005 0221         case e_isfour:
_0xA009A:
	CPI  R30,LOW(0x3)
	BRNE _0xA009E
; 0005 0222             if (direction) if (curr_menu.val_data) curr_menu.val_data = 0; else curr_menu.val_data = 3;
	LDD  R30,Y+2
	CPI  R30,0
	BREQ _0xA009F
	CALL SUBOPT_0x98
	SBIW R30,0
	BREQ _0xA00A0
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0xA00E0
_0xA00A0:
	LDI  R30,LOW(3)
	LDI  R31,HIGH(3)
_0xA00E0:
	__PUTW1MN _curr_menu,8
; 0005 0223             break;
_0xA009F:
	RJMP _0xA0096
; 0005 0224         case e_temperature:
_0xA009E:
	CPI  R30,LOW(0x5)
	BRNE _0xA00A2
; 0005 0225             // Изменение температуры идет с шагом +/-0,1 градуса
; 0005 0226             curr_menu.val_data += (int)direction * 10;
	CALL SUBOPT_0x9D
; 0005 0227             if (curr_menu.val_data > 10000) curr_menu.val_data = -3000;
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x2711)
	LDI  R30,HIGH(0x2711)
	CPC  R27,R30
	BRLT _0xA00A3
	LDI  R30,LOW(62536)
	LDI  R31,HIGH(62536)
	CALL SUBOPT_0x97
; 0005 0228             if (curr_menu.val_data < -3000) curr_menu.val_data = 10000;
_0xA00A3:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0xF448)
	LDI  R30,HIGH(0xF448)
	CPC  R27,R30
	BRGE _0xA00A4
	LDI  R30,LOW(10000)
	LDI  R31,HIGH(10000)
	CALL SUBOPT_0x97
; 0005 0229             break;
_0xA00A4:
	RJMP _0xA0096
; 0005 022A         case e_room:
_0xA00A2:
	CPI  R30,LOW(0x6)
	BRNE _0xA00A5
; 0005 022B             // Изменение температуры идет с шагом +/-0,1 градуса
; 0005 022C             curr_menu.val_data += (int)direction * 10;
	CALL SUBOPT_0x9D
; 0005 022D             if (curr_menu.val_data > 3000) curr_menu.val_data = 500;
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0xBB9)
	LDI  R30,HIGH(0xBB9)
	CPC  R27,R30
	BRLT _0xA00A6
	LDI  R30,LOW(500)
	LDI  R31,HIGH(500)
	CALL SUBOPT_0x97
; 0005 022E             if (curr_menu.val_data < 500) curr_menu.val_data = 3000;
_0xA00A6:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x1F4)
	LDI  R30,HIGH(0x1F4)
	CPC  R27,R30
	BRGE _0xA00A7
	LDI  R30,LOW(3000)
	LDI  R31,HIGH(3000)
	CALL SUBOPT_0x97
; 0005 022F             break;
_0xA00A7:
	RJMP _0xA0096
; 0005 0230         case e_world:
_0xA00A5:
	CPI  R30,LOW(0x7)
	BRNE _0xA00A8
; 0005 0231             // Изменение температуры идет с шагом +/-1 градус
; 0005 0232             curr_menu.val_data += (int)direction * 100;
	CALL SUBOPT_0x9F
	CALL SUBOPT_0xA0
; 0005 0233             if (curr_menu.val_data > 3000) curr_menu.val_data = -3000;
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0xBB9)
	LDI  R30,HIGH(0xBB9)
	CPC  R27,R30
	BRLT _0xA00A9
	LDI  R30,LOW(62536)
	LDI  R31,HIGH(62536)
	CALL SUBOPT_0x97
; 0005 0234             if (curr_menu.val_data < -3000) curr_menu.val_data = 3000;
_0xA00A9:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0xF448)
	LDI  R30,HIGH(0xF448)
	CPC  R27,R30
	BRGE _0xA00AA
	LDI  R30,LOW(3000)
	LDI  R31,HIGH(3000)
	CALL SUBOPT_0x97
; 0005 0235             break;
_0xA00AA:
	RJMP _0xA0096
; 0005 0236         case e_water:
_0xA00A8:
	CPI  R30,LOW(0x8)
	BRNE _0xA00AB
; 0005 0237             // Изменение температуры идет с шагом +/-1 градус
; 0005 0238             curr_menu.val_data += (int)direction * 100;
	CALL SUBOPT_0x9F
	CALL SUBOPT_0xA0
; 0005 0239             if (curr_menu.val_data > 10000) curr_menu.val_data = 500;
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x2711)
	LDI  R30,HIGH(0x2711)
	CPC  R27,R30
	BRLT _0xA00AC
	LDI  R30,LOW(500)
	LDI  R31,HIGH(500)
	CALL SUBOPT_0x97
; 0005 023A             if (curr_menu.val_data < 500) curr_menu.val_data = 10000;
_0xA00AC:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x1F4)
	LDI  R30,HIGH(0x1F4)
	CPC  R27,R30
	BRGE _0xA00AD
	LDI  R30,LOW(10000)
	LDI  R31,HIGH(10000)
	CALL SUBOPT_0x97
; 0005 023B             break;
_0xA00AD:
	RJMP _0xA0096
; 0005 023C         case e_percent:
_0xA00AB:
	CPI  R30,LOW(0x4)
	BRNE _0xA00AE
; 0005 023D             // Изменение порцентов идет с шагом +/-1 %
; 0005 023E             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 023F             //  curr_menu.val_data += 3*direction;
; 0005 0240             if (curr_menu.val_data > 0xFF) curr_menu.val_data = 0;
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x100)
	LDI  R30,HIGH(0x100)
	CPC  R27,R30
	BRLT _0xA00AF
	CALL SUBOPT_0x9C
; 0005 0241             if (curr_menu.val_data < 0) curr_menu.val_data = 0xFF;
_0xA00AF:
	__GETB2MN _curr_menu,9
	TST  R26
	BRPL _0xA00B0
	LDI  R30,LOW(255)
	LDI  R31,HIGH(255)
	CALL SUBOPT_0x97
; 0005 0242             break;
_0xA00B0:
	RJMP _0xA0096
; 0005 0243         case e_coef:
_0xA00AE:
	CPI  R30,LOW(0x9)
	BRNE _0xA00B1
; 0005 0244             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 0245             if (curr_menu.val_data < 0 ) curr_menu.val_data = 0xFF;
	__GETB2MN _curr_menu,9
	TST  R26
	BRPL _0xA00B2
	LDI  R30,LOW(255)
	LDI  R31,HIGH(255)
	CALL SUBOPT_0x97
; 0005 0246             if (curr_menu.val_data > 0xFF) curr_menu.val_data = 0;
_0xA00B2:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x100)
	LDI  R30,HIGH(0x100)
	CPC  R27,R30
	BRLT _0xA00B3
	CALL SUBOPT_0x9C
; 0005 0247             break;
_0xA00B3:
	RJMP _0xA0096
; 0005 0248         case e_scale:
_0xA00B1:
	CPI  R30,LOW(0xA)
	BRNE _0xA00B4
; 0005 0249             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 024A             if (curr_menu.val_data < -128 ) curr_menu.val_data = 127;
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0xFF80)
	LDI  R30,HIGH(0xFF80)
	CPC  R27,R30
	BRGE _0xA00B5
	LDI  R30,LOW(127)
	LDI  R31,HIGH(127)
	CALL SUBOPT_0x97
; 0005 024B             if (curr_menu.val_data > 127) curr_menu.val_data = -128;
_0xA00B5:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x80)
	LDI  R30,HIGH(0x80)
	CPC  R27,R30
	BRLT _0xA00B6
	LDI  R30,LOW(65408)
	LDI  R31,HIGH(65408)
	CALL SUBOPT_0x97
; 0005 024C             break;
_0xA00B6:
	RJMP _0xA0096
; 0005 024D         case e_stime:
_0xA00B4:
	CPI  R30,LOW(0xB)
	BRNE _0xA00B7
; 0005 024E             if (curr_menu.val_data < 100) curr_menu.val_data += direction; else
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x64)
	LDI  R30,HIGH(0x64)
	CPC  R27,R30
	BRGE _0xA00B8
	CALL SUBOPT_0x9E
	LDD  R30,Y+2
	LDI  R31,0
	SBRC R30,7
	SER  R31
	RJMP _0xA00E1
_0xA00B8:
; 0005 024F                 if (curr_menu.val_data < 1000) curr_menu.val_data += (int)direction*10; else
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x3E8)
	LDI  R30,HIGH(0x3E8)
	CPC  R27,R30
	BRGE _0xA00BA
	LDD  R30,Y+2
	LDI  R26,LOW(10)
	RJMP _0xA00E2
_0xA00BA:
; 0005 0250                     curr_menu.val_data += (int)direction*100;
	LDD  R30,Y+2
	LDI  R26,LOW(100)
_0xA00E2:
	MULS R30,R26
	MOVW R30,R0
	CALL SUBOPT_0x9E
_0xA00E1:
	ADD  R30,R26
	ADC  R31,R27
	CALL SUBOPT_0x97
; 0005 0251             if (curr_menu.val_data < 0) curr_menu.val_data = 3600;
	__GETB2MN _curr_menu,9
	TST  R26
	BRPL _0xA00BC
	LDI  R30,LOW(3600)
	LDI  R31,HIGH(3600)
	CALL SUBOPT_0x97
; 0005 0252             if (curr_menu.val_data > 3600) curr_menu.val_data = 0;
_0xA00BC:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0xE11)
	LDI  R30,HIGH(0xE11)
	CPC  R27,R30
	BRLT _0xA00BD
	CALL SUBOPT_0x9C
; 0005 0253             break;
_0xA00BD:
	RJMP _0xA0096
; 0005 0254         case e_minute:          // Время в минутах [00..59]
_0xA00B7:
	CPI  R30,LOW(0xD)
	BRNE _0xA00BE
; 0005 0255             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 0256             if (curr_menu.val_data < 0) curr_menu.val_data = 59;
	__GETB2MN _curr_menu,9
	TST  R26
	BRPL _0xA00BF
	LDI  R30,LOW(59)
	LDI  R31,HIGH(59)
	CALL SUBOPT_0x97
; 0005 0257             if (curr_menu.val_data > 59) curr_menu.val_data = 0;
_0xA00BF:
	CALL SUBOPT_0x9E
	SBIW R26,60
	BRLT _0xA00C0
	CALL SUBOPT_0x9C
; 0005 0258             break;
_0xA00C0:
	RJMP _0xA0096
; 0005 0259         case e_hour:            // Время в часах [00..23]
_0xA00BE:
	CPI  R30,LOW(0xE)
	BRNE _0xA00C1
; 0005 025A             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 025B             if (curr_menu.val_data < 0) curr_menu.val_data = 23;
	__GETB2MN _curr_menu,9
	TST  R26
	BRPL _0xA00C2
	LDI  R30,LOW(23)
	LDI  R31,HIGH(23)
	CALL SUBOPT_0x97
; 0005 025C             if (curr_menu.val_data > 23) curr_menu.val_data = 0;
_0xA00C2:
	CALL SUBOPT_0x9E
	SBIW R26,24
	BRLT _0xA00C3
	CALL SUBOPT_0x9C
; 0005 025D             break;
_0xA00C3:
	RJMP _0xA0096
; 0005 025E         case e_day:              // Дни [01..31]
_0xA00C1:
	CPI  R30,LOW(0xF)
	BRNE _0xA00C4
; 0005 025F             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 0260             if (curr_menu.val_data < 1) curr_menu.val_data = 31;
	CALL SUBOPT_0x9E
	SBIW R26,1
	BRGE _0xA00C5
	LDI  R30,LOW(31)
	LDI  R31,HIGH(31)
	CALL SUBOPT_0x97
; 0005 0261             if (curr_menu.val_data > 31) curr_menu.val_data = 1;
_0xA00C5:
	CALL SUBOPT_0x9E
	SBIW R26,32
	BRLT _0xA00C6
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CALL SUBOPT_0x97
; 0005 0262             break;
_0xA00C6:
	RJMP _0xA0096
; 0005 0263         case e_month:            // Месяцы [01..12]
_0xA00C4:
	CPI  R30,LOW(0x10)
	BRNE _0xA00C7
; 0005 0264             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 0265             if (curr_menu.val_data < 1) curr_menu.val_data = 12;
	CALL SUBOPT_0x9E
	SBIW R26,1
	BRGE _0xA00C8
	LDI  R30,LOW(12)
	LDI  R31,HIGH(12)
	CALL SUBOPT_0x97
; 0005 0266             if (curr_menu.val_data > 12) curr_menu.val_data = 1;
_0xA00C8:
	CALL SUBOPT_0x9E
	SBIW R26,13
	BRLT _0xA00C9
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CALL SUBOPT_0x97
; 0005 0267             break;
_0xA00C9:
	RJMP _0xA0096
; 0005 0268         case e_year:             // Года [00..99]
_0xA00C7:
	CPI  R30,LOW(0x11)
	BRNE _0xA00CA
; 0005 0269             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 026A             if (curr_menu.val_data < 11) curr_menu.val_data = 99;
	CALL SUBOPT_0x9E
	SBIW R26,11
	BRGE _0xA00CB
	LDI  R30,LOW(99)
	LDI  R31,HIGH(99)
	CALL SUBOPT_0x97
; 0005 026B             if (curr_menu.val_data > 99) curr_menu.val_data = 11;
_0xA00CB:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x64)
	LDI  R30,HIGH(0x64)
	CPC  R27,R30
	BRLT _0xA00CC
	LDI  R30,LOW(11)
	LDI  R31,HIGH(11)
	CALL SUBOPT_0x97
; 0005 026C             break;
_0xA00CC:
	RJMP _0xA0096
; 0005 026D         case e_alert:
_0xA00CA:
	CPI  R30,LOW(0x17)
	BRNE _0xA00CD
; 0005 026E             if (direction) curr_menu.val_data = 0;
	LDD  R30,Y+2
	CPI  R30,0
	BREQ _0xA00CE
	CALL SUBOPT_0x9C
; 0005 026F             break;
_0xA00CE:
	RJMP _0xA0096
; 0005 0270         case e_password:
_0xA00CD:
	CPI  R30,LOW(0x18)
	BRNE _0xA00D2
; 0005 0271             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 0272             SETTINGS_OPEN = (curr_menu.val_data == 20);
	CALL SUBOPT_0x9E
	LDI  R30,LOW(20)
	LDI  R31,HIGH(20)
	CALL __EQW12
	__PUTB1MN _main_menu,33
; 0005 0273             if (curr_menu.val_data < 0) curr_menu.val_data = 99;
	__GETB2MN _curr_menu,9
	TST  R26
	BRPL _0xA00D0
	LDI  R30,LOW(99)
	LDI  R31,HIGH(99)
	CALL SUBOPT_0x97
; 0005 0274             if (curr_menu.val_data > 99) curr_menu.val_data = 0;
_0xA00D0:
	CALL SUBOPT_0x9E
	CPI  R26,LOW(0x64)
	LDI  R30,HIGH(0x64)
	CPC  R27,R30
	BRLT _0xA00D1
	CALL SUBOPT_0x9C
; 0005 0275             break;
_0xA00D1:
	RJMP _0xA0096
; 0005 0276         default:
_0xA00D2:
; 0005 0277             curr_menu.val_data += direction;
	CALL SUBOPT_0x9E
	CALL SUBOPT_0xA1
; 0005 0278     }
_0xA0096:
; 0005 0279     // Рисуем две строки.
; 0005 027A     lcd_gotoxy(0,0);        // Устанавливаем курсор в позицию 0 строки 1
	CALL SUBOPT_0x64
; 0005 027B     lcd_line_menu(par_str(lmenu, 0, lmenu->val_data), 0);
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(0)
	ST   -Y,R30
	MOVW R26,R16
	CALL SUBOPT_0xA2
	RCALL _par_str
	CALL SUBOPT_0x37
	CALL _lcd_line_menu
; 0005 027C     lcd_gotoxy(0,1);        // Устанавливаем курсор в позицию 0 строки 1
	CALL SUBOPT_0x7
	CALL _lcd_gotoxy
; 0005 027D     lcd_line_menu(par_str(lmenu, 1, curr_menu.val_data), 0);
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL SUBOPT_0x98
	ST   -Y,R31
	ST   -Y,R30
	RCALL _par_str
	CALL SUBOPT_0x37
	CALL _lcd_line_menu
; 0005 027E     lcd_command(LCD_DISP_ON_CURSOR_BLINK);
	LDI  R30,LOW(15)
	ST   -Y,R30
	CALL _lcd_command
; 0005 027F }
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20E0006
;#pragma used+
;// Функция печатающая текущий и следующий элемент меню с использованием направления (-1, 0, 1)
;void print_curr_menu2(signed char direction) {
; 0005 0282 void print_curr_menu2(signed char direction) {
; 0005 0283     calc_pos(&curr_menu, curr_menu.maximum, direction);
;	direction -> Y+0
; 0005 0284     printf("Выбор меню [%u, %u]", curr_menu.line0, curr_menu.line1);
; 0005 0285     printf(" 1) ""%s"",\t2) ""%s""\r\n", main_menu[curr_menu.line0], main_menu[curr_menu.line1]);
; 0005 0286 }
;// Печать всех значений меню параметров в отладочном терминале
;void print_curr_menu(void) {
; 0005 0288 void print_curr_menu(void) {
; 0005 0289     register byte i;
; 0005 028A     // Выведем на отладочную консоль все пункты текущего (!) меню
; 0005 028B     printf ("Текущее меню: ");
;	i -> R16
; 0005 028C     for (i=0; i<curr_menu.maximum; i++) printf ("%s\t", param_str(i, curr_menu.menu));
; 0005 028D printf ("\r\n");
; 0005 028E }
;#pragma used-
;// Функция, возвращающая указатель на строку меню по порядковому номеру
;char *getmenustr(unsigned char menu_num_pp) {
; 0005 0291 char *getmenustr(unsigned char menu_num_pp) {
_getmenustr:
; 0005 0292     static lcd_str menustr;
; 0005 0293     if (menu_num_pp) {
;	menu_num_pp -> Y+0
	LD   R30,Y
	CPI  R30,0
	BREQ _0xA00D6
; 0005 0294         if (menu_num_pp < ALERT_POS)
	LD   R26,Y
	CPI  R26,LOW(0x3D)
	BRSH _0xA00D7
; 0005 0295             strcpyf (menustr, all_menu_str[menu_num_pp-1]);
	LDI  R30,LOW(_menustr_S005000C)
	LDI  R31,HIGH(_menustr_S005000C)
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+2
	SUBI R30,LOW(1)
	LDI  R31,0
	CALL __LSLW4
	SUBI R30,LOW(-_all_menu_str*2)
	SBCI R31,HIGH(-_all_menu_str*2)
	ST   -Y,R31
	ST   -Y,R30
	CALL _strcpyf
; 0005 0296         else
	RJMP _0xA00D8
_0xA00D7:
; 0005 0297             strcpy (menustr, get_alert_str(menu_num_pp - ALERT_POS));
	LDI  R30,LOW(_menustr_S005000C)
	LDI  R31,HIGH(_menustr_S005000C)
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+2
	SUBI R30,LOW(61)
	CALL SUBOPT_0x36
	CALL _strcpy
; 0005 0298         return menustr;
_0xA00D8:
	LDI  R30,LOW(_menustr_S005000C)
	LDI  R31,HIGH(_menustr_S005000C)
	JMP  _0x20E0003
; 0005 0299     } else
_0xA00D6:
; 0005 029A         return NULL;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	JMP  _0x20E0003
; 0005 029B }
;#include <stdio.h>
;#include <i2c.h>
;#include <delay.h>
;#include "at2404.h"
;
;#define OFFSET_FOR_SETTING 0x0
;#define OFFSET_FOR_ALARMS 0x0
;#define NODEBUG
;
;char eeprom_write(unsigned char eeprom_adresse, unsigned char eeprom_input, unsigned char bank)
; 0006 000B {

	.CSEG
_eeprom_write:
; 0006 000C     i2c_start();
;	eeprom_adresse -> Y+2
;	eeprom_input -> Y+1
;	bank -> Y+0
	CALL _i2c_start
; 0006 000D     if (bank)
	LD   R30,Y
	CPI  R30,0
	BREQ _0xC0003
; 0006 000E         i2c_write(M24C02_1+I2C_WRITE);
	LDI  R30,LOW(162)
	RJMP _0xC0015
; 0006 000F     else
_0xC0003:
; 0006 0010         i2c_write(M24C02_0+I2C_WRITE);
	LDI  R30,LOW(160)
_0xC0015:
	ST   -Y,R30
	CALL _i2c_write
; 0006 0011 	i2c_write(eeprom_adresse);
	LDD  R30,Y+2
	CALL SUBOPT_0xA3
; 0006 0012     i2c_write(eeprom_input);
	CALL _i2c_write
; 0006 0013     i2c_stop();
	CALL _i2c_stop
; 0006 0014     delay_ms(10);
	LDI  R30,LOW(10)
	LDI  R31,HIGH(10)
	CALL SUBOPT_0xB
; 0006 0015 	return 1;
	LDI  R30,LOW(1)
	JMP  _0x20E0006
; 0006 0016 }
;
;char eeprom_read(unsigned char eeprom_adresse, unsigned char bank)
; 0006 0019 {
_eeprom_read:
; 0006 001A 	unsigned char data;
; 0006 001B     i2c_start();
	ST   -Y,R16
;	eeprom_adresse -> Y+2
;	bank -> Y+1
;	data -> R16
	CALL _i2c_start
; 0006 001C     if (bank)
	LDD  R30,Y+1
	CPI  R30,0
	BREQ _0xC0005
; 0006 001D         i2c_write(M24C02_1+I2C_WRITE);
	LDI  R30,LOW(162)
	RJMP _0xC0016
; 0006 001E     else
_0xC0005:
; 0006 001F         i2c_write(M24C02_0+I2C_WRITE);
	LDI  R30,LOW(160)
_0xC0016:
	ST   -Y,R30
	CALL _i2c_write
; 0006 0020    	i2c_write(eeprom_adresse);
	LDD  R30,Y+2
	CALL SUBOPT_0xA4
; 0006 0021     i2c_start();
; 0006 0022     if (bank)
	LDD  R30,Y+1
	CPI  R30,0
	BREQ _0xC0007
; 0006 0023         i2c_write(M24C02_1+I2C_READ);
	LDI  R30,LOW(163)
	RJMP _0xC0017
; 0006 0024     else
_0xC0007:
; 0006 0025         i2c_write(M24C02_0+I2C_READ);
	LDI  R30,LOW(161)
_0xC0017:
	ST   -Y,R30
	CALL _i2c_write
; 0006 0026     data = i2c_read(0);
	CALL SUBOPT_0xA5
	MOV  R16,R30
; 0006 0027     i2c_stop();
	CALL _i2c_stop
; 0006 0028 	return data;
	MOV  R30,R16
	LDD  R16,Y+0
	JMP  _0x20E0006
; 0006 0029 }
;// Функция, загоняющая в EEPROM структуру размером size
;void eeprom_write_struct (unsigned char *struct_data, unsigned char size)
; 0006 002C {
_eeprom_write_struct:
; 0006 002D     register unsigned char i;
; 0006 002E     unsigned char s_byte;
; 0006 002F     printf("Записываем SETTINGS в EEPROM [0x%x]: ", size);
	ST   -Y,R17
	ST   -Y,R16
;	*struct_data -> Y+3
;	size -> Y+2
;	i -> R16
;	s_byte -> R17
	__POINTW1FN _0xC0000,0
	CALL SUBOPT_0x6B
	CALL SUBOPT_0xA
; 0006 0030     #ifdef NODEBUG
; 0006 0031     printf("\r\n");
	__POINTW1FN _0xC0000,38
	CALL SUBOPT_0x1
; 0006 0032     #endif
; 0006 0033     for (i=0; i<size; i++) {
	LDI  R16,LOW(0)
_0xC000A:
	LDD  R30,Y+2
	CP   R16,R30
	BRSH _0xC000B
; 0006 0034         s_byte = *struct_data;
	LDD  R26,Y+3
	LDD  R27,Y+3+1
	LD   R17,X
; 0006 0035         eeprom_write(i + OFFSET_FOR_SETTING, s_byte, 0);
	MOV  R30,R16
	ST   -Y,R30
	ST   -Y,R17
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _eeprom_write
; 0006 0036         #ifndef NODEBUG
; 0006 0037         printf(" %d", s_byte);
; 0006 0038         #endif
; 0006 0039         struct_data++;
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	ADIW R30,1
	STD  Y+3,R30
	STD  Y+3+1,R31
; 0006 003A     }
	SUBI R16,-1
	RJMP _0xC000A
_0xC000B:
; 0006 003B     #ifndef NODEBUG
; 0006 003C     printf("\r\n");
; 0006 003D     #endif
; 0006 003E }
	RJMP _0x20E000A
;// Функция, загоняющая в EEPROM ALARM-структуру размером в size
;void eeprom_write_alarm (unsigned char *struct_data, unsigned char size, unsigned char num_alarm)
; 0006 0041 {
_eeprom_write_alarm:
; 0006 0042     register unsigned char i;
; 0006 0043     unsigned char s_byte;
; 0006 0044     unsigned char eeprom_offset;
; 0006 0045     eeprom_offset = OFFSET_FOR_ALARMS + size * (num_alarm - 1);
	CALL SUBOPT_0xA6
;	*struct_data -> Y+5
;	size -> Y+4
;	num_alarm -> Y+3
;	i -> R16
;	s_byte -> R17
;	eeprom_offset -> R18
; 0006 0046     printf("Записываем ALARM #%u в EEPROM [0x%x] по адресу 0x%x:\r\n", num_alarm, size, eeprom_offset);
	__POINTW1FN _0xC0000,41
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+5
	CALL SUBOPT_0x28
	LDD  R30,Y+10
	CALL SUBOPT_0x28
	MOV  R30,R18
	CALL SUBOPT_0x28
	CALL SUBOPT_0x12
; 0006 0047     for (i=0; i<size; i++) {
	LDI  R16,LOW(0)
_0xC000D:
	LDD  R30,Y+4
	CP   R16,R30
	BRSH _0xC000E
; 0006 0048         s_byte = *struct_data;
	LDD  R26,Y+5
	LDD  R27,Y+5+1
	LD   R17,X
; 0006 0049         eeprom_write(i + eeprom_offset, s_byte, 1); // Записываем во второй банк памяти
	MOV  R30,R18
	ADD  R30,R16
	ST   -Y,R30
	ST   -Y,R17
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _eeprom_write
; 0006 004A         #ifndef NODEBUG
; 0006 004B         printf(" %02X", s_byte);
; 0006 004C         #endif
; 0006 004D         struct_data++;
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ADIW R30,1
	STD  Y+5,R30
	STD  Y+5+1,R31
; 0006 004E     }
	SUBI R16,-1
	RJMP _0xC000D
_0xC000E:
; 0006 004F     #ifndef NODEBUG
; 0006 0050     printf("\r\n");
; 0006 0051     #endif
; 0006 0052 }
	CALL __LOADLOCR3
	JMP  _0x20E0002
;// Функция, загоняющая из EEPROM в структуру размером size
;void eeprom_read_struct (unsigned char *struct_data, unsigned char size)
; 0006 0055 {
_eeprom_read_struct:
; 0006 0056     register unsigned char i;
; 0006 0057     unsigned char s_byte;
; 0006 0058     printf("Считываем из EEPROM [0x%x]: ", size);
	ST   -Y,R17
	ST   -Y,R16
;	*struct_data -> Y+3
;	size -> Y+2
;	i -> R16
;	s_byte -> R17
	__POINTW1FN _0xC0000,96
	CALL SUBOPT_0x6B
	CALL SUBOPT_0xA
; 0006 0059     #ifdef NODEBUG
; 0006 005A     printf("\r\n");
	__POINTW1FN _0xC0000,38
	CALL SUBOPT_0x1
; 0006 005B     #endif
; 0006 005C     for (i=0; i<size; i++) {
	LDI  R16,LOW(0)
_0xC0010:
	LDD  R30,Y+2
	CP   R16,R30
	BRSH _0xC0011
; 0006 005D         s_byte = eeprom_read(i + OFFSET_FOR_SETTING, 0);
	MOV  R30,R16
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RCALL _eeprom_read
	MOV  R17,R30
; 0006 005E         *struct_data = s_byte;
	LDD  R26,Y+3
	LDD  R27,Y+3+1
	ST   X,R17
; 0006 005F         #ifndef NODEBUG
; 0006 0060         printf(" %d", s_byte);
; 0006 0061         #endif
; 0006 0062         struct_data++;
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	ADIW R30,1
	STD  Y+3,R30
	STD  Y+3+1,R31
; 0006 0063     }
	SUBI R16,-1
	RJMP _0xC0010
_0xC0011:
; 0006 0064     #ifndef NODEBUG
; 0006 0065     printf("\r\n");
; 0006 0066     #endif
; 0006 0067 }
_0x20E000A:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,5
	RET
;// Функция, загоняющая из EEPROM в структуру ALARM размером size
;void eeprom_read_alarm (unsigned char *struct_data, unsigned char size, unsigned char num_alarm)
; 0006 006A {
_eeprom_read_alarm:
; 0006 006B     register unsigned char i;
; 0006 006C     unsigned char s_byte;
; 0006 006D     unsigned char eeprom_offset;
; 0006 006E     eeprom_offset = OFFSET_FOR_ALARMS + (num_alarm - 1) * size;
	CALL SUBOPT_0xA6
;	*struct_data -> Y+5
;	size -> Y+4
;	num_alarm -> Y+3
;	i -> R16
;	s_byte -> R17
;	eeprom_offset -> R18
; 0006 006F     #ifndef NODEBUG
; 0006 0070     printf("Считываем ALARM #%u из EEPROM [%d bytes] по адресу 0x%x:\r\n", num_alarm, size, eeprom_offset);
; 0006 0071     #endif
; 0006 0072     for (i=0; i<size; i++) {
	LDI  R16,LOW(0)
_0xC0013:
	LDD  R30,Y+4
	CP   R16,R30
	BRSH _0xC0014
; 0006 0073         s_byte = eeprom_read(i + eeprom_offset, 1);
	MOV  R30,R18
	ADD  R30,R16
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _eeprom_read
	MOV  R17,R30
; 0006 0074         *struct_data = s_byte;
	LDD  R26,Y+5
	LDD  R27,Y+5+1
	ST   X,R17
; 0006 0075         #ifndef NODEBUG
; 0006 0076         printf(" %02X", s_byte);
; 0006 0077         #endif
; 0006 0078         struct_data++;
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ADIW R30,1
	STD  Y+5,R30
	STD  Y+5+1,R31
; 0006 0079     }
	SUBI R16,-1
	RJMP _0xC0013
_0xC0014:
; 0006 007A     #ifndef NODEBUG
; 0006 007B     printf("\r\n");
; 0006 007C     #endif
; 0006 007D }
	CALL __LOADLOCR3
	JMP  _0x20E0002
;#include <stdio.h>
;#include <string.h>
;#include "robowater.h"
;#include "at2404.h"
;#include "spd1820.h"
;#include "alarm.h"
;#include "bits.h"
;#include "menu.h"
;
;struct st_alarm alarm;      // Текущий alarm
;
;flash alarm_text all_alerts[MAX_ALERTS] = {
;        "Термозащита ",  // [0]
;        "Замерзание ",   // [1]
;        "Темп.возд.вх ", // [2]
;        "Т.возд.вых. ",  // [3]
;        "Темп.воды вх ", // [4]
;        "Т.воды вых.",   // [5]
;        "Нет связи ",    // [6]
;        "Нет терм.B1 ",  // [7]
;        "Нет терм.B2 ",  // [8]
;        "Нет терм.B3 ",  // [9]
;        "Нет терм.B4 ",  // [10]
;        "Фильтр "        // [11]
;};
;// Функция обновляющая количество активных алертов в системе для меню
;void update_alert_menu (void) {
; 0007 001B void update_alert_menu (void) {

	.CSEG
_update_alert_menu:
; 0007 001C     register unsigned char i;
; 0007 001D     KOL_ALERT = 0;
	ST   -Y,R16
;	i -> R16
	__POINTW1MN _main_menu,25
	CALL SUBOPT_0xA7
; 0007 001E     for (i = 0; i < MAX_ALERTS; i++) {
	LDI  R16,LOW(0)
_0xE0004:
	CPI  R16,12
	BRSH _0xE0005
; 0007 001F         alerts[i].can_edit = prim_par.alert_status[i];
	LDI  R26,LOW(5)
	MUL  R16,R26
	MOVW R30,R0
	__ADDW1MN _alerts,3
	MOVW R0,R30
	__POINTW2MN _prim_par,36
	CLR  R30
	ADD  R26,R16
	ADC  R27,R30
	LD   R30,X
	MOVW R26,R0
	ST   X,R30
; 0007 0020         if (prim_par.alert_status[i]) {
	CALL SUBOPT_0x61
	BREQ _0xE0006
; 0007 0021             KOL_ALERT++;
	__POINTW2MN _main_menu,25
	CALL SUBOPT_0xA8
; 0007 0022             if (alerts[i].val_data == 0) alerts[i].val_data = 1;
	CALL SUBOPT_0x89
	BRNE _0xE0007
	LDI  R26,LOW(5)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_alerts)
	SBCI R31,HIGH(-_alerts)
	CALL SUBOPT_0xA9
; 0007 0023         }
_0xE0007:
; 0007 0024     }
_0xE0006:
	SUBI R16,-1
	RJMP _0xE0004
_0xE0005:
; 0007 0025     IS_ALERT = KOL_ALERT;
	__GETB1MN _main_menu,25
	__PUTB1MN _main_menu,28
; 0007 0026 }
	JMP  _0x20E0009
;// Функция регистрации ALARM
;void alarm_reg (int reg_preset, int reg_alarm, char *text_alarm, unsigned char code) {
; 0007 0028 void alarm_reg (int reg_preset, int reg_alarm, char *text_alarm, unsigned char code) {
_alarm_reg:
; 0007 0029     sprintf (alarm.datestamp, "%02u:%02u %02u.%02u", s_dt.cHH, s_dt.cMM, s_dt.cdd, s_dt.cmo);
;	reg_preset -> Y+5
;	reg_alarm -> Y+3
;	*text_alarm -> Y+1
;	code -> Y+0
	CALL SUBOPT_0xAA
	__POINTW1FN _0xE0000,0
	CALL SUBOPT_0x58
	CALL SUBOPT_0x59
	CALL SUBOPT_0x66
	CALL SUBOPT_0x67
	CALL SUBOPT_0x6A
; 0007 002A     sprintf (alarm.text, "%s", text_alarm);
	__POINTW1MN _alarm,16
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1FN _0xE0000,20
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x8C
; 0007 002B     alarm.val_preset = reg_preset;
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	__PUTW1MN _alarm,12
; 0007 002C     alarm.val_alarm = reg_alarm;
	LDD  R30,Y+3
	LDD  R31,Y+3+1
	__PUTW1MN _alarm,14
; 0007 002D     // Регистрируем событие в общей структуре prim_par
; 0007 002E     prim_par.alert_status[code] = 1;
	CALL SUBOPT_0xAB
	LDI  R30,LOW(1)
	ST   X,R30
; 0007 002F     alerts[code].val_data = reg_alarm;
	LD   R30,Y
	LDI  R26,LOW(5)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,LOW(-_alerts)
	SBCI R31,HIGH(-_alerts)
	LDD  R26,Y+3
	LDD  R27,Y+3+1
	STD  Z+0,R26
	STD  Z+1,R27
; 0007 0030     // Вычисление позиции необработанного alarm
; 0007 0031     if (prim_par.c_alarm < MAX_ALARMS) prim_par.c_alarm++;
	__GETB2MN _prim_par,50
	CPI  R26,LOW(0x8)
	BRSH _0xE0008
	__GETB1MN _prim_par,50
	SUBI R30,-LOW(1)
	__PUTB1MN _prim_par,50
	SUBI R30,LOW(1)
; 0007 0032     prim_par.alarm++;
_0xE0008:
	__GETB1MN _prim_par,49
	SUBI R30,-LOW(1)
	__PUTB1MN _prim_par,49
	SUBI R30,LOW(1)
; 0007 0033     if (prim_par.alarm > prim_par.c_alarm) prim_par.alarm = 1;
	__GETB2MN _prim_par,49
	__GETB1MN _prim_par,50
	CP   R30,R26
	BRSH _0xE0009
	LDI  R30,LOW(1)
	__PUTB1MN _prim_par,49
; 0007 0034     // Запись ALARM
; 0007 0035     eeprom_write_alarm ((char *)&alarm, sizeof(alarm), prim_par.alarm);
_0xE0009:
	CALL SUBOPT_0xAA
	LDI  R30,LOW(32)
	ST   -Y,R30
	__GETB1MN _prim_par,49
	ST   -Y,R30
	RCALL _eeprom_write_alarm
; 0007 0036     // Запись структуры установок (там хранится позиция и номер ALARM)
; 0007 0037     eeprom_write_struct ((char *)&prim_par, sizeof(prim_par));
	CALL SUBOPT_0x16
	CALL SUBOPT_0x9B
; 0007 0038     update_alert_menu ();
	RCALL _update_alert_menu
; 0007 0039     return;
	JMP  _0x20E0002
; 0007 003A }
;// Функция обработки ALARM
;signed char alarm_unreg (unsigned char code) {
; 0007 003C signed char alarm_unreg (unsigned char code) {
_alarm_unreg:
; 0007 003D     // Если событий нет, возвращаем признак -1
; 0007 003E     if (prim_par.alert_status[code] == 0) return -1;
;	code -> Y+0
	CALL SUBOPT_0xAB
	LD   R30,X
	CPI  R30,0
	BRNE _0xE000A
	LDI  R30,LOW(255)
	JMP  _0x20E0003
; 0007 003F     // Разрегистрируем событие в общей структуре prim_par
; 0007 0040     prim_par.alert_status[code] = 0;
_0xE000A:
	CALL SUBOPT_0xAB
	LDI  R30,LOW(0)
	ST   X,R30
; 0007 0041     // Запись структуры установок (там хранится позиция и номер ALARM)
; 0007 0042     eeprom_write_struct ((char *)&prim_par, sizeof(prim_par));
	CALL SUBOPT_0x16
	CALL SUBOPT_0x9B
; 0007 0043     update_alert_menu ();
	RCALL _update_alert_menu
; 0007 0044     if (code >= 7 && code <= 10) read_all_terms(INIT_MODE);
	LD   R26,Y
	CPI  R26,LOW(0x7)
	BRLO _0xE000C
	CPI  R26,LOW(0xB)
	BRLO _0xE000D
_0xE000C:
	RJMP _0xE000B
_0xE000D:
	CALL SUBOPT_0x18
; 0007 0045     return;
_0xE000B:
	JMP  _0x20E0003
; 0007 0046 }
;// Функция чтения ALARM по номеру из EEPROM
;signed char alarm_read (unsigned char num) {
; 0007 0048 signed char alarm_read (unsigned char num) {
_alarm_read:
; 0007 0049     // Если событий нет, возвращаем признак -1
; 0007 004A     if (num == 0) return -1;
;	num -> Y+0
	LD   R30,Y
	CPI  R30,0
	BRNE _0xE000E
	LDI  R30,LOW(255)
	JMP  _0x20E0003
; 0007 004B     eeprom_read_alarm ((char *)&alarm, sizeof(alarm), num);
_0xE000E:
	CALL SUBOPT_0xAA
	LDI  R30,LOW(32)
	ST   -Y,R30
	LDD  R30,Y+3
	ST   -Y,R30
	RCALL _eeprom_read_alarm
; 0007 004C }
	JMP  _0x20E0003
;void alarm_c_print (void) {
; 0007 004D void alarm_c_print (void) {
_alarm_c_print:
; 0007 004E     printf("> %s %i %i %s\r\n", alarm.datestamp, alarm.val_preset, alarm.val_alarm, alarm.text);
	__POINTW1FN _0xE0000,23
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_alarm)
	LDI  R31,HIGH(_alarm)
	CALL SUBOPT_0x5D
	__GETW1MN _alarm,12
	CALL SUBOPT_0x23
	__GETW1MN _alarm,14
	CALL SUBOPT_0x23
	__POINTW1MN _alarm,16
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x52
; 0007 004F }
	RET
;// Функция печатающая все ALARMs
;void alarm_all_print (void) {
; 0007 0051 void alarm_all_print (void) {
_alarm_all_print:
; 0007 0052     register unsigned char i;
; 0007 0053     unsigned char c;
; 0007 0054     c = prim_par.alarm;
	ST   -Y,R17
	ST   -Y,R16
;	i -> R16
;	c -> R17
	__GETBRMN 17,_prim_par,49
; 0007 0055     // Печатаем все зарегистрированные alarms начиная с текущей и в обратном порядке
; 0007 0056     printf("Все аварии:\r\n");
	__POINTW1FN _0xE0000,39
	CALL SUBOPT_0x1
; 0007 0057     for (i = 1; i <= MAX_ALARMS; i++) {
	LDI  R16,LOW(1)
_0xE0010:
	CPI  R16,9
	BRSH _0xE0011
; 0007 0058         alarm_read(c--);
	ST   -Y,R17
	DEC  R17
	RCALL _alarm_read
; 0007 0059         alarm_c_print();
	RCALL _alarm_c_print
; 0007 005A         if (c == 0) c = prim_par.c_alarm;
	CPI  R17,0
	BRNE _0xE0012
	__GETBRMN 17,_prim_par,50
; 0007 005B     }
_0xE0012:
	SUBI R16,-1
	RJMP _0xE0010
_0xE0011:
; 0007 005C }
	LD   R16,Y+
	LD   R17,Y+
	RET
;// Функция, возвращающая строку названия тревоги по коду
;char *get_alert_str(unsigned char code) {
; 0007 005E char *get_alert_str(unsigned char code) {
_get_alert_str:
; 0007 005F     static alarm_text alert_string;
; 0007 0060     if (code < MAX_ALERTS) {
;	code -> Y+0
	LD   R26,Y
	CPI  R26,LOW(0xC)
	BRSH _0xE0013
; 0007 0061         strcpyf (alert_string, all_alerts[code]);
	LDI  R30,LOW(_alert_string_S0070006)
	LDI  R31,HIGH(_alert_string_S0070006)
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+2
	LDI  R31,0
	CALL __LSLW4
	SUBI R30,LOW(-_all_alerts*2)
	SBCI R31,HIGH(-_all_alerts*2)
	ST   -Y,R31
	ST   -Y,R30
	CALL _strcpyf
; 0007 0062         return alert_string;
	LDI  R30,LOW(_alert_string_S0070006)
	LDI  R31,HIGH(_alert_string_S0070006)
	JMP  _0x20E0003
; 0007 0063     } else {
_0xE0013:
; 0007 0064         return NULL;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	JMP  _0x20E0003
; 0007 0065     }
; 0007 0066 }
;#include <mega32.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x80
	.EQU __sm_mask=0x70
	.EQU __sm_powerdown=0x20
	.EQU __sm_powersave=0x30
	.EQU __sm_standby=0x60
	.EQU __sm_ext_standby=0x70
	.EQU __sm_adc_noise_red=0x10
	.SET power_ctrl_reg=mcucr
	#endif
;#include <stdio.h>
;#include "robowater.h"
;#include "signals.h"
;// Лапы сигналов
;#define BUZ PORTD.6     // Порт звука
;#define RED PORTA.3     // Порт красной лампочки
;#define GREEN PORTB.4   // Порт зеленой лампочки
;#define WHITE PORTA.2   // Порт белой лампочки
;// Описание модульных переменных
;struct st_signal signals;      // Текущее состояние всех сигналов
;// Функция выводящая состояние всей структуры сигналов
;void signal_printallbytes (void) {
; 0008 000D void signal_printallbytes (void) {

	.CSEG
_signal_printallbytes:
; 0008 000E     register unsigned char i;
; 0008 000F     unsigned char *status = &signals.buz_mode;
; 0008 0010     printf ("Стуктура signals =");
	CALL __SAVELOCR3
;	i -> R16
;	*status -> R17,R18
	__POINTWRM 17,18,_signals
	__POINTW1FN _0x100000,0
	CALL SUBOPT_0x1
; 0008 0011     for (i = 0; i < sizeof(signals); i++) {
	LDI  R16,LOW(0)
_0x100004:
	CPI  R16,12
	BRSH _0x100005
; 0008 0012         printf (" %x", *status);
	__POINTW1FN _0x100000,19
	ST   -Y,R31
	ST   -Y,R30
	__GETW2R 17,18
	LD   R30,X
	CALL SUBOPT_0x28
	CALL SUBOPT_0xA
; 0008 0013         status++;
	__ADDWRN 17,18,1
; 0008 0014     }
	SUBI R16,-1
	RJMP _0x100004
_0x100005:
; 0008 0015     printf ("\r\n");
	__POINTW1FN _0x100000,23
	CALL SUBOPT_0x1
; 0008 0016 }
	CALL __LOADLOCR3
	RJMP _0x20E0006
;// Функция инициализация статуса любого светика
;unsigned char init_lamp_status (unsigned char *lamp_mode) {
; 0008 0018 unsigned char init_lamp_status (unsigned char *lamp_mode) {
_init_lamp_status:
; 0008 0019     unsigned char *lamp_timer = lamp_mode + 1;
; 0008 001A     unsigned char *lamp_status = lamp_mode + 2;
; 0008 001B     switch (*lamp_mode) {
	CALL SUBOPT_0xAC
;	*lamp_mode -> Y+4
;	*lamp_timer -> R16,R17
;	*lamp_status -> R18,R19
; 0008 001C         case SHORT:
	BRNE _0x100009
; 0008 001D             *lamp_timer = SHORT_MAX;
	MOVW R26,R16
	LDI  R30,LOW(1)
	ST   X,R30
; 0008 001E             *lamp_status = ON;
	MOVW R26,R18
	RJMP _0x100047
; 0008 001F             break;
; 0008 0020         case LONG:
_0x100009:
	CPI  R30,LOW(0x3)
	BRNE _0x10000A
; 0008 0021             *lamp_timer = LONG_MAX;
	MOVW R26,R16
	LDI  R30,LOW(5)
	ST   X,R30
; 0008 0022             *lamp_status = ON;
	MOVW R26,R18
	LDI  R30,LOW(1)
	RJMP _0x100047
; 0008 0023             break;
; 0008 0024         case MEANDR:
_0x10000A:
	CPI  R30,LOW(0x4)
	BRNE _0x10000B
; 0008 0025             *lamp_timer = MEANDR_MAX;
	MOVW R26,R16
	LDI  R30,LOW(3)
	ST   X,R30
; 0008 0026             *lamp_status = ON;
	MOVW R26,R18
	LDI  R30,LOW(1)
	RJMP _0x100047
; 0008 0027             break;
; 0008 0028         case ON:
_0x10000B:
	CPI  R30,LOW(0x1)
	BRNE _0x10000D
; 0008 0029             *lamp_status = ON;
	MOVW R26,R18
	LDI  R30,LOW(1)
	RJMP _0x100047
; 0008 002A             break;
; 0008 002B         default:
_0x10000D:
; 0008 002C             *lamp_status = OFF;
	MOVW R26,R18
	LDI  R30,LOW(0)
_0x100047:
	ST   X,R30
; 0008 002D             break;
; 0008 002E     };
; 0008 002F     return (*lamp_status);
	MOVW R26,R18
	LD   R30,X
	CALL __LOADLOCR4
	RJMP _0x20E0008
; 0008 0030 }
;// Функция обновления статуса любого светика
;unsigned char update_lamp_status (unsigned char *lamp_mode) {
; 0008 0032 unsigned char update_lamp_status (unsigned char *lamp_mode) {
_update_lamp_status:
; 0008 0033     unsigned char *lamp_timer = lamp_mode + 1;
; 0008 0034     unsigned char *lamp_status = lamp_mode + 2;
; 0008 0035     switch (*lamp_mode) {
	CALL SUBOPT_0xAC
;	*lamp_mode -> Y+4
;	*lamp_timer -> R16,R17
;	*lamp_status -> R18,R19
; 0008 0036         case SHORT:
	BRNE _0x100011
; 0008 0037             if (*lamp_timer) {
	MOVW R26,R16
	LD   R30,X
	CPI  R30,0
	BREQ _0x100012
; 0008 0038                 *lamp_timer = *lamp_timer - 1;
	CALL SUBOPT_0xAD
; 0008 0039                 if (*lamp_timer == 0) {
	BRNE _0x100013
; 0008 003A                     if (*lamp_status) {
	MOVW R26,R18
	LD   R30,X
	CPI  R30,0
	BREQ _0x100014
; 0008 003B                         *lamp_status = OFF;
	LDI  R30,LOW(0)
	ST   X,R30
; 0008 003C                         *lamp_timer = LONG_MAX;
	MOVW R26,R16
	LDI  R30,LOW(5)
	RJMP _0x100048
; 0008 003D                     } else {
_0x100014:
; 0008 003E                         *lamp_status = ON;
	MOVW R26,R18
	LDI  R30,LOW(1)
	ST   X,R30
; 0008 003F                         *lamp_timer = SHORT_MAX;
	MOVW R26,R16
_0x100048:
	ST   X,R30
; 0008 0040                     }
; 0008 0041                 }
; 0008 0042             }
_0x100013:
; 0008 0043             break;
_0x100012:
	RJMP _0x100010
; 0008 0044         case LONG:
_0x100011:
	CPI  R30,LOW(0x3)
	BRNE _0x100016
; 0008 0045             if (*lamp_timer) {
	MOVW R26,R16
	LD   R30,X
	CPI  R30,0
	BREQ _0x100017
; 0008 0046                 *lamp_timer = *lamp_timer - 1;
	CALL SUBOPT_0xAD
; 0008 0047                 if (*lamp_timer == 0) {
	BRNE _0x100018
; 0008 0048                     if (*lamp_status) {
	MOVW R26,R18
	LD   R30,X
	CPI  R30,0
	BREQ _0x100019
; 0008 0049                         *lamp_status = OFF;
	LDI  R30,LOW(0)
	ST   X,R30
; 0008 004A                         *lamp_timer = SHORT_MAX;
	MOVW R26,R16
	LDI  R30,LOW(1)
	RJMP _0x100049
; 0008 004B                     } else {
_0x100019:
; 0008 004C                         *lamp_status = ON;
	MOVW R26,R18
	LDI  R30,LOW(1)
	ST   X,R30
; 0008 004D                         *lamp_timer = LONG_MAX;
	MOVW R26,R16
	LDI  R30,LOW(5)
_0x100049:
	ST   X,R30
; 0008 004E                     }
; 0008 004F                 }
; 0008 0050             }
_0x100018:
; 0008 0051             break;
_0x100017:
	RJMP _0x100010
; 0008 0052         case MEANDR:
_0x100016:
	CPI  R30,LOW(0x4)
	BRNE _0x10001B
; 0008 0053             if (*lamp_timer) {
	MOVW R26,R16
	LD   R30,X
	CPI  R30,0
	BREQ _0x10001C
; 0008 0054                 *lamp_timer = *lamp_timer - 1;
	CALL SUBOPT_0xAD
; 0008 0055                 if (*lamp_timer == 0) {
	BRNE _0x10001D
; 0008 0056                     *lamp_status = !(*lamp_status);
	MOVW R26,R18
	LD   R30,X
	CALL __LNEGB1
	ST   X,R30
; 0008 0057                     *lamp_timer = MEANDR_MAX;
	MOVW R26,R16
	LDI  R30,LOW(3)
	ST   X,R30
; 0008 0058                 }
; 0008 0059             }
_0x10001D:
; 0008 005A             break;
_0x10001C:
	RJMP _0x100010
; 0008 005B         case ON:
_0x10001B:
	CPI  R30,LOW(0x1)
	BRNE _0x10001E
; 0008 005C             *lamp_status = ON;
	MOVW R26,R18
	LDI  R30,LOW(1)
	RJMP _0x10004A
; 0008 005D             break;
; 0008 005E         case OFF:
_0x10001E:
; 0008 005F         default:
; 0008 0060             *lamp_status = OFF;
	MOVW R26,R18
	LDI  R30,LOW(0)
	ST   X,R30
; 0008 0061             *lamp_mode = OFF;
	LDD  R26,Y+4
	LDD  R27,Y+4+1
_0x10004A:
	ST   X,R30
; 0008 0062             break;
; 0008 0063     };
_0x100010:
; 0008 0064     return (*lamp_status);
	MOVW R26,R18
	LD   R30,X
	CALL __LOADLOCR4
	RJMP _0x20E0008
; 0008 0065 }
;// Функция обновления статуса
;// Вызывается только из таймера. Необходим равномерно распределенный по времени вызов.
;void update_signal_status(void) {
; 0008 0068 void update_signal_status(void) {
_update_signal_status:
; 0008 0069     switch (signals.buz_mode) {
	LDS  R30,_signals
; 0008 006A         case SHORT:
	CPI  R30,LOW(0x2)
	BREQ _0x100025
; 0008 006B         case LONG:
	CPI  R30,LOW(0x3)
	BRNE _0x100026
_0x100025:
; 0008 006C             signals.buz_status = OFF;
	LDI  R30,LOW(0)
	__PUTB1MN _signals,2
; 0008 006D             if (signals.buz_timer) {
	__GETB1MN _signals,1
	CPI  R30,0
	BREQ _0x100027
; 0008 006E                 signals.buz_timer--;
	CALL SUBOPT_0xAE
; 0008 006F                 if (signals.buz_timer) signals.buz_status = ON; else signals.buz_mode = OFF;
	BREQ _0x100028
	LDI  R30,LOW(1)
	__PUTB1MN _signals,2
	RJMP _0x100029
_0x100028:
	LDI  R30,LOW(0)
	STS  _signals,R30
; 0008 0070             }
_0x100029:
; 0008 0071             break;
_0x100027:
	RJMP _0x100023
; 0008 0072         case MEANDR:
_0x100026:
	CPI  R30,LOW(0x4)
	BRNE _0x10002D
; 0008 0073             if (signals.buz_timer) {
	__GETB1MN _signals,1
	CPI  R30,0
	BREQ _0x10002B
; 0008 0074                 signals.buz_timer--;
	CALL SUBOPT_0xAE
; 0008 0075                 if (signals.buz_timer == 0) {
	BRNE _0x10002C
; 0008 0076                     signals.buz_status = !signals.buz_status;
	__GETB1MN _signals,2
	CALL __LNEGB1
	__PUTB1MN _signals,2
; 0008 0077                     signals.buz_timer = MEANDR_MAX;
	LDI  R30,LOW(3)
	__PUTB1MN _signals,1
; 0008 0078                 }
; 0008 0079             }
_0x10002C:
; 0008 007A             break;
_0x10002B:
	RJMP _0x100023
; 0008 007B         default:
_0x10002D:
; 0008 007C             signals.buz_status = OFF;
	LDI  R30,LOW(0)
	__PUTB1MN _signals,2
; 0008 007D             signals.buz_mode = OFF;
	STS  _signals,R30
; 0008 007E             break;
; 0008 007F     }
_0x100023:
; 0008 0080     if (mode.sound) BUZ = signals.buz_status;
	__GETB1MN _mode,6
	CPI  R30,0
	BREQ _0x10002E
	__GETB1MN _signals,2
	CPI  R30,0
	BRNE _0x10002F
	CBI  0x12,6
	RJMP _0x100030
_0x10002F:
	SBI  0x12,6
_0x100030:
; 0008 0081     RED = update_lamp_status(&signals.red_mode);
_0x10002E:
	__POINTW1MN _signals,3
	CALL SUBOPT_0xAF
	BRNE _0x100031
	CBI  0x1B,3
	RJMP _0x100032
_0x100031:
	SBI  0x1B,3
_0x100032:
; 0008 0082     GREEN = update_lamp_status(&signals.green_mode);
	__POINTW1MN _signals,6
	CALL SUBOPT_0xAF
	BRNE _0x100033
	CBI  0x18,4
	RJMP _0x100034
_0x100033:
	SBI  0x18,4
_0x100034:
; 0008 0083     WHITE = update_lamp_status(&signals.white_mode);
	__POINTW1MN _signals,9
	CALL SUBOPT_0xAF
	BRNE _0x100035
	CBI  0x1B,2
	RJMP _0x100036
_0x100035:
	SBI  0x1B,2
_0x100036:
; 0008 0084     // signal_printallbytes();
; 0008 0085 }
	RET
;// Функция смены режима звукового оповещения
;void signal_buz(unsigned char signal_mode) {
; 0008 0087 void signal_buz(unsigned char signal_mode) {
_signal_buz:
; 0008 0088     signals.buz_mode = signal_mode;
;	signal_mode -> Y+0
	LD   R30,Y
	STS  _signals,R30
; 0008 0089     switch (signal_mode) {
; 0008 008A         case SHORT:
	CPI  R30,LOW(0x2)
	BRNE _0x10003A
; 0008 008B             signals.buz_timer = SHORT_MAX;
	LDI  R30,LOW(1)
	__PUTB1MN _signals,1
; 0008 008C             signals.buz_status = ON;
	__PUTB1MN _signals,2
; 0008 008D             break;
	RJMP _0x100039
; 0008 008E         case LONG:
_0x10003A:
	CPI  R30,LOW(0x3)
	BRNE _0x10003B
; 0008 008F             signals.buz_status = ON;
	LDI  R30,LOW(1)
	__PUTB1MN _signals,2
; 0008 0090             signals.buz_timer = LONG_MAX;
	LDI  R30,LOW(5)
	RJMP _0x10004B
; 0008 0091             break;
; 0008 0092         case MEANDR:
_0x10003B:
	CPI  R30,LOW(0x4)
	BRNE _0x10003D
; 0008 0093             signals.buz_status = ON;
	LDI  R30,LOW(1)
	__PUTB1MN _signals,2
; 0008 0094             signals.buz_timer = MEANDR_MAX;
	LDI  R30,LOW(3)
	RJMP _0x10004B
; 0008 0095             break;
; 0008 0096         default:
_0x10003D:
; 0008 0097             signals.buz_status = OFF;
	LDI  R30,LOW(0)
	__PUTB1MN _signals,2
; 0008 0098             signals.buz_timer = OFF;
_0x10004B:
	__PUTB1MN _signals,1
; 0008 0099             break;
; 0008 009A     };
_0x100039:
; 0008 009B     if (mode.sound) BUZ = signals.buz_status;
	__GETB1MN _mode,6
	CPI  R30,0
	BREQ _0x10003E
	__GETB1MN _signals,2
	CPI  R30,0
	BRNE _0x10003F
	CBI  0x12,6
	RJMP _0x100040
_0x10003F:
	SBI  0x12,6
_0x100040:
; 0008 009C }
_0x10003E:
	JMP  _0x20E0003
;// Функция смены режима светового оповещения красной лампочки
;void signal_red(unsigned char signal_mode) {
; 0008 009E void signal_red(unsigned char signal_mode) {
_signal_red:
; 0008 009F     signals.red_mode = signal_mode;
;	signal_mode -> Y+0
	LD   R30,Y
	__PUTB1MN _signals,3
; 0008 00A0     RED = init_lamp_status(&signals.red_mode);
	__POINTW1MN _signals,3
	CALL SUBOPT_0xB0
	BRNE _0x100041
	CBI  0x1B,3
	RJMP _0x100042
_0x100041:
	SBI  0x1B,3
_0x100042:
; 0008 00A1 }
	JMP  _0x20E0003
;// Функция смены режима светового оповещения зеленой лампочки
;void signal_green(unsigned char signal_mode) {
; 0008 00A3 void signal_green(unsigned char signal_mode) {
_signal_green:
; 0008 00A4     signals.green_mode = signal_mode;
;	signal_mode -> Y+0
	LD   R30,Y
	__PUTB1MN _signals,6
; 0008 00A5     GREEN = init_lamp_status(&signals.green_mode);
	__POINTW1MN _signals,6
	CALL SUBOPT_0xB0
	BRNE _0x100043
	CBI  0x18,4
	RJMP _0x100044
_0x100043:
	SBI  0x18,4
_0x100044:
; 0008 00A6 }
	JMP  _0x20E0003
;// Функция смены режима светового оповещения белой лампочки
;void signal_white(unsigned char signal_mode) {
; 0008 00A8 void signal_white(unsigned char signal_mode) {
_signal_white:
; 0008 00A9     signals.white_mode = signal_mode;
;	signal_mode -> Y+0
	LD   R30,Y
	__PUTB1MN _signals,9
; 0008 00AA     WHITE = init_lamp_status(&signals.white_mode);
	__POINTW1MN _signals,9
	CALL SUBOPT_0xB0
	BRNE _0x100045
	CBI  0x1B,2
	RJMP _0x100046
_0x100045:
	SBI  0x1B,2
_0x100046:
; 0008 00AB }
	JMP  _0x20E0003
;#include <mega32.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x80
	.EQU __sm_mask=0x70
	.EQU __sm_powerdown=0x20
	.EQU __sm_powersave=0x30
	.EQU __sm_standby=0x60
	.EQU __sm_ext_standby=0x70
	.EQU __sm_adc_noise_red=0x10
	.SET power_ctrl_reg=mcucr
	#endif
;#include <stdio.h>
;#include "keys.h"
;#include "robowater.h"
;#include "valcoder.h"
;#include "bits.h"
;#include "signals.h"
;#define NODEBUG
;// Состояние всех клавиш
;// Структура статуса кнопки. Устраняется дребезг и помехи.
;struct st_key {
;    signed char status;     // текущий статус кнопки (0 - off, 1 - on, -1 - идет выбор)
;    unsigned char last;     // последний статус копки
;    unsigned char is_work;  // Признак работоспособности кнопки (0 - не работает)
;    unsigned char range;  // Признак выбора 0-выбрано 1- нет
;    unsigned int on;        // кол-во 1 (см. мажоритарный клапан)
;    unsigned int off;       // кол-во 0 (см. мажоритарный клапан)
;    unsigned char reg;      // указатель на регистр кнопки
;    unsigned char pin;      // нога регистра кнопки
;} keys[NUM_KEYS]= {
;    {-1, 0, 0, 0, 0, 0, 0x33, 3},     // [0] KEY_STOP   PINC.3
;    {-1, 0, 0, 0, 0, 0, 0x33, 5},     // [1] KEY_START  PINC.5
;    {-1, 0, 0, 0, 0, 0, 0x33, 6},     // [2] KEY_ENTER  PINC.6
;    {-1, 0, 0, 0, 0, 0, 0x33, 7},     // [3] KEY_CANCEL PINC.7
;    {-1, 0, 0, 0, 0, 0, 0x33, 2},     // [4] KEY_ALARM1 PINC.2
;    {-1, 0, 0, 0, 0, 0, 0x33, 4},     // [5] KEY_ALARM2 PINC.4
;    {-1, 0, 0, 0, 0, 0, 0x36, 1}      // [6] KEY_FILTER PINB.1
;
;};

	.DSEG
;// Счетчик срабатываний таймера 1
;unsigned char t_key = 0;
;// Функция, возвращающая значение клавиши
;unsigned char key(unsigned char i) {
; 0009 0021 unsigned char key(unsigned char i) {

	.CSEG
_key:
; 0009 0022     // return ((keys[i].status == KEY_POLL) ? keys[i].last : keys[i].status);
; 0009 0023     if (i <= 3 ) {
;	i -> Y+0
	LD   R26,Y
	CPI  R26,LOW(0x4)
	BRSH _0x120004
; 0009 0024          if (keys[i].status == KEY_POLL) {
	CALL SUBOPT_0xB1
	CPI  R30,LOW(0xFF)
	BRNE _0x120005
; 0009 0025                 return KEY_OFF;
	LDI  R30,LOW(1)
	JMP  _0x20E0003
; 0009 0026          } else {
_0x120005:
; 0009 0027                 if (keys[i].status == KEY_ON) {
	CALL SUBOPT_0xB1
	CPI  R30,0
	BRNE _0x120007
; 0009 0028                     //printf ("кнопкa #%d. Статус = %d\r\n", i, key_treated[i]);
; 0009 0029                     if (key_treated[i] == 0) {
	CALL SUBOPT_0xB2
	LD   R30,Z
	CPI  R30,0
	BRNE _0x120008
; 0009 002A                         signal_buz(SHORT);
	CALL SUBOPT_0x2A
; 0009 002B                         return KEY_ON;
	LDI  R30,LOW(0)
	JMP  _0x20E0003
; 0009 002C                     } else return KEY_OFF;
_0x120008:
	LDI  R30,LOW(1)
	JMP  _0x20E0003
; 0009 002D                  }
; 0009 002E                 if (keys[i].status == KEY_OFF) {
_0x120007:
	CALL SUBOPT_0xB1
	CPI  R30,LOW(0x1)
	BRNE _0x12000A
; 0009 002F                     key_treated[i] = 0;
	CALL SUBOPT_0xB2
	LDI  R26,LOW(0)
	STD  Z+0,R26
; 0009 0030                     //printf ("Опросили кнопку #%d. Статус = %d\r\n", i, key_treated[i]);
; 0009 0031                     return KEY_OFF;
	LDI  R30,LOW(1)
	JMP  _0x20E0003
; 0009 0032                   }
; 0009 0033          }
_0x12000A:
; 0009 0034     } else {
	RJMP _0x12000B
_0x120004:
; 0009 0035         if (keys[i].status == KEY_POLL) {
	CALL SUBOPT_0xB1
	CPI  R30,LOW(0xFF)
	BRNE _0x12000C
; 0009 0036             return (keys[i].last);
	LD   R30,Y
	CALL SUBOPT_0xB3
	LD   R30,Z
	JMP  _0x20E0003
; 0009 0037         } else {
_0x12000C:
; 0009 0038             //signal_buz(SHORT);
; 0009 0039             return (keys[i].status);
	CALL SUBOPT_0xB1
	JMP  _0x20E0003
; 0009 003A         }
; 0009 003B     }
_0x12000B:
; 0009 003C }
	RJMP _0x20E0003
;// Функция инициализации всех кнопок
;void init_keys(void) {
; 0009 003E void init_keys(void) {
_init_keys:
; 0009 003F     register unsigned char i;
; 0009 0040     for (i=0; i<NUM_KEYS; i++) {
	ST   -Y,R16
;	i -> R16
	LDI  R16,LOW(0)
_0x12000F:
	CPI  R16,7
	BRSH _0x120010
; 0009 0041         t_key = KEY_INACTIVE;
	LDI  R30,LOW(10)
	STS  _t_key,R30
; 0009 0042         while (keys[i].status == KEY_POLL) {
_0x120011:
	CALL SUBOPT_0xB4
	BRNE _0x120013
; 0009 0043             poll_key(i);
	ST   -Y,R16
	RCALL _poll_key
; 0009 0044             if(keys[i].status != KEY_POLL && keys[i].last != keys[i].status) {
	CALL SUBOPT_0xB4
	BREQ _0x120015
	LDI  R26,LOW(10)
	MUL  R16,R26
	MOVW R30,R0
	__ADDW1MN _keys,1
	LD   R22,Z
	CALL SUBOPT_0xB5
	MOV  R26,R22
	LDI  R27,0
	LDI  R31,0
	SBRC R30,7
	SER  R31
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x120016
_0x120015:
	RJMP _0x120014
_0x120016:
; 0009 0045                 keys[i].last = keys[i].status;
	LDI  R26,LOW(10)
	MUL  R16,R26
	MOVW R30,R0
	__ADDW1MN _keys,1
	MOVW R22,R30
	CALL SUBOPT_0xB5
	MOVW R26,R22
	ST   X,R30
; 0009 0046                 keys[i].status = KEY_POLL;
	LDI  R26,LOW(10)
	MUL  R16,R26
	MOVW R30,R0
	CALL SUBOPT_0xB6
; 0009 0047                 if (t_key == 0) break;        // printf ("сработал таймер\r\n");
	LDS  R30,_t_key
	CPI  R30,0
	BREQ _0x120013
; 0009 0048             } else {
	RJMP _0x120018
_0x120014:
; 0009 0049                 keys[i].is_work = 1;
	LDI  R26,LOW(10)
	MUL  R16,R26
	MOVW R30,R0
	__ADDW1MN _keys,2
	LDI  R26,LOW(1)
	STD  Z+0,R26
; 0009 004A             }
_0x120018:
; 0009 004B         }
	RJMP _0x120011
_0x120013:
; 0009 004C         //printf ("Опросили кнопку #%d. Статус = %d\r\n", i, keys[i].status);
; 0009 004D     }
	SUBI R16,-1
	RJMP _0x12000F
_0x120010:
; 0009 004E }
	RJMP _0x20E0009
;// Функция опроса всех кнопок
;void poll_keys(void) {
; 0009 0050 void poll_keys(void) {
_poll_keys:
; 0009 0051     register unsigned char i;
; 0009 0052     #ifndef NODEBUG
; 0009 0053     // printf ("Опрос всех кнопок (NUM_KEYS)\r\n");
; 0009 0054     #endif
; 0009 0055     for (i=0; i<NUM_KEYS; i++) {
	ST   -Y,R16
;	i -> R16
	LDI  R16,LOW(0)
_0x12001A:
	CPI  R16,7
	BRSH _0x12001B
; 0009 0056         poll_key(i);    // if keys[i].status
	ST   -Y,R16
	RCALL _poll_key
; 0009 0057         //if (key(i) != keys[i].last)
; 0009 0058         // printf("Нажата кнопка #%d\r\n", i);
; 0009 0059     }
	SUBI R16,-1
	RJMP _0x12001A
_0x12001B:
; 0009 005A }
_0x20E0009:
	LD   R16,Y+
	RET
;// Опрос конкретной кнопки
;void poll_key(unsigned char i) {
; 0009 005C void poll_key(unsigned char i) {
_poll_key:
; 0009 005D     unsigned char pin_val = 0;
; 0009 005E     union reg_port {
; 0009 005F         unsigned char num[2];
; 0009 0060         unsigned int *p;
; 0009 0061     } curr_port;
; 0009 0062 
; 0009 0063     curr_port.num[0] = keys[i].reg; curr_port.num[1] = 0;
	SBIW R28,2
	ST   -Y,R16
;	i -> Y+3
;	pin_val -> R16
;	reg_port -> Y+3
;	curr_port -> Y+1
	LDI  R16,0
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,8
	LD   R30,Z
	STD  Y+1,R30
	LDI  R30,LOW(0)
	STD  Y+2,R30
; 0009 0064     // printf ("Опрашиваем клавишу 0x%x, нога %d", keys[i].reg, keys[i].pin);
; 0009 0065     pin_val = BITSET(*(curr_port.p), keys[i].pin) >> keys[i].pin;
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R22,X+
	LD   R23,X
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,9
	LD   R30,Z
	LDI  R26,LOW(1)
	CALL __LSLB12
	LDI  R31,0
	__ANDWRR 22,23,30,31
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,9
	LD   R30,Z
	MOVW R26,R22
	CALL __LSRW12
	MOV  R16,R30
; 0009 0066     // printf (", результат 0x%x\r\n", pin_val);
; 0009 0067     switch (keys[i].status) {
	CALL SUBOPT_0xB7
	SUBI R30,LOW(-_keys)
	SBCI R31,HIGH(-_keys)
	LD   R30,Z
; 0009 0068         case KEY_ON:
	CPI  R30,0
	BRNE _0x12001F
; 0009 0069             if (pin_val == KEY_OFF) {
	CPI  R16,1
	BRNE _0x120020
; 0009 006A                 keys[i].status = KEY_POLL;
	CALL SUBOPT_0xB7
	CALL SUBOPT_0xB6
; 0009 006B                 VALCODER_DISABLE();
	IN   R30,0x3B
	ANDI R30,LOW(0x3F)
	OUT  0x3B,R30
; 0009 006C                 keys[i].on = 0;
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,4
	CALL SUBOPT_0xA7
; 0009 006D                 keys[i].off = 1;
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,6
	CALL SUBOPT_0xA9
; 0009 006E                 keys[i].last = KEY_ON;
	LDD  R30,Y+3
	CALL SUBOPT_0xB3
	LDI  R26,LOW(0)
	STD  Z+0,R26
; 0009 006F             }
; 0009 0070             break;
_0x120020:
	RJMP _0x12001E
; 0009 0071         case KEY_OFF:
_0x12001F:
	CPI  R30,LOW(0x1)
	BRNE _0x120021
; 0009 0072             if (pin_val == KEY_ON) {
	CPI  R16,0
	BRNE _0x120022
; 0009 0073                 keys[i].status = KEY_POLL;
	CALL SUBOPT_0xB7
	CALL SUBOPT_0xB6
; 0009 0074                 VALCODER_DISABLE();
	IN   R30,0x3B
	ANDI R30,LOW(0x3F)
	OUT  0x3B,R30
; 0009 0075                 keys[i].on = 1;
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,4
	CALL SUBOPT_0xA9
; 0009 0076                 keys[i].off = 0;
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,6
	CALL SUBOPT_0xA7
; 0009 0077                 keys[i].last = KEY_OFF;
	LDD  R30,Y+3
	CALL SUBOPT_0xB3
	LDI  R26,LOW(1)
	STD  Z+0,R26
; 0009 0078             }
; 0009 0079             break;
_0x120022:
	RJMP _0x12001E
; 0009 007A         case KEY_POLL:
_0x120021:
	CPI  R30,LOW(0xFFFFFFFF)
	BRNE _0x12002D
; 0009 007B             (pin_val == KEY_ON) ? keys[i].on++ : keys[i].off++;
	CPI  R16,0
	BRNE _0x120024
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,4
	RJMP _0x12002E
_0x120024:
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,6
_0x12002E:
	MOVW R26,R30
	CALL SUBOPT_0xA8
; 0009 007C             // Выборы окончены?
; 0009 007D             if (keys[i].on >= MAX_POLL || keys[i].off >= MAX_POLL) {
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,4
	CALL SUBOPT_0xB8
	BRSH _0x120028
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,6
	CALL SUBOPT_0xB8
	BRLO _0x120027
_0x120028:
; 0009 007E                 keys[i].status = (keys[i].on > keys[i].off) ? KEY_ON : KEY_OFF;
	CALL SUBOPT_0xB7
	SUBI R30,LOW(-_keys)
	SBCI R31,HIGH(-_keys)
	MOVW R24,R30
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,4
	LD   R22,Z
	LDD  R23,Z+1
	CALL SUBOPT_0xB7
	__ADDW1MN _keys,6
	MOVW R26,R30
	CALL __GETW1P
	CP   R30,R22
	CPC  R31,R23
	BRSH _0x12002A
	LDI  R30,LOW(0)
	RJMP _0x12002B
_0x12002A:
	LDI  R30,LOW(1)
_0x12002B:
	MOVW R26,R24
	ST   X,R30
; 0009 007F                 //printf(".");
; 0009 0080                 VALCODER_ENABLE();
	IN   R30,0x3B
	ORI  R30,LOW(0xC0)
	OUT  0x3B,R30
; 0009 0081                 // if (keys[i].status != keys[i].last)
; 0009 0082                     // printf ("Адрес: 0x%x, Нога: %d, Значение: %d, предыдущее значение %d\r\n",
; 0009 0083                     //     keys[i].reg, keys[i].pin, keys[i].status, keys[i].last);
; 0009 0084             }
; 0009 0085             break;
_0x120027:
; 0009 0086         default:
_0x12002D:
; 0009 0087     };
_0x12001E:
; 0009 0088 }
	LDD  R16,Y+0
	ADIW R28,4
	RET

	.CSEG
_rtc_init:
	LDD  R30,Y+2
	ANDI R30,LOW(0x3)
	STD  Y+2,R30
	LDD  R30,Y+1
	CPI  R30,0
	BREQ _0x2000003
	LDD  R30,Y+2
	ORI  R30,0x10
	STD  Y+2,R30
_0x2000003:
	LD   R30,Y
	CPI  R30,0
	BREQ _0x2000004
	LDD  R30,Y+2
	ORI  R30,0x80
	STD  Y+2,R30
_0x2000004:
	CALL SUBOPT_0xB9
	LDI  R30,LOW(7)
	CALL SUBOPT_0xBA
	RJMP _0x20E0005
_rtc_get_time:
	CALL SUBOPT_0xB9
	LDI  R30,LOW(0)
	CALL SUBOPT_0xA4
	CALL SUBOPT_0xBB
	CALL SUBOPT_0x7E
	CALL SUBOPT_0xBC
	ST   -Y,R30
	CALL _bcd2bin
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	RJMP _0x20E0007
_rtc_set_time:
	CALL SUBOPT_0xB9
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _i2c_write
	LD   R30,Y
	ST   -Y,R30
	CALL _bin2bcd
	CALL SUBOPT_0xA3
	CALL _bin2bcd
	CALL SUBOPT_0xBA
	RJMP _0x20E0004
_rtc_get_date:
	CALL SUBOPT_0xB9
	LDI  R30,LOW(4)
	CALL SUBOPT_0xA4
	CALL SUBOPT_0xBB
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ST   X,R30
	LDI  R30,LOW(1)
	CALL SUBOPT_0xBC
	ST   -Y,R30
	CALL _bcd2bin
	LD   R26,Y
	LDD  R27,Y+1
_0x20E0007:
	ST   X,R30
	CALL _i2c_stop
_0x20E0008:
	ADIW R28,6
	RET
_rtc_set_date:
	CALL SUBOPT_0xB9
	LDI  R30,LOW(4)
	CALL SUBOPT_0xBA
	ST   -Y,R30
	CALL _bin2bcd
	CALL SUBOPT_0xA3
	CALL _bin2bcd
	ST   -Y,R30
	CALL _i2c_write
	LD   R30,Y
_0x20E0004:
	ST   -Y,R30
	CALL _bin2bcd
_0x20E0005:
	ST   -Y,R30
	CALL _i2c_write
	CALL _i2c_stop
_0x20E0006:
	ADIW R28,3
	RET
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x80
	.EQU __sm_mask=0x70
	.EQU __sm_powerdown=0x20
	.EQU __sm_powersave=0x30
	.EQU __sm_standby=0x60
	.EQU __sm_ext_standby=0x70
	.EQU __sm_adc_noise_red=0x10
	.SET power_ctrl_reg=mcucr
	#endif

	.CSEG
_putchar:
     sbis usr,udre
     rjmp _putchar
     ld   r30,y
     out  udr,r30
_0x20E0003:
	ADIW R28,1
	RET
__put_G101:
	ST   -Y,R17
	ST   -Y,R16
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL __GETW1P
	SBIW R30,0
	BREQ _0x2020010
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	CALL __GETW1P
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x2020012
	__CPWRN 16,17,2
	BRLO _0x2020013
	MOVW R30,R16
	SBIW R30,1
	MOVW R16,R30
	ST   X+,R30
	ST   X,R31
_0x2020012:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL SUBOPT_0xA8
	LDD  R26,Y+6
	STD  Z+0,R26
_0x2020013:
	RJMP _0x2020014
_0x2020010:
	LDD  R30,Y+6
	ST   -Y,R30
	RCALL _putchar
_0x2020014:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E0002:
	ADIW R28,7
	RET
__print_G101:
	SBIW R28,6
	CALL __SAVELOCR6
	LDI  R16,0
_0x2020015:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ADIW R30,1
	STD  Y+18,R30
	STD  Y+18+1,R31
	SBIW R30,1
	LPM  R30,Z
	MOV  R19,R30
	CPI  R30,0
	BRNE PC+3
	JMP _0x2020017
	MOV  R30,R16
	CPI  R30,0
	BRNE _0x202001B
	CPI  R19,37
	BRNE _0x202001C
	LDI  R16,LOW(1)
	RJMP _0x202001D
_0x202001C:
	CALL SUBOPT_0xBD
_0x202001D:
	RJMP _0x202001A
_0x202001B:
	CPI  R30,LOW(0x1)
	BRNE _0x202001E
	CPI  R19,37
	BRNE _0x202001F
	CALL SUBOPT_0xBD
	RJMP _0x20200BC
_0x202001F:
	LDI  R16,LOW(2)
	LDI  R21,LOW(0)
	LDI  R17,LOW(0)
	CPI  R19,45
	BRNE _0x2020020
	LDI  R17,LOW(1)
	RJMP _0x202001A
_0x2020020:
	CPI  R19,43
	BRNE _0x2020021
	LDI  R21,LOW(43)
	RJMP _0x202001A
_0x2020021:
	CPI  R19,32
	BRNE _0x2020022
	LDI  R21,LOW(32)
	RJMP _0x202001A
_0x2020022:
	RJMP _0x2020023
_0x202001E:
	CPI  R30,LOW(0x2)
	BRNE _0x2020024
_0x2020023:
	LDI  R20,LOW(0)
	LDI  R16,LOW(3)
	CPI  R19,48
	BRNE _0x2020025
	ORI  R17,LOW(128)
	RJMP _0x202001A
_0x2020025:
	RJMP _0x2020026
_0x2020024:
	CPI  R30,LOW(0x3)
	BREQ PC+3
	JMP _0x202001A
_0x2020026:
	CPI  R19,48
	BRLO _0x2020029
	CPI  R19,58
	BRLO _0x202002A
_0x2020029:
	RJMP _0x2020028
_0x202002A:
	MOV  R26,R20
	LDI  R30,LOW(10)
	MUL  R30,R26
	MOVW R30,R0
	MOV  R20,R30
	MOV  R30,R19
	SUBI R30,LOW(48)
	ADD  R20,R30
	RJMP _0x202001A
_0x2020028:
	MOV  R30,R19
	CPI  R30,LOW(0x63)
	BRNE _0x202002E
	CALL SUBOPT_0xBE
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	LDD  R26,Z+4
	ST   -Y,R26
	CALL SUBOPT_0xBF
	RJMP _0x202002F
_0x202002E:
	CPI  R30,LOW(0x73)
	BRNE _0x2020031
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xC0
	CALL _strlen
	MOV  R16,R30
	RJMP _0x2020032
_0x2020031:
	CPI  R30,LOW(0x70)
	BRNE _0x2020034
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xC0
	CALL _strlenf
	MOV  R16,R30
	ORI  R17,LOW(8)
_0x2020032:
	ORI  R17,LOW(2)
	ANDI R17,LOW(127)
	LDI  R18,LOW(0)
	RJMP _0x2020035
_0x2020034:
	CPI  R30,LOW(0x64)
	BREQ _0x2020038
	CPI  R30,LOW(0x69)
	BRNE _0x2020039
_0x2020038:
	ORI  R17,LOW(4)
	RJMP _0x202003A
_0x2020039:
	CPI  R30,LOW(0x75)
	BRNE _0x202003B
_0x202003A:
	LDI  R30,LOW(_tbl10_G101*2)
	LDI  R31,HIGH(_tbl10_G101*2)
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDI  R16,LOW(5)
	RJMP _0x202003C
_0x202003B:
	CPI  R30,LOW(0x58)
	BRNE _0x202003E
	ORI  R17,LOW(8)
	RJMP _0x202003F
_0x202003E:
	CPI  R30,LOW(0x78)
	BREQ PC+3
	JMP _0x2020070
_0x202003F:
	LDI  R30,LOW(_tbl16_G101*2)
	LDI  R31,HIGH(_tbl16_G101*2)
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDI  R16,LOW(4)
_0x202003C:
	SBRS R17,2
	RJMP _0x2020041
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xC1
	LDD  R26,Y+11
	TST  R26
	BRPL _0x2020042
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL __ANEGW1
	STD  Y+10,R30
	STD  Y+10+1,R31
	LDI  R21,LOW(45)
_0x2020042:
	CPI  R21,0
	BREQ _0x2020043
	SUBI R16,-LOW(1)
	RJMP _0x2020044
_0x2020043:
	ANDI R17,LOW(251)
_0x2020044:
	RJMP _0x2020045
_0x2020041:
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xC1
_0x2020045:
_0x2020035:
	SBRC R17,0
	RJMP _0x2020046
_0x2020047:
	CP   R16,R20
	BRSH _0x2020049
	SBRS R17,7
	RJMP _0x202004A
	SBRS R17,2
	RJMP _0x202004B
	ANDI R17,LOW(251)
	MOV  R19,R21
	SUBI R16,LOW(1)
	RJMP _0x202004C
_0x202004B:
	LDI  R19,LOW(48)
_0x202004C:
	RJMP _0x202004D
_0x202004A:
	LDI  R19,LOW(32)
_0x202004D:
	CALL SUBOPT_0xBD
	SUBI R20,LOW(1)
	RJMP _0x2020047
_0x2020049:
_0x2020046:
	MOV  R18,R16
	SBRS R17,1
	RJMP _0x202004E
_0x202004F:
	CPI  R18,0
	BREQ _0x2020051
	SBRS R17,3
	RJMP _0x2020052
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	SBIW R30,1
	LPM  R30,Z
	RJMP _0x20200BD
_0x2020052:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R30,X+
	STD  Y+6,R26
	STD  Y+6+1,R27
_0x20200BD:
	ST   -Y,R30
	CALL SUBOPT_0xBF
	CPI  R20,0
	BREQ _0x2020054
	SUBI R20,LOW(1)
_0x2020054:
	SUBI R18,LOW(1)
	RJMP _0x202004F
_0x2020051:
	RJMP _0x2020055
_0x202004E:
_0x2020057:
	LDI  R19,LOW(48)
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL __GETW1PF
	STD  Y+8,R30
	STD  Y+8+1,R31
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,2
	STD  Y+6,R30
	STD  Y+6+1,R31
_0x2020059:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x202005B
	SUBI R19,-LOW(1)
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	SUB  R30,R26
	SBC  R31,R27
	STD  Y+10,R30
	STD  Y+10+1,R31
	RJMP _0x2020059
_0x202005B:
	CPI  R19,58
	BRLO _0x202005C
	SBRS R17,3
	RJMP _0x202005D
	SUBI R19,-LOW(7)
	RJMP _0x202005E
_0x202005D:
	SUBI R19,-LOW(39)
_0x202005E:
_0x202005C:
	SBRC R17,4
	RJMP _0x2020060
	CPI  R19,49
	BRSH _0x2020062
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,1
	BRNE _0x2020061
_0x2020062:
	RJMP _0x20200BE
_0x2020061:
	CP   R20,R18
	BRLO _0x2020066
	SBRS R17,0
	RJMP _0x2020067
_0x2020066:
	RJMP _0x2020065
_0x2020067:
	LDI  R19,LOW(32)
	SBRS R17,7
	RJMP _0x2020068
	LDI  R19,LOW(48)
_0x20200BE:
	ORI  R17,LOW(16)
	SBRS R17,2
	RJMP _0x2020069
	ANDI R17,LOW(251)
	ST   -Y,R21
	CALL SUBOPT_0xBF
	CPI  R20,0
	BREQ _0x202006A
	SUBI R20,LOW(1)
_0x202006A:
_0x2020069:
_0x2020068:
_0x2020060:
	CALL SUBOPT_0xBD
	CPI  R20,0
	BREQ _0x202006B
	SUBI R20,LOW(1)
_0x202006B:
_0x2020065:
	SUBI R18,LOW(1)
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,2
	BRLO _0x2020058
	RJMP _0x2020057
_0x2020058:
_0x2020055:
	SBRS R17,0
	RJMP _0x202006C
_0x202006D:
	CPI  R20,0
	BREQ _0x202006F
	SUBI R20,LOW(1)
	LDI  R30,LOW(32)
	ST   -Y,R30
	CALL SUBOPT_0xBF
	RJMP _0x202006D
_0x202006F:
_0x202006C:
_0x2020070:
_0x202002F:
_0x20200BC:
	LDI  R16,LOW(0)
_0x202001A:
	RJMP _0x2020015
_0x2020017:
	CALL __LOADLOCR6
	ADIW R28,20
	RET
_sprintf:
	PUSH R15
	CALL SUBOPT_0xC2
	MOVW R26,R28
	ADIW R26,6
	CALL __ADDW2R15
	CALL __GETW1P
	STD  Y+2,R30
	STD  Y+2+1,R31
	CALL SUBOPT_0xC3
	CALL SUBOPT_0xC4
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(0)
	ST   X,R30
	RJMP _0x20E0001
_printf:
	PUSH R15
	CALL SUBOPT_0xC2
	LDI  R30,LOW(0)
	STD  Y+2,R30
	STD  Y+2+1,R30
	CALL SUBOPT_0xC3
	CALL SUBOPT_0xC4
_0x20E0001:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,4
	POP  R15
	RET

	.CSEG
_abs:
    ld   r30,y+
    ld   r31,y+
    sbiw r30,0
    brpl __abs0
    com  r30
    com  r31
    adiw r30,1
__abs0:
    ret

	.DSEG

	.CSEG

	.CSEG
_strcpy:
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
strcpy0:
    ld   r22,z+
    st   x+,r22
    tst  r22
    brne strcpy0
    movw r30,r24
    ret
_strcpyf:
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
strcpyf0:
	lpm  r0,z+
    st   x+,r0
    tst  r0
    brne strcpyf0
    movw r30,r24
    ret
_strlen:
    ld   r26,y+
    ld   r27,y+
    clr  r30
    clr  r31
strlen0:
    ld   r22,x+
    tst  r22
    breq strlen1
    adiw r30,1
    rjmp strlen0
strlen1:
    ret
_strlenf:
    clr  r26
    clr  r27
    ld   r30,y+
    ld   r31,y+
strlenf0:
    lpm  r0,z+
    tst  r0
    breq strlenf1
    adiw r26,1
    rjmp strlenf0
strlenf1:
    movw r30,r26
    ret

	.CSEG
_bcd2bin:
    ld   r30,y
    swap r30
    andi r30,0xf
    mov  r26,r30
    lsl  r26
    lsl  r26
    add  r30,r26
    lsl  r30
    ld   r26,y+
    andi r26,0xf
    add  r30,r26
    ret
_bin2bcd:
    ld   r26,y+
    clr  r30
bin2bcd0:
    subi r26,10
    brmi bin2bcd1
    subi r30,-16
    rjmp bin2bcd0
bin2bcd1:
    subi r26,-10
    add  r30,r26
    ret

	.CSEG

	.CSEG

	.DSEG
_prim_par:
	.BYTE 0x58
_mode:
	.BYTE 0x13
_event:
	.BYTE 0x1
_s_dt:
	.BYTE 0x6
_time_integration:
	.BYTE 0x2
_timer1_valcoder:
	.BYTE 0x1
_timer_start:
	.BYTE 0x2
_timer_stop:
	.BYTE 0x1
_timer_fan:
	.BYTE 0x1
_count_fan:
	.BYTE 0x1
___ds1820_scratch_pad:
	.BYTE 0x9
_termometers:
	.BYTE 0x18
_ds1820_rom_codes:
	.BYTE 0x24
_valcoder:
	.BYTE 0x1
_linestr:
	.BYTE 0x14
_main_menu:
	.BYTE 0x23
_parameters:
	.BYTE 0x37
_alerts:
	.BYTE 0x3C
_curr_menu:
	.BYTE 0xB
_t_key:
	.BYTE 0x1
_key_treated:
	.BYTE 0x7
_error_w_stop_S0020003:
	.BYTE 0x2
_dState_S0020006:
	.BYTE 0x2
_iState_S0020006:
	.BYTE 0x2
_dt_curr_menu:
	.BYTE 0xB
_sdt:
	.BYTE 0x23
_settings:
	.BYTE 0x55
_menustr_S005000C:
	.BYTE 0x10
_alarm:
	.BYTE 0x20
_alert_string_S0070006:
	.BYTE 0x10
_signals:
	.BYTE 0xC
_keys:
	.BYTE 0x46
__seed_G102:
	.BYTE 0x4
_p_S1030024:
	.BYTE 0x2

	.CSEG
;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0x0:
	ST   -Y,R0
	ST   -Y,R1
	ST   -Y,R15
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R24
	ST   -Y,R25
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 34 TIMES, CODE SIZE REDUCTION:129 WORDS
SUBOPT_0x1:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R24,0
	CALL _printf
	ADIW R28,2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2:
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _signal_green

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x3:
	LDI  R30,LOW(0)
	__PUTB1MN _mode,1
	__PUTB1MN _mode,4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x4:
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _signal_green

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x5:
	LDS  R30,_time_integration
	LDS  R31,_time_integration+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x6:
	LDI  R30,LOW(200)
	LDI  R31,HIGH(200)
	ST   -Y,R31
	ST   -Y,R30
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x7:
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x8:
	LDI  R30,LOW(240)
	ST   -Y,R30
	LDI  R30,LOW(_ds1820_rom_codes)
	LDI  R31,HIGH(_ds1820_rom_codes)
	ST   -Y,R31
	ST   -Y,R30
	JMP  _w1_search

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x9:
	__GETB1MN _prim_par,51
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 30 TIMES, CODE SIZE REDUCTION:55 WORDS
SUBOPT_0xA:
	LDI  R24,4
	CALL _printf
	ADIW R28,6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xB:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC:
	LDI  R30,LOW(_main_menu)
	LDI  R31,HIGH(_main_menu)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD:
	LDI  R30,LOW(7)
	ST   -Y,R30
	JMP  _init_curr_menu

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE:
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _signal_red
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _signal_buz

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xF:
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _signal_white

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x10:
	SBI  0x18,6
	__DELAY_USW 230
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x11:
	CALL _lcd_e_toggle_G001
	__DELAY_USB 79
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x12:
	LDI  R24,12
	CALL _printf
	ADIW R28,14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x13:
	LDI  R30,LOW(3)
	ST   -Y,R30
	CALL _key
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x14:
	LDI  R30,LOW(2)
	ST   -Y,R30
	CALL _key
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x15:
	LDI  R30,LOW(4)
	__PUTB1MN _prim_par,51
	CALL _sync_ds1820_eeprom
	ST   Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x16:
	LDI  R30,LOW(_prim_par)
	LDI  R31,HIGH(_prim_par)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x17:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+2
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RJMP SUBOPT_0xA

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x18:
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _read_all_terms

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x19:
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _sync_set_par

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x1A:
	__POINTW2MN _parameters,40
	__GETB1MN _prim_par,13
	LDI  R31,0
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1B:
	__GETW1MN _prim_par,30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x1C:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _abs

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x1D:
	__GETW1MN _parameters,10
	CALL __CWD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x1E:
	__CPD1N 0x1F4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:39 WORDS
SUBOPT_0x1F:
	__GETD2N 0x1F4
	CALL __SUBD21
	__GETW1MN _mode,7
	CALL __CWD1
	CALL __MULD12
	MOVW R26,R30
	MOVW R24,R22
	__GETD1N 0x3E8
	CALL __DIVD21
	MOV  R6,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x20:
	__GETW2MN _parameters,30
	MOV  R30,R6
	LDI  R31,0
	CP   R26,R30
	CPC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x21:
	ST   -Y,R31
	ST   -Y,R30
	__GETW1MN _parameters,40
	CALL __CWD1
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x22:
	__GETW1MN _parameters,30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 63 TIMES, CODE SIZE REDUCTION:121 WORDS
SUBOPT_0x23:
	CALL __CWD1
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x24:
	LDI  R24,8
	CALL _printf
	ADIW R28,10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x25:
	LDI  R31,0
	SBRC R30,7
	SER  R31
	RJMP SUBOPT_0x1C

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x26:
	ST   -Y,R30
	CALL _key
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x27:
	RCALL SUBOPT_0x5
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 56 TIMES, CODE SIZE REDUCTION:162 WORDS
SUBOPT_0x28:
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x29:
	LDS  R30,_mode
	SUBI R30,-LOW(1)
	STS  _mode,R30
	SUBI R30,LOW(1)
	ST   -Y,R30
	JMP  _lcd_menu

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x2A:
	LDI  R30,LOW(2)
	ST   -Y,R30
	JMP  _signal_buz

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x2B:
	LDS  R30,_mode
	SUBI R30,LOW(1)
	STS  _mode,R30
	JMP  _lcd_esc_edit

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2C:
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _signal_white

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x2D:
	__GETW1MN _prim_par,22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:41 WORDS
SUBOPT_0x2E:
	__POINTW1MN _parameters,30
	LDI  R26,LOW(255)
	LDI  R27,HIGH(255)
	STD  Z+0,R26
	STD  Z+1,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x2F:
	__GETW2MN _parameters,40
	CPI  R26,LOW(0x67)
	LDI  R30,HIGH(0x67)
	CPC  R27,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x30:
	__POINTW1MN _parameters,40
	LDI  R26,LOW(102)
	LDI  R27,HIGH(102)
	STD  Z+0,R26
	STD  Z+1,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x31:
	LDI  R30,LOW(0)
	STS  _time_integration,R30
	STS  _time_integration+1,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x32:
	LDI  R30,LOW(3)
	ST   -Y,R30
	JMP  _signal_buz

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x33:
	LDI  R30,LOW(2)
	ST   -Y,R30
	JMP  _signal_green

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x34:
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL _signal_red
	LDI  R30,LOW(4)
	ST   -Y,R30
	JMP  _signal_buz

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x35:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x36:
	ST   -Y,R30
	CALL _get_alert_str
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x37:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:63 WORDS
SUBOPT_0x38:
	CALL _get_alert_str
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RJMP SUBOPT_0xA

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x39:
	__POINTW1FN _0x40000,594
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3A:
	ST   -Y,R30
	CALL _alarm_reg
	RJMP SUBOPT_0x34

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3B:
	LDI  R30,LOW(5)
	LDI  R31,HIGH(5)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x3C:
	LDI  R31,0
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0x3D:
	ST   -Y,R30
	CALL _alarm_reg
	LDI  R30,LOW(3)
	ST   -Y,R30
	CALL _signal_red
	LDI  R30,LOW(4)
	ST   -Y,R30
	CALL _signal_buz
	RJMP SUBOPT_0x4

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3E:
	__GETW1MN _prim_par,34
	STS  _parameters,R30
	STS  _parameters+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0x3F:
	LDI  R31,0
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x40:
	__POINTW2MN _parameters,50
	__GETB1MN _mode,3
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x41:
	LDI  R30,LOW(100)
	LDI  R31,HIGH(100)
	CALL __DIVW21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x42:
	__GETW1MN _prim_par,28
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x43:
	MOVW R18,R30
	__GETW2MN _parameters,20
	CP   R16,R26
	CPC  R17,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x44:
	LDS  R26,_error_w_stop_S0020003
	LDS  R27,_error_w_stop_S0020003+1
	ADD  R30,R26
	ADC  R31,R27
	__PUTW1MN _parameters,30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x45:
	__POINTW2MN _parameters,30
	MOV  R30,R6
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x46:
	__GETW2MN _parameters,30
	CPI  R26,LOW(0x100)
	LDI  R30,HIGH(0x100)
	CPC  R27,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x47:
	__GETW2MN _parameters,20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x48:
	ST   -Y,R31
	ST   -Y,R30
	LDS  R30,_error_w_stop_S0020003
	LDS  R31,_error_w_stop_S0020003+1
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x49:
	__GETW1MN _parameters,25
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x4A:
	LDI  R30,LOW(10)
	LDI  R31,HIGH(10)
	CALL __DIVW21
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x4B:
	LDI  R24,20
	CALL _printf
	ADIW R28,22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x4C:
	__GETW1MN _parameters,5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x4D:
	LDS  R30,_parameters
	LDS  R31,_parameters+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x4E:
	LDS  R30,_count_fan
	SUBI R30,-LOW(1)
	STS  _count_fan,R30
	LDS  R26,_count_fan
	CPI  R26,LOW(0x5)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x4F:
	__GETW1MN _parameters,40
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x50:
	__PUTW1MN _parameters,40
	LDI  R30,LOW(0)
	STS  _count_fan,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x51:
	__GETW1MN _parameters,35
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x52:
	LDI  R24,16
	CALL _printf
	ADIW R28,18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x53:
	__GETW2MN _parameters,40
	__GETB1MN _prim_par,13
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x54:
	__GETW1MN _prim_par,16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x55:
	CALL __MULW12
	MOVW R26,R30
	LDI  R30,LOW(255)
	LDI  R31,HIGH(255)
	CALL __DIVW21
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x56:
	LDS  R26,_iState_S0020006
	LDS  R27,_iState_S0020006+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x57:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	RCALL SUBOPT_0x56
	CP   R30,R26
	CPC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x58:
	ST   -Y,R31
	ST   -Y,R30
	LDS  R30,_s_dt
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x59:
	__GETB1MN _s_dt,1
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5A:
	__GETB1MN _s_dt,2
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x5B:
	LDI  R26,LOW(9)
	MUL  R18,R26
	MOVW R30,R0
	SUBI R30,LOW(-_ds1820_rom_codes)
	SBCI R31,HIGH(-_ds1820_rom_codes)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5C:
	LDI  R30,LOW(100)
	LDI  R31,HIGH(100)
	CALL __MODW21
	RJMP SUBOPT_0x1C

;OPTIMIZER ADDED SUBROUTINE, CALLED 33 TIMES, CODE SIZE REDUCTION:61 WORDS
SUBOPT_0x5D:
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:18 WORDS
SUBOPT_0x5E:
	CALL __CBD1
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x5F:
	__POINTW1FN _0x40000,23
	RJMP SUBOPT_0x1

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x60:
	LDI  R26,LOW(6)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,LOW(-_termometers)
	SBCI R31,HIGH(-_termometers)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x61:
	__POINTW2MN _prim_par,36
	CLR  R30
	ADD  R26,R16
	ADC  R27,R30
	LD   R30,X
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x62:
	MOVW R30,R28
	ADIW R30,5
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x63:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R24,0
	CALL _sprintf
	ADIW R28,4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x64:
	LDI  R30,LOW(0)
	ST   -Y,R30
	ST   -Y,R30
	JMP  _lcd_gotoxy

;OPTIMIZER ADDED SUBROUTINE, CALLED 30 TIMES, CODE SIZE REDUCTION:55 WORDS
SUBOPT_0x65:
	LDI  R30,LOW(_linestr)
	LDI  R31,HIGH(_linestr)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x66:
	__GETB1MN _s_dt,5
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x67:
	__GETB1MN _s_dt,4
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x68:
	ST   -Y,R20
	ST   -Y,R19
	CALL _abs
	MOVW R26,R30
	LDI  R30,LOW(100)
	LDI  R31,HIGH(100)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x69:
	CALL __DIVW21U
	RJMP SUBOPT_0x5D

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x6A:
	LDI  R24,16
	CALL _sprintf
	ADIW R28,20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x6B:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+4
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x6C:
	LDI  R26,LOW(9)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_ds1820_rom_codes)
	SBCI R31,HIGH(-_ds1820_rom_codes)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x6D:
	LDI  R27,0
	SBRC R26,7
	SER  R27
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x6E:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+9
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x6F:
	ST   -Y,R30
	CALL _ds1820_set_alarm
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x70:
	LDD  R30,Y+1
	LDI  R26,LOW(9)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,LOW(-_ds1820_rom_codes)
	SBCI R31,HIGH(-_ds1820_rom_codes)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x71:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _param_str

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x72:
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	JMP  _set_term

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x73:
	ST   -Y,R30
	LDI  R30,LOW(187)
	ST   -Y,R30
	JMP  _set_term

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x74:
	LDI  R31,0
	MOVW R22,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x75:
	LDD  R30,Y+1
	LDI  R26,LOW(6)
	MUL  R30,R26
	MOVW R30,R0
	__ADDW1MN _termometers,5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x76:
	LDD  R30,Y+1
	LDI  R26,LOW(6)
	MUL  R30,R26
	MOVW R30,R0
	__ADDW1MN _termometers,3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x77:
	MOVW R26,R30
	CALL __GETW1P
	MOVW R26,R22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x78:
	ST   -Y,R30
	CALL _w1_write
	LDI  R16,LOW(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x79:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _ds1820_select

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x7A:
	ST   -Y,R31
	ST   -Y,R30
	CALL _ds1820_read_spd
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x7B:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x7C:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	RJMP SUBOPT_0x7A

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x7D:
	LDI  R30,LOW(72)
	ST   -Y,R30
	CALL _w1_write
	LDI  R30,LOW(15)
	LDI  R31,HIGH(15)
	RJMP SUBOPT_0xB

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x7E:
	LD   R26,Y
	LDD  R27,Y+1
	ST   X,R30
	LDI  R30,LOW(1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x7F:
	MOV  R30,R16
	LDI  R26,LOW(2)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,-LOW(9)
	MOV  R17,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x80:
	SUBI R30,LOW(-_settings)
	SBCI R31,HIGH(-_settings)
	MOVW R22,R30
	LDI  R26,LOW(3)
	MUL  R16,R26
	MOVW R30,R0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x81:
	LDS  R30,_sdt
	LDS  R31,_sdt+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x82:
	LDI  R27,0
	CP   R30,R26
	CPC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x83:
	__GETW1MN _sdt,5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x84:
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0x81
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x85:
	ST   -Y,R31
	ST   -Y,R30
	__GETW1MN _sdt,10
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x86:
	__GETW1MN _sdt,15
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x87:
	__GETW1MN _sdt,20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x88:
	LDI  R26,LOW(5)
	MUL  R17,R26
	MOVW R30,R0
	SUBI R30,LOW(-_settings)
	SBCI R31,HIGH(-_settings)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x89:
	LDI  R26,LOW(5)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_alerts)
	SBCI R31,HIGH(-_alerts)
	MOVW R26,R30
	CALL __GETW1P
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x8A:
	LDI  R26,LOW(5)
	LDI  R27,HIGH(5)
	CALL __MULW12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x8B:
	__POINTW1FN _0xA0000,170
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R16
	RJMP SUBOPT_0x5D

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x8C:
	LDI  R24,4
	CALL _sprintf
	ADIW R28,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 17 TIMES, CODE SIZE REDUCTION:45 WORDS
SUBOPT_0x8D:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R16
	RJMP SUBOPT_0x5D

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x8E:
	LDI  R24,8
	CALL _sprintf
	ADIW R28,12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x8F:
	LDD  R30,Y+15
	LDD  R31,Y+15+1
	RJMP SUBOPT_0x23

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x90:
	ST   -Y,R30
	__GETW1MN _curr_menu,3
	RJMP SUBOPT_0x71

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x91:
	ST   -Y,R31
	ST   -Y,R30
	__GETW2MN _curr_menu,3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x92:
	MOVW R26,R22
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,3
	LD   R30,X
	ST   -Y,R30
	JMP  _lcd_line_menu

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x93:
	CALL __SAVELOCR3
	__GETB1MN _curr_menu,2
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x94:
	ST   -Y,R30
	CALL _init_curr_menu
	LDI  R30,LOW(1)
	__PUTB1MN _curr_menu,10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x95:
	__GETW2MN _curr_menu,3
	MOV  R30,R18
	RJMP SUBOPT_0x74

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x96:
	__PUTWMRN _curr_menu,6,16,17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 46 TIMES, CODE SIZE REDUCTION:87 WORDS
SUBOPT_0x97:
	__PUTW1MN _curr_menu,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x98:
	__GETW1MN _curr_menu,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x99:
	LDI  R30,LOW(_dt_curr_menu)
	LDI  R31,HIGH(_dt_curr_menu)
	LDI  R26,LOW(_curr_menu)
	LDI  R27,HIGH(_curr_menu)
	LDI  R24,11
	CALL __COPYMML
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x9A:
	LDI  R30,LOW(0)
	__PUTB1MN _curr_menu,10
	__PUTB1MN _mode,5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x9B:
	LDI  R30,LOW(88)
	ST   -Y,R30
	JMP  _eeprom_write_struct

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x9C:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP SUBOPT_0x97

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x9D:
	LDD  R30,Y+2
	LDI  R26,LOW(10)
	MULS R30,R26
	MOVW R30,R0
	__GETW2MN _curr_menu,8
	ADD  R30,R26
	ADC  R31,R27
	RJMP SUBOPT_0x97

;OPTIMIZER ADDED SUBROUTINE, CALLED 39 TIMES, CODE SIZE REDUCTION:73 WORDS
SUBOPT_0x9E:
	__GETW2MN _curr_menu,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x9F:
	LDD  R30,Y+2
	LDI  R26,LOW(100)
	MULS R30,R26
	MOVW R30,R0
	RJMP SUBOPT_0x9E

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0xA0:
	ADD  R30,R26
	ADC  R31,R27
	RJMP SUBOPT_0x97

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0xA1:
	LDD  R30,Y+2
	LDI  R31,0
	SBRC R30,7
	SER  R31
	RJMP SUBOPT_0xA0

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA2:
	CALL __GETW1P
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA3:
	ST   -Y,R30
	CALL _i2c_write
	LDD  R30,Y+1
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA4:
	ST   -Y,R30
	CALL _i2c_write
	JMP  _i2c_start

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA5:
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _i2c_read

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA6:
	CALL __SAVELOCR3
	LDD  R30,Y+3
	SUBI R30,LOW(1)
	LDD  R26,Y+4
	MUL  R30,R26
	MOVW R30,R0
	MOV  R18,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA7:
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	STD  Z+0,R26
	STD  Z+1,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xA8:
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	SBIW R30,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA9:
	LDI  R26,LOW(1)
	LDI  R27,HIGH(1)
	STD  Z+0,R26
	STD  Z+1,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xAA:
	LDI  R30,LOW(_alarm)
	LDI  R31,HIGH(_alarm)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xAB:
	__POINTW2MN _prim_par,36
	LD   R30,Y
	LDI  R31,0
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xAC:
	CALL __SAVELOCR4
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,1
	MOVW R16,R30
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,2
	MOVW R18,R30
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R30,X
	CPI  R30,LOW(0x2)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xAD:
	MOVW R26,R16
	LD   R30,X
	SUBI R30,LOW(1)
	ST   X,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0xAE:
	__GETB1MN _signals,1
	SUBI R30,LOW(1)
	__PUTB1MN _signals,1
	SUBI R30,-LOW(1)
	__GETB1MN _signals,1
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xAF:
	ST   -Y,R31
	ST   -Y,R30
	CALL _update_lamp_status
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB0:
	ST   -Y,R31
	ST   -Y,R30
	CALL _init_lamp_status
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0xB1:
	LD   R30,Y
	LDI  R26,LOW(10)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,LOW(-_keys)
	SBCI R31,HIGH(-_keys)
	LD   R30,Z
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB2:
	LD   R30,Y
	LDI  R31,0
	SUBI R30,LOW(-_key_treated)
	SBCI R31,HIGH(-_key_treated)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB3:
	LDI  R26,LOW(10)
	MUL  R30,R26
	MOVW R30,R0
	__ADDW1MN _keys,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xB4:
	LDI  R26,LOW(10)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_keys)
	SBCI R31,HIGH(-_keys)
	LD   R30,Z
	CPI  R30,LOW(0xFF)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB5:
	LDI  R26,LOW(10)
	MUL  R16,R26
	MOVW R30,R0
	SUBI R30,LOW(-_keys)
	SBCI R31,HIGH(-_keys)
	LD   R30,Z
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB6:
	SUBI R30,LOW(-_keys)
	SBCI R31,HIGH(-_keys)
	LDI  R26,LOW(255)
	STD  Z+0,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 17 TIMES, CODE SIZE REDUCTION:29 WORDS
SUBOPT_0xB7:
	LDD  R30,Y+3
	LDI  R26,LOW(10)
	MUL  R30,R26
	MOVW R30,R0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB8:
	MOVW R26,R30
	CALL __GETW1P
	CPI  R30,LOW(0x64)
	LDI  R26,HIGH(0x64)
	CPC  R31,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0xB9:
	CALL _i2c_start
	LDI  R30,LOW(208)
	ST   -Y,R30
	JMP  _i2c_write

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xBA:
	ST   -Y,R30
	CALL _i2c_write
	LDD  R30,Y+2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xBB:
	LDI  R30,LOW(209)
	ST   -Y,R30
	CALL _i2c_write
	LDI  R30,LOW(1)
	ST   -Y,R30
	CALL _i2c_read
	ST   -Y,R30
	JMP  _bcd2bin

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xBC:
	ST   -Y,R30
	CALL _i2c_read
	ST   -Y,R30
	CALL _bcd2bin
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ST   X,R30
	RJMP SUBOPT_0xA5

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:24 WORDS
SUBOPT_0xBD:
	ST   -Y,R19
	LDD  R30,Y+15
	LDD  R31,Y+15+1
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,15
	ST   -Y,R31
	ST   -Y,R30
	JMP  __put_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xBE:
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	SBIW R30,4
	STD  Y+16,R30
	STD  Y+16+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0xBF:
	LDD  R30,Y+15
	LDD  R31,Y+15+1
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,15
	ST   -Y,R31
	ST   -Y,R30
	JMP  __put_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xC0:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,4
	CALL __GETW1P
	STD  Y+6,R30
	STD  Y+6+1,R31
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xC1:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,4
	CALL __GETW1P
	STD  Y+10,R30
	STD  Y+10+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0xC2:
	MOV  R15,R24
	SBIW R28,2
	ST   -Y,R17
	ST   -Y,R16
	MOVW R26,R28
	CALL __ADDW2R15
	MOVW R16,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC3:
	MOVW R26,R28
	ADIW R26,4
	CALL __ADDW2R15
	RJMP SUBOPT_0xA2

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xC4:
	ST   -Y,R17
	ST   -Y,R16
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	JMP  __print_G101


	.CSEG
	.equ __i2c_dir=__i2c_port-1
	.equ __i2c_pin=__i2c_port-2
_i2c_init:
	cbi  __i2c_port,__scl_bit
	cbi  __i2c_port,__sda_bit
	sbi  __i2c_dir,__scl_bit
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_delay2
_i2c_start:
	cbi  __i2c_dir,__sda_bit
	cbi  __i2c_dir,__scl_bit
	clr  r30
	nop
	sbis __i2c_pin,__sda_bit
	ret
	sbis __i2c_pin,__scl_bit
	ret
	rcall __i2c_delay1
	sbi  __i2c_dir,__sda_bit
	rcall __i2c_delay1
	sbi  __i2c_dir,__scl_bit
	ldi  r30,1
__i2c_delay1:
	ldi  r22,6
	rjmp __i2c_delay2l
_i2c_stop:
	sbi  __i2c_dir,__sda_bit
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__sda_bit
__i2c_delay2:
	ldi  r22,12
__i2c_delay2l:
	dec  r22
	brne __i2c_delay2l
	ret
_i2c_read:
	ldi  r23,8
__i2c_read0:
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
__i2c_read3:
	sbis __i2c_pin,__scl_bit
	rjmp __i2c_read3
	rcall __i2c_delay1
	clc
	sbic __i2c_pin,__sda_bit
	sec
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	rol  r30
	dec  r23
	brne __i2c_read0
	ld   r23,y+
	tst  r23
	brne __i2c_read1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_read2
__i2c_read1:
	sbi  __i2c_dir,__sda_bit
__i2c_read2:
	rcall __i2c_delay1
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_delay1

_i2c_write:
	ld   r30,y+
	ldi  r23,8
__i2c_write0:
	lsl  r30
	brcc __i2c_write1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_write2
__i2c_write1:
	sbi  __i2c_dir,__sda_bit
__i2c_write2:
	rcall __i2c_delay2
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
__i2c_write3:
	sbis __i2c_pin,__scl_bit
	rjmp __i2c_write3
	rcall __i2c_delay1
	sbi  __i2c_dir,__scl_bit
	dec  r23
	brne __i2c_write0
	cbi  __i2c_dir,__sda_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	ldi  r30,1
	sbic __i2c_pin,__sda_bit
	clr  r30
	sbi  __i2c_dir,__scl_bit
	ret

_delay_ms:
	ld   r30,y+
	ld   r31,y+
	adiw r30,0
	breq __delay_ms1
__delay_ms0:
	__DELAY_USW 0x39A
	wdr
	sbiw r30,1
	brne __delay_ms0
__delay_ms1:
	ret

_w1_init:
	clr  r30
	cbi  __w1_port,__w1_bit
	sbi  __w1_port-1,__w1_bit
	__DELAY_USW 0x1BA
	cbi  __w1_port-1,__w1_bit
	__DELAY_USB 0x11
	sbis __w1_port-2,__w1_bit
	ret
	__DELAY_USB 0x5D
	sbis __w1_port-2,__w1_bit
	inc  r30
	__DELAY_USW 0x167
	ret

__w1_read_bit:
	sbi  __w1_port-1,__w1_bit
	__DELAY_USB 0x2
	cbi  __w1_port-1,__w1_bit
	__DELAY_USB 0xE
	clc
	sbic __w1_port-2,__w1_bit
	sec
	ror  r30
	__DELAY_USB 0x62
	ret

__w1_write_bit:
	clt
	sbi  __w1_port-1,__w1_bit
	__DELAY_USB 0x2
	sbrc r23,0
	cbi  __w1_port-1,__w1_bit
	__DELAY_USB 0x10
	sbic __w1_port-2,__w1_bit
	rjmp __w1_write_bit0
	sbrs r23,0
	rjmp __w1_write_bit1
	ret
__w1_write_bit0:
	sbrs r23,0
	ret
__w1_write_bit1:
	__DELAY_USB 0x5C
	cbi  __w1_port-1,__w1_bit
	__DELAY_USB 0x6
	set
	ret

_w1_read:
	ldi  r22,8
	__w1_read0:
	rcall __w1_read_bit
	dec  r22
	brne __w1_read0
	ret

_w1_write:
	ldi  r22,8
	ld   r23,y+
	clr  r30
__w1_write0:
	rcall __w1_write_bit
	brtc __w1_write1
	ror  r23
	dec  r22
	brne __w1_write0
	inc  r30
__w1_write1:
	ret

_w1_search:
	push r20
	push r21
	clr  r1
	clr  r20
	ld   r26,y
	ldd  r27,y+1
__w1_search0:
	mov  r0,r1
	clr  r1
	rcall _w1_init
	tst  r30
	breq __w1_search7
	ldd  r30,y+2
	st   -y,r30
	rcall _w1_write
	ldi  r21,1
__w1_search1:
	cp   r21,r0
	brsh __w1_search6
	rcall __w1_read_bit
	sbrc r30,7
	rjmp __w1_search2
	rcall __w1_read_bit
	sbrc r30,7
	rjmp __w1_search3
	rcall __sel_bit
	and  r24,r25
	brne __w1_search3
	mov  r1,r21
	rjmp __w1_search3
__w1_search2:
	rcall __w1_read_bit
__w1_search3:
	rcall __sel_bit
	and  r24,r25
	ldi  r23,0
	breq __w1_search5
__w1_search4:
	ldi  r23,1
__w1_search5:
	rcall __w1_write_bit
	rjmp __w1_search13
__w1_search6:
	rcall __w1_read_bit
	sbrs r30,7
	rjmp __w1_search9
	rcall __w1_read_bit
	sbrs r30,7
	rjmp __w1_search8
__w1_search7:
	mov  r30,r20
	pop  r21
	pop  r20
	adiw r28,3
	ret
__w1_search8:
	set
	rcall __set_bit
	rjmp __w1_search4
__w1_search9:
	rcall __w1_read_bit
	sbrs r30,7
	rjmp __w1_search10
	rjmp __w1_search11
__w1_search10:
	cp   r21,r0
	breq __w1_search12
	mov  r1,r21
__w1_search11:
	clt
	rcall __set_bit
	clr  r23
	rcall __w1_write_bit
	rjmp __w1_search13
__w1_search12:
	set
	rcall __set_bit
	ldi  r23,1
	rcall __w1_write_bit
__w1_search13:
	inc  r21
	cpi  r21,65
	brlt __w1_search1
	rcall __w1_read_bit
	rol  r30
	rol  r30
	andi r30,1
	adiw r26,8
	st   x,r30
	sbiw r26,8
	inc  r20
	tst  r1
	breq __w1_search7
	ldi  r21,9
__w1_search14:
	ld   r30,x
	adiw r26,9
	st   x,r30
	sbiw r26,8
	dec  r21
	brne __w1_search14
	rjmp __w1_search0

__sel_bit:
	mov  r30,r21
	dec  r30
	mov  r22,r30
	lsr  r30
	lsr  r30
	lsr  r30
	clr  r31
	add  r30,r26
	adc  r31,r27
	ld   r24,z
	ldi  r25,1
	andi r22,7
__sel_bit0:
	breq __sel_bit1
	lsl  r25
	dec  r22
	rjmp __sel_bit0
__sel_bit1:
	ret

__set_bit:
	rcall __sel_bit
	brts __set_bit2
	com  r25
	and  r24,r25
	rjmp __set_bit3
__set_bit2:
	or   r24,r25
__set_bit3:
	st   z,r24
	ret

_w1_dow_crc8:
	clr  r30
	ld   r24,y
	tst  r24
	breq __w1_dow_crc83
	ldi  r22,0x18
	ldd  r26,y+1
	ldd  r27,y+2
__w1_dow_crc80:
	ldi  r25,8
	ld   r31,x+
__w1_dow_crc81:
	mov  r23,r31
	eor  r23,r30
	ror  r23
	brcc __w1_dow_crc82
	eor  r30,r22
__w1_dow_crc82:
	ror  r30
	lsr  r31
	dec  r25
	brne __w1_dow_crc81
	dec  r24
	brne __w1_dow_crc80
__w1_dow_crc83:
	adiw r28,3
	ret

__ADDW2R15:
	CLR  R0
	ADD  R26,R15
	ADC  R27,R0
	RET

__SUBD21:
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R25,R23
	RET

__ANEGW1:
	NEG  R31
	NEG  R30
	SBCI R31,0
	RET

__ANEGD1:
	COM  R31
	COM  R22
	COM  R23
	NEG  R30
	SBCI R31,-1
	SBCI R22,-1
	SBCI R23,-1
	RET

__LSLB12:
	TST  R30
	MOV  R0,R30
	MOV  R30,R26
	BREQ __LSLB12R
__LSLB12L:
	LSL  R30
	DEC  R0
	BRNE __LSLB12L
__LSLB12R:
	RET

__LSRW12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	BREQ __LSRW12R
__LSRW12L:
	LSR  R31
	ROR  R30
	DEC  R0
	BRNE __LSRW12L
__LSRW12R:
	RET

__LSLW4:
	LSL  R30
	ROL  R31
__LSLW3:
	LSL  R30
	ROL  R31
__LSLW2:
	LSL  R30
	ROL  R31
	LSL  R30
	ROL  R31
	RET

__ASRW4:
	ASR  R31
	ROR  R30
__ASRW3:
	ASR  R31
	ROR  R30
__ASRW2:
	ASR  R31
	ROR  R30
	ASR  R31
	ROR  R30
	RET

__LSRW2:
	LSR  R31
	ROR  R30
	LSR  R31
	ROR  R30
	RET

__CBD1:
	MOV  R31,R30
	ADD  R31,R31
	SBC  R31,R31
	MOV  R22,R31
	MOV  R23,R31
	RET

__CWD1:
	MOV  R22,R31
	ADD  R22,R22
	SBC  R22,R22
	MOV  R23,R22
	RET

__EQW12:
	CP   R30,R26
	CPC  R31,R27
	LDI  R30,1
	BREQ __EQW12T
	CLR  R30
__EQW12T:
	RET

__LNEGB1:
	TST  R30
	LDI  R30,1
	BREQ __LNEGB1F
	CLR  R30
__LNEGB1F:
	RET

__MULW12U:
	MUL  R31,R26
	MOV  R31,R0
	MUL  R30,R27
	ADD  R31,R0
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	RET

__MULD12U:
	MUL  R23,R26
	MOV  R23,R0
	MUL  R22,R27
	ADD  R23,R0
	MUL  R31,R24
	ADD  R23,R0
	MUL  R30,R25
	ADD  R23,R0
	MUL  R22,R26
	MOV  R22,R0
	ADD  R23,R1
	MUL  R31,R27
	ADD  R22,R0
	ADC  R23,R1
	MUL  R30,R24
	ADD  R22,R0
	ADC  R23,R1
	CLR  R24
	MUL  R31,R26
	MOV  R31,R0
	ADD  R22,R1
	ADC  R23,R24
	MUL  R30,R27
	ADD  R31,R0
	ADC  R22,R1
	ADC  R23,R24
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	ADC  R22,R24
	ADC  R23,R24
	RET

__MULW12:
	RCALL __CHKSIGNW
	RCALL __MULW12U
	BRTC __MULW121
	RCALL __ANEGW1
__MULW121:
	RET

__MULD12:
	RCALL __CHKSIGND
	RCALL __MULD12U
	BRTC __MULD121
	RCALL __ANEGD1
__MULD121:
	RET

__DIVW21U:
	CLR  R0
	CLR  R1
	LDI  R25,16
__DIVW21U1:
	LSL  R26
	ROL  R27
	ROL  R0
	ROL  R1
	SUB  R0,R30
	SBC  R1,R31
	BRCC __DIVW21U2
	ADD  R0,R30
	ADC  R1,R31
	RJMP __DIVW21U3
__DIVW21U2:
	SBR  R26,1
__DIVW21U3:
	DEC  R25
	BRNE __DIVW21U1
	MOVW R30,R26
	MOVW R26,R0
	RET

__DIVW21:
	RCALL __CHKSIGNW
	RCALL __DIVW21U
	BRTC __DIVW211
	RCALL __ANEGW1
__DIVW211:
	RET

__DIVD21U:
	PUSH R19
	PUSH R20
	PUSH R21
	CLR  R0
	CLR  R1
	CLR  R20
	CLR  R21
	LDI  R19,32
__DIVD21U1:
	LSL  R26
	ROL  R27
	ROL  R24
	ROL  R25
	ROL  R0
	ROL  R1
	ROL  R20
	ROL  R21
	SUB  R0,R30
	SBC  R1,R31
	SBC  R20,R22
	SBC  R21,R23
	BRCC __DIVD21U2
	ADD  R0,R30
	ADC  R1,R31
	ADC  R20,R22
	ADC  R21,R23
	RJMP __DIVD21U3
__DIVD21U2:
	SBR  R26,1
__DIVD21U3:
	DEC  R19
	BRNE __DIVD21U1
	MOVW R30,R26
	MOVW R22,R24
	MOVW R26,R0
	MOVW R24,R20
	POP  R21
	POP  R20
	POP  R19
	RET

__DIVD21:
	RCALL __CHKSIGND
	RCALL __DIVD21U
	BRTC __DIVD211
	RCALL __ANEGD1
__DIVD211:
	RET

__MODW21U:
	RCALL __DIVW21U
	MOVW R30,R26
	RET

__MODW21:
	CLT
	SBRS R27,7
	RJMP __MODW211
	COM  R26
	COM  R27
	ADIW R26,1
	SET
__MODW211:
	SBRC R31,7
	RCALL __ANEGW1
	RCALL __DIVW21U
	MOVW R30,R26
	BRTC __MODW212
	RCALL __ANEGW1
__MODW212:
	RET

__CHKSIGNW:
	CLT
	SBRS R31,7
	RJMP __CHKSW1
	RCALL __ANEGW1
	SET
__CHKSW1:
	SBRS R27,7
	RJMP __CHKSW2
	COM  R26
	COM  R27
	ADIW R26,1
	BLD  R0,0
	INC  R0
	BST  R0,0
__CHKSW2:
	RET

__CHKSIGND:
	CLT
	SBRS R23,7
	RJMP __CHKSD1
	RCALL __ANEGD1
	SET
__CHKSD1:
	SBRS R25,7
	RJMP __CHKSD2
	CLR  R0
	COM  R26
	COM  R27
	COM  R24
	COM  R25
	ADIW R26,1
	ADC  R24,R0
	ADC  R25,R0
	BLD  R0,0
	INC  R0
	BST  R0,0
__CHKSD2:
	RET

__GETW1P:
	LD   R30,X+
	LD   R31,X
	SBIW R26,1
	RET

__GETW1PF:
	LPM  R0,Z+
	LPM  R31,Z
	MOV  R30,R0
	RET

__PUTPARD1:
	ST   -Y,R23
	ST   -Y,R22
	ST   -Y,R31
	ST   -Y,R30
	RET

__COPYMML:
	CLR  R25
__COPYMM:
	PUSH R30
	PUSH R31
__COPYMM0:
	LD   R22,Z+
	ST   X+,R22
	SBIW R24,1
	BRNE __COPYMM0
	POP  R31
	POP  R30
	RET

__ROUND_REPACK:
	TST  R21
	BRPL __REPACK
	CPI  R21,0x80
	BRNE __ROUND_REPACK0
	SBRS R30,0
	RJMP __REPACK
__ROUND_REPACK0:
	ADIW R30,1
	ADC  R22,R25
	ADC  R23,R25
	BRVS __REPACK1

__REPACK:
	LDI  R21,0x80
	EOR  R21,R23
	BRNE __REPACK0
	PUSH R21
	RJMP __ZERORES
__REPACK0:
	CPI  R21,0xFF
	BREQ __REPACK1
	LSL  R22
	LSL  R0
	ROR  R21
	ROR  R22
	MOV  R23,R21
	RET
__REPACK1:
	PUSH R21
	TST  R0
	BRMI __REPACK2
	RJMP __MAXRES
__REPACK2:
	RJMP __MINRES

__UNPACK:
	LDI  R21,0x80
	MOV  R1,R25
	AND  R1,R21
	LSL  R24
	ROL  R25
	EOR  R25,R21
	LSL  R21
	ROR  R24

__UNPACK1:
	LDI  R21,0x80
	MOV  R0,R23
	AND  R0,R21
	LSL  R22
	ROL  R23
	EOR  R23,R21
	LSL  R21
	ROR  R22
	RET

__CFD1U:
	SET
	RJMP __CFD1U0
__CFD1:
	CLT
__CFD1U0:
	PUSH R21
	RCALL __UNPACK1
	CPI  R23,0x80
	BRLO __CFD10
	CPI  R23,0xFF
	BRCC __CFD10
	RJMP __ZERORES
__CFD10:
	LDI  R21,22
	SUB  R21,R23
	BRPL __CFD11
	NEG  R21
	CPI  R21,8
	BRTC __CFD19
	CPI  R21,9
__CFD19:
	BRLO __CFD17
	SER  R30
	SER  R31
	SER  R22
	LDI  R23,0x7F
	BLD  R23,7
	RJMP __CFD15
__CFD17:
	CLR  R23
	TST  R21
	BREQ __CFD15
__CFD18:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	DEC  R21
	BRNE __CFD18
	RJMP __CFD15
__CFD11:
	CLR  R23
__CFD12:
	CPI  R21,8
	BRLO __CFD13
	MOV  R30,R31
	MOV  R31,R22
	MOV  R22,R23
	SUBI R21,8
	RJMP __CFD12
__CFD13:
	TST  R21
	BREQ __CFD15
__CFD14:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	DEC  R21
	BRNE __CFD14
__CFD15:
	TST  R0
	BRPL __CFD16
	RCALL __ANEGD1
__CFD16:
	POP  R21
	RET

__CDF1U:
	SET
	RJMP __CDF1U0
__CDF1:
	CLT
__CDF1U0:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	BREQ __CDF10
	CLR  R0
	BRTS __CDF11
	TST  R23
	BRPL __CDF11
	COM  R0
	RCALL __ANEGD1
__CDF11:
	MOV  R1,R23
	LDI  R23,30
	TST  R1
__CDF12:
	BRMI __CDF13
	DEC  R23
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R1
	RJMP __CDF12
__CDF13:
	MOV  R30,R31
	MOV  R31,R22
	MOV  R22,R1
	PUSH R21
	RCALL __REPACK
	POP  R21
__CDF10:
	RET

__ZERORES:
	CLR  R30
	CLR  R31
	CLR  R22
	CLR  R23
	POP  R21
	RET

__MINRES:
	SER  R30
	SER  R31
	LDI  R22,0x7F
	SER  R23
	POP  R21
	RET

__MAXRES:
	SER  R30
	SER  R31
	LDI  R22,0x7F
	LDI  R23,0x7F
	POP  R21
	RET

__MULF12:
	PUSH R21
	RCALL __UNPACK
	CPI  R23,0x80
	BREQ __ZERORES
	CPI  R25,0x80
	BREQ __ZERORES
	EOR  R0,R1
	SEC
	ADC  R23,R25
	BRVC __MULF124
	BRLT __ZERORES
__MULF125:
	TST  R0
	BRMI __MINRES
	RJMP __MAXRES
__MULF124:
	PUSH R0
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	CLR  R17
	CLR  R18
	CLR  R25
	MUL  R22,R24
	MOVW R20,R0
	MUL  R24,R31
	MOV  R19,R0
	ADD  R20,R1
	ADC  R21,R25
	MUL  R22,R27
	ADD  R19,R0
	ADC  R20,R1
	ADC  R21,R25
	MUL  R24,R30
	RCALL __MULF126
	MUL  R27,R31
	RCALL __MULF126
	MUL  R22,R26
	RCALL __MULF126
	MUL  R27,R30
	RCALL __MULF127
	MUL  R26,R31
	RCALL __MULF127
	MUL  R26,R30
	ADD  R17,R1
	ADC  R18,R25
	ADC  R19,R25
	ADC  R20,R25
	ADC  R21,R25
	MOV  R30,R19
	MOV  R31,R20
	MOV  R22,R21
	MOV  R21,R18
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	POP  R0
	TST  R22
	BRMI __MULF122
	LSL  R21
	ROL  R30
	ROL  R31
	ROL  R22
	RJMP __MULF123
__MULF122:
	INC  R23
	BRVS __MULF125
__MULF123:
	RCALL __ROUND_REPACK
	POP  R21
	RET

__MULF127:
	ADD  R17,R0
	ADC  R18,R1
	ADC  R19,R25
	RJMP __MULF128
__MULF126:
	ADD  R18,R0
	ADC  R19,R1
__MULF128:
	ADC  R20,R25
	ADC  R21,R25
	RET

__DIVF21:
	PUSH R21
	RCALL __UNPACK
	CPI  R23,0x80
	BRNE __DIVF210
	TST  R1
__DIVF211:
	BRPL __DIVF219
	RJMP __MINRES
__DIVF219:
	RJMP __MAXRES
__DIVF210:
	CPI  R25,0x80
	BRNE __DIVF218
__DIVF217:
	RJMP __ZERORES
__DIVF218:
	EOR  R0,R1
	SEC
	SBC  R25,R23
	BRVC __DIVF216
	BRLT __DIVF217
	TST  R0
	RJMP __DIVF211
__DIVF216:
	MOV  R23,R25
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	CLR  R1
	CLR  R17
	CLR  R18
	CLR  R19
	CLR  R20
	CLR  R21
	LDI  R25,32
__DIVF212:
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	CPC  R20,R17
	BRLO __DIVF213
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R20,R17
	SEC
	RJMP __DIVF214
__DIVF213:
	CLC
__DIVF214:
	ROL  R21
	ROL  R18
	ROL  R19
	ROL  R1
	ROL  R26
	ROL  R27
	ROL  R24
	ROL  R20
	DEC  R25
	BRNE __DIVF212
	MOVW R30,R18
	MOV  R22,R1
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	TST  R22
	BRMI __DIVF215
	LSL  R21
	ROL  R30
	ROL  R31
	ROL  R22
	DEC  R23
	BRVS __DIVF217
__DIVF215:
	RCALL __ROUND_REPACK
	POP  R21
	RET

__SAVELOCR6:
	ST   -Y,R21
__SAVELOCR5:
	ST   -Y,R20
__SAVELOCR4:
	ST   -Y,R19
__SAVELOCR3:
	ST   -Y,R18
__SAVELOCR2:
	ST   -Y,R17
	ST   -Y,R16
	RET

__LOADLOCR6:
	LDD  R21,Y+5
__LOADLOCR5:
	LDD  R20,Y+4
__LOADLOCR4:
	LDD  R19,Y+3
__LOADLOCR3:
	LDD  R18,Y+2
__LOADLOCR2:
	LDD  R17,Y+1
	LD   R16,Y
	RET

__INITLOCB:
__INITLOCW:
	ADD R26,R28
	ADC R27,R29
__INITLOC0:
	LPM  R0,Z+
	ST   X+,R0
	DEC  R24
	BRNE __INITLOC0
	RET

;END OF CODE MARKER
__END_OF_CODE:
